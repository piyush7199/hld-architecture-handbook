# 1.2.1 System Architecture Styles: Fundamental and Distributed Models

## Intuitive Explanation

Imagine you are running a restaurant ordering system:

1. **The Client-Server Model (The Waiter):** The client (you) asks the waiter (the server) for a menu. This is the
   simplest request/response model that underpins almost everything.
2. **The Monolith (The Single Kitchen):** All functions‚Äîmenu, order taking, inventory, and payment‚Äîare handled by a
   single, tightly-knit codebase. If the fryer breaks, the whole system might stop.
3. **Microservices (The Food Court):** Services like Menu and Payment are separate and independent. They can be updated
   or fixed without affecting each other.
4. **Serverless (The Outsourced Vendor):** You pay a vendor (cloud provider) only when you need a specific function (
   e.g., generating an invoice). You don't manage the kitchen or the waiters; the vendor scales the function instantly
   and charges you per use.
5. **Peer-to-Peer (P2P) (The Bartering System):** There is no central waiter or kitchen. You trade goods directly with
   other customers in the restaurant.

---

## In-Depth Analysis

### 1. Client-Server Architecture

This is the most common model where a client (e.g., a web browser, mobile app) requests a resource or service from a
server.

- **Characteristics:** Request-response cycle, the client is dependent on the server, and the server is typically
  stateless (
  it doesn't save client session data locally).

### 2. Monolithic Architecture

A monolithic architecture is a unified approach where all logical components are combined into a single, cohesive unit.
It shares one codebase and one database.

- **Communication:** Simple, internal function calls.
- **Deployment:** Single deployment unit.
- **Scaling:** Primarily Vertical Scaling (adding more resources to the single server).
- **Trade-off:** Low initial complexity, but slow development and deployment at scale.

### 3. Microservices Architecture

Microservices structure an application as a collection of services that are **highly maintainable**, **testable**, *
*loosely coupled**, and independently deployable.

- **Communication:** Inter-process communication (IPC) via HTTP/REST, gRPC, or Asynchronous Messaging.
- **Deployment:** Independent deployment per service.
- **Scaling:** Horizontal Scaling (adding more instances of the specific service under load).
- **Trade-off:** Excellent horizontal scalability, but adds operational complexity (networking, tracing, distributed
  logging).

### 4. Serverless Architecture (Function as a Service - FaaS)

Allows developers to build and run application functionality without managing the underlying infrastructure. The cloud
provider dynamically manages the allocation of machine resources.

- **Key Benefit (Cost/Scale):** Pay-per-execution. Scales to zero when not in use and scales instantly when traffic
  spikes.
- **Trade-off:** Cold Starts (latency penalty when a function is first called after being idle) and reliance on vendor
  ecosystems.

### 5. Peer-to-Peer (P2P) Architecture

A distributed application architecture that partitions tasks or workload between peers. Each peer is both a client and a
server.

- **Key Benefit (Resilience):** No central SPOF (Single Point of Failure). Highly resilient to network failures.
- **Trade-off:** Discovery (finding other peers) and Consistency (data integrity is hard to guarantee).

### Key Concepts / Tradeoffs**

| Choice                      | Rationale                                                                                                                             | Trade-off / Future Scalability Issue                                                                                     |
|-----------------------------|---------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------|
| Serverless (FaaS)           | Choose for highly volatile or infrequent workload components (e.g., image processing, CRON jobs) to optimize cost and elastic scale.  | Vendor Lock-in and difficulty managing long-running processes or complex state.                                          |
| Monolith (Starting Phase)   | Low initial complexity, faster deployment, simpler cross-cutting concerns (logging, security).                                        | The deployment pipeline will slow down as the codebase grows, creating a Single Point of Failure (SPOF).                 |
| Microservices (Scale Phase) | Handles high, variable traffic by scaling services independently; enables large, independent teams.                                   | Latency can increase due to network hops. Managing distributed state and debugging across dozens of services is complex. |
| P2P                         | Best for systems where censorship resistance or high resiliency against server failure is paramount (e.g., blockchain, file sharing). | High latency and poor performance compared to centralized systems; managing data consistency is extremely difficult.     |

---

## üí° Real-World Use Cases

- **AWS Lambda / Google Cloud Functions:** Classic examples of Serverless where functions execute based on triggers (
  e.g., file uploaded to storage ‚Üí trigger function ‚Üí image compressed).
- **Blockchain / BitTorrent:** Rely on P2P to distribute data and consensus across a global network without centralized
  control.
- **Modern Web Apps:** Use Client-Server for the front-end/back-end split, often implemented using Microservices in the
  backend.

---

## ‚úèÔ∏è Design Challenge

### Problems

You are designing an internal corporate finance application. It has 500 users, strict security requirements, and low
traffic. Would you choose a Monolithic or Microservices architecture and why? What would be the biggest risk associated
with your choice?

### Solution

#### üß© Scenario Summary

- Application type: Internal corporate finance system
- Users: ~500 (small, known group)
- Traffic: Low
- Requirements: Strict security and compliance
- Goal: Reliability, simplicity, and maintainability

#### ‚úÖ Choice: Monolithic Architecture

**Reasoning**

1. Simplicity Over Complexity
    - A monolith is easier and faster to develop, test, secure, and deploy.
    - With low scale and a small user base, the overhead of distributed systems (network calls, service discovery, CI/CD
      pipelines, observability) adds unnecessary complexity.

2. Tight Security and Compliance
    - Easier to enforce strict security policies (authentication, authorization, auditing) in one unified codebase and
      database.
    - Fewer inter-service communication channels means a smaller attack surface.

3. Operational Efficiency
    - Only 500 internal users ‚Üí scaling horizontally or regionally is unnecessary.
    - Monolith allows simpler infrastructure: one app server + one database + load balancer.

4. Low Change Velocity
    - Internal finance apps change slowly, with well-defined workflows and fewer independent teams.
    - Microservices would add overhead without real organizational benefit.

#### ‚ö†Ô∏è Biggest Risk: Scalability & Modularity Later

The main risk of a monolith is future rigidity:

- As the application grows (e.g., more modules like billing, reporting, forecasting), it may become harder to maintain
  and scale independently.
- Deployments become slower (a small change requires redeploying the entire app).
- If more teams join development, coordination becomes painful.

However, ‚Äî with good internal modular design (layered architecture, clean boundaries, domain-driven modules), you can
delay or mitigate this risk significantly.

#### üß† When Microservices Might Be Justified

If the finance app later needs:

- Integration with many external systems (e.g., ERP, HR, compliance APIs),
- Separate scaling for compute-heavy analytics,
- Or independent release cycles for different modules (e.g., payments vs reports),

‚Üí Then refactoring certain parts into microservices gradually would make sense.

#### ‚úÖ Final Summary

| Aspect                    | Decision                                                                   | Rationale                                                     |
|---------------------------|----------------------------------------------------------------------------|---------------------------------------------------------------|
| **Architecture**          | **Monolithic**                                                             | Simpler, cheaper, more secure for low-traffic internal system |
| **Why not Microservices** | Overhead, unnecessary complexity, higher operational cost                  |                                                               |
| **Biggest Risk**          | Future scalability and modularity challenges if system grows significantly |                                                               |
