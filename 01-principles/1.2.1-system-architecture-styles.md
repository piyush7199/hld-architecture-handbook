# 1.2.1 System Architecture Styles: Monoliths, Microservices, and Event-Driven

## Intuitive Explanation

Imagine you are running a restaurant ordering system:

1. **The Monolith (The Single Kitchen):** This is one giant application where all functions‚Äîmenu, order taking,
   inventory, and payment‚Äîare handled by a single, tightly-knit codebase, all deployed together. If the fryer breaks (a
   bug in order processing), the whole restaurant might shut down.
2. **Microservices (The Food Court):** This is a collection of small, independent applications. The Menu Service is
   separate from the Order Service, which is separate from the Payment Service. Each service can be updated or fixed
   without affecting the others. If the Payment Service goes down, customers can still browse the menu and place
   orders (which will be processed later).
3. **Event-Driven Architecture (The Pager System):** This is a communication style where services don't talk directly
   but communicate using notifications (events). The Order Service broadcasts a message: "New Order Placed!" The
   Inventory Service and the Notification Service listen for that message and react independently.

---

## In-Depth Analysis

### Monolithic Architecture

A monolithic architecture is a unified approach where all logical components are combined into a single, cohesive unit.
It shares one codebase and one database.

- **Communication:** Simple, internal function calls.
- **Deployment:** Single deployment unit.
- **Scaling:** Primarily Vertical Scaling (adding more resources to the single server).

### Microservices Architecture

Microservices structure an application as a collection of services that are **highly maintainable**, **testable**, *
*loosely coupled**, and independently deployable.

- **Communication:** Inter-process communication (IPC) via HTTP/REST, gRPC, or Asynchronous Messaging.
- **Deployment:** Independent deployment per service.
- **Scaling:** Horizontal Scaling (adding more instances of the specific service under load).

### Event-Driven Architecture (EDA)

EDA uses a publish/subscribe model, centralizing communication through a message broker `(Kafka, RabbitMQ)`. Services
publish Events (facts that happened) and other services Subscribe to events they care about.

- **Decoupling:** Services are fully decoupled; the publisher doesn't know who the consumers are.
- **Scalability:** Excellent for high-write systems where processing can be delayed (asynchronous).

**Key Concepts / Tradeoffs**

| Choice                       | Rationale                                                                                              | Trade-off / Future Scalability Issue                                                                                     |
|------------------------------|--------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------|
| Monolith (Starting Phase)    | Low initial complexity, faster deployment, simpler cross-cutting concerns (logging, security).         | The deployment pipeline will slow down as the codebase grows, creating a Single Point of Failure (SPOF).                 |
| Microservices (Scale Phase)  | Handles high, variable traffic by scaling services independently; enables large, independent teams.    | Latency can increase due to network hops. Managing distributed state and debugging across dozens of services is complex. |
| Event-Driven (Communication) | Used for non-critical, background tasks (e.g., sending emails) that do not need an immediate response. | Eventual Consistency: Data takes time to propagate across the system, making immediate querying unreliable.              |

---

## üí° Real-World Use Cases

- **Netflix:** Classic example of microservices, allowing independent teams to deploy features quickly across streaming
  and billing.
- **E-commerce (Order Fulfillment):** A perfect use case for EDA. The Order Service publishes an event (ORDER_PAID). The
  Inventory Service, Shipping Service, and Email Service all consume this single event asynchronously.

---

## ‚úèÔ∏è Design Challenge

### Problems

You are designing an internal corporate finance application. It has 500 users, strict security requirements, and low
traffic. Would you choose a Monolithic or Microservices architecture and why? What would be the biggest risk associated
with your choice?

### Solution

#### üß© Scenario Summary

- Application type: Internal corporate finance system
- Users: ~500 (small, known group)
- Traffic: Low
- Requirements: Strict security and compliance
- Goal: Reliability, simplicity, and maintainability

#### ‚úÖ Choice: Monolithic Architecture

**Reasoning**

1. Simplicity Over Complexity
    - A monolith is easier and faster to develop, test, secure, and deploy.
    - With low scale and a small user base, the overhead of distributed systems (network calls, service discovery, CI/CD
      pipelines, observability) adds unnecessary complexity.

2. Tight Security and Compliance
    - Easier to enforce strict security policies (authentication, authorization, auditing) in one unified codebase and
      database.
    - Fewer inter-service communication channels means a smaller attack surface.

3. Operational Efficiency
    - Only 500 internal users ‚Üí scaling horizontally or regionally is unnecessary.
    - Monolith allows simpler infrastructure: one app server + one database + load balancer.

4. Low Change Velocity
    - Internal finance apps change slowly, with well-defined workflows and fewer independent teams.
    - Microservices would add overhead without real organizational benefit.

#### ‚ö†Ô∏è Biggest Risk: Scalability & Modularity Later

The main risk of a monolith is future rigidity:

- As the application grows (e.g., more modules like billing, reporting, forecasting), it may become harder to maintain
  and scale independently.
- Deployments become slower (a small change requires redeploying the entire app).
- If more teams join development, coordination becomes painful.

However, ‚Äî with good internal modular design (layered architecture, clean boundaries, domain-driven modules), you can
delay or mitigate this risk significantly.

#### üß† When Microservices Might Be Justified

If the finance app later needs:

- Integration with many external systems (e.g., ERP, HR, compliance APIs),
- Separate scaling for compute-heavy analytics,
- Or independent release cycles for different modules (e.g., payments vs reports),

‚Üí Then refactoring certain parts into microservices gradually would make sense.

#### ‚úÖ Final Summary

| Aspect                    | Decision                                                                   | Rationale                                                     |
|---------------------------|----------------------------------------------------------------------------|---------------------------------------------------------------|
| **Architecture**          | **Monolithic**                                                             | Simpler, cheaper, more secure for low-traffic internal system |
| **Why not Microservices** | Overhead, unnecessary complexity, higher operational cost                  |                                                               |
| **Biggest Risk**          | Future scalability and modularity challenges if system grows significantly |                                                               |
