# 1.2.4 Domain-Driven Design (DDD): Aligning Software with Business Reality

## Intuitive Explanation

Domain-Driven Design (DDD) is a software design philosophy that focuses on modeling software to match the business domain it serves. Instead of thinking "What database tables do I need?", you think "What business concepts and rules exist, and how do they interact?"

- **Domain:** The business or problem space you're modeling (e.g., e-commerce, banking, logistics).
- **The Goal:** Create software that speaks the same language as domain experts (business people), making it easier to understand, maintain, and evolve.
- **Why It Matters:** In large systems, especially microservices, DDD helps you draw boundaries between services and avoid creating a "distributed monolith."

---

## In-Depth Analysis

### 1. Core DDD Concepts

#### A. Ubiquitous Language

A shared vocabulary between developers and domain experts, used consistently everywhere: code, documentation, conversations.

**Problem Without It:**
```
Developer: "Let's update the cart_items table when user_action is 2"
Business: "What's user_action 2? Do you mean when they add to cart?"
Developer: "Yes, or maybe checkout... I need to check the code"
```

**Solution With It:**
```
Developer: "When a Customer adds an Item to their ShoppingCart..."
Business: "Yes, exactly! And what happens if the Item is out of stock?"
(Same language, clear communication)
```

**Implementation:**
```python
# Good: Uses business language
class ShoppingCart:
    def add_item(self, item: Item, quantity: int):
        if not item.is_in_stock():
            raise OutOfStockException(item)
        self.items.append(CartItem(item, quantity))

# Bad: Technical jargon
class UserDataStore:
    def insert_row(self, table_id: int, data: dict):
        self.db.execute(f"INSERT INTO {table_id} VALUES ...")
```

#### B. Bounded Context

A boundary within which a particular domain model is defined and applicable. Outside this boundary, a different model may apply to the same concepts.

**Example: E-commerce System**

```
┌─────────────────────────────┐
│  Catalog Bounded Context    │
│  - Product (SKU, name, etc) │
│  - Category                  │
│  - Inventory                 │
└─────────────────────────────┘

┌─────────────────────────────┐
│  Shopping Bounded Context   │
│  - Product (basic info)     │  <- Different Product model!
│  - Cart                     │
│  - Cart Item                │
└─────────────────────────────┘

┌─────────────────────────────┐
│  Payment Bounded Context    │
│  - Order                    │
│  - Payment Method           │
│  - Transaction              │
└─────────────────────────────┘
```

**Key Insight:**
- "Product" in the Catalog context includes detailed inventory, specifications, categories
- "Product" in the Shopping context only needs basic info (name, price, image)
- Different contexts, different models, different needs

**In Microservices:**
- Each bounded context typically becomes a microservice
- Services have separate databases (not shared)
- Services communicate via well-defined APIs or events

#### C. Entities

Objects with a unique identity that persists over time, even if their attributes change.

**Characteristics:**
- Has a unique identifier (ID)
- Mutable (attributes can change)
- Identity-based equality

**Example:**
```python
class User(Entity):
    def __init__(self, user_id: UUID, email: str, name: str):
        self.user_id = user_id  # Unique identifier
        self.email = email
        self.name = name
    
    def change_name(self, new_name: str):
        self.name = new_name
        # Still the same user, even though name changed
    
    def __eq__(self, other):
        # Equality based on ID, not attributes
        return self.user_id == other.user_id
```

**Real-World Example:**
- Your bank account is an Entity
- Balance changes over time, but it's still YOUR account
- Identified by account number, not by balance

#### D. Value Objects

Objects defined only by their attributes, with no unique identity. Two value objects with the same attributes are considered identical.

**Characteristics:**
- No unique identifier
- Immutable
- Equality based on all attributes

**Example:**
```python
class Money(ValueObject):
    def __init__(self, amount: Decimal, currency: str):
        self._amount = amount
        self._currency = currency
    
    @property
    def amount(self):
        return self._amount
    
    @property
    def currency(self):
        return self._currency
    
    def add(self, other: 'Money') -> 'Money':
        if self.currency != other.currency:
            raise ValueError("Cannot add different currencies")
        # Returns NEW object (immutable)
        return Money(self.amount + other.amount, self.currency)
    
    def __eq__(self, other):
        # Equality based on all attributes
        return (self.amount == other.amount and 
                self.currency == other.currency)

# Usage
price1 = Money(Decimal('10.00'), 'USD')
price2 = Money(Decimal('10.00'), 'USD')
price1 == price2  # True - same value, considered identical
```

**More Examples:**
- Address: "123 Main St, NY, 10001" - no identity, just a value
- Date Range: "2024-01-01 to 2024-12-31"
- Geolocation: (latitude: 40.7128, longitude: -74.0060)

#### E. Aggregates

A cluster of Entities and Value Objects that are treated as a single unit for data changes. The Aggregate has a root Entity that controls access.

**Rules:**
1. External objects can only reference the Aggregate Root
2. All modifications go through the Aggregate Root
3. Aggregate boundaries define transaction boundaries
4. One aggregate per transaction

**Example: Order Aggregate**

```python
class Order(AggregateRoot):  # Order is the root
    def __init__(self, order_id: UUID, customer_id: UUID):
        self.order_id = order_id
        self.customer_id = customer_id
        self.order_items: List[OrderItem] = []  # Part of aggregate
        self.status = OrderStatus.PENDING
        self.total = Money(Decimal('0'), 'USD')
    
    def add_item(self, product_id: UUID, quantity: int, price: Money):
        # All changes go through the root
        item = OrderItem(product_id, quantity, price)
        self.order_items.append(item)
        self._recalculate_total()
    
    def remove_item(self, product_id: UUID):
        # Business rule enforced by root
        if self.status != OrderStatus.PENDING:
            raise InvalidOperationException("Cannot modify confirmed order")
        self.order_items = [i for i in self.order_items 
                           if i.product_id != product_id]
        self._recalculate_total()
    
    def confirm(self):
        # Business invariant
        if len(self.order_items) == 0:
            raise InvalidOperationException("Cannot confirm empty order")
        self.status = OrderStatus.CONFIRMED
    
    def _recalculate_total(self):
        self.total = sum(item.subtotal() for item in self.order_items)

class OrderItem:  # NOT directly accessible from outside
    def __init__(self, product_id: UUID, quantity: int, price: Money):
        self.product_id = product_id
        self.quantity = quantity
        self.price = price
    
    def subtotal(self) -> Money:
        return Money(self.price.amount * self.quantity, self.price.currency)

# Usage
order = Order(order_id, customer_id)
order.add_item(product_id, quantity=2, price=Money(Decimal('10'), 'USD'))
order.confirm()

# WRONG - don't access OrderItem directly
# order.order_items[0].quantity = 100  # Bypasses business logic!
```

**Aggregate Design Guidelines:**

| Guideline | Reason | Example |
|-----------|--------|---------|
| **Small aggregates** | Large aggregates cause performance issues and contention | Order with items (good) vs Order with items + customer + shipping address + payment history (bad) |
| **Reference by ID** | Don't embed entire aggregates inside each other | Order stores `customer_id`, not full Customer object |
| **Eventual consistency between aggregates** | Can't update multiple aggregates in one transaction | Order and Inventory are separate aggregates |
| **One aggregate per transaction** | Maintains clear boundaries | Updating Order doesn't update Inventory in same transaction |

#### F. Domain Events

Events that represent something significant that happened in the domain.

**Characteristics:**
- Named in past tense (something already happened)
- Immutable
- Contains all data needed to understand what happened
- Used for eventual consistency between aggregates

**Example:**
```python
class OrderPlaced(DomainEvent):
    def __init__(self, order_id: UUID, customer_id: UUID, 
                 items: List[OrderItem], total: Money, timestamp: datetime):
        self.order_id = order_id
        self.customer_id = customer_id
        self.items = items
        self.total = total
        self.timestamp = timestamp
        self.event_id = uuid4()

class Order(AggregateRoot):
    def confirm(self):
        # State change
        self.status = OrderStatus.CONFIRMED
        
        # Raise domain event
        self.raise_event(OrderPlaced(
            order_id=self.order_id,
            customer_id=self.customer_id,
            items=self.order_items,
            total=self.total,
            timestamp=datetime.now()
        ))
```

**Event Flow:**
```
Order Service                    Inventory Service
     │                                 │
     │ 1. order.confirm()              │
     │ 2. Save order to DB             │
     │ 3. Publish OrderPlaced event ──→│
     │                                 │ 4. Consume event
     │                                 │ 5. Decrement inventory
     │                                 │ 6. Publish InventoryReserved
     │←────────────────────────────────│
     │ 7. Mark order as reserved       │
```

### 2. Strategic Design Patterns

#### A. Context Mapping

Defines relationships between bounded contexts.

**Relationship Types:**

| Pattern | Description | Use Case |
|---------|-------------|----------|
| **Shared Kernel** | Two contexts share a subset of the domain model | Small, tightly-aligned teams |
| **Customer/Supplier** | Supplier provides services to customer | Payment provider (supplier) to E-commerce (customer) |
| **Conformist** | Downstream context accepts upstream model as-is | Using external API (Google Maps, Stripe) |
| **Anti-Corruption Layer (ACL)** | Translates between different models | Protecting your model from external systems |
| **Separate Ways** | No relationship between contexts | Completely independent domains |
| **Partnership** | Two contexts work together, coordinate releases | Closely collaborating teams |

**Anti-Corruption Layer Example:**
```python
# External payment API uses different terminology
class ExternalPaymentAPI:
    def process_txn(self, card_info, amt_cents, merchant_key):
        pass

# Our domain model
class PaymentService:
    def process_payment(self, payment_method: PaymentMethod, 
                       amount: Money) -> PaymentResult:
        # Anti-corruption layer - translate our model to external API
        external_result = self._external_api.process_txn(
            card_info=self._translate_payment_method(payment_method),
            amt_cents=int(amount.amount * 100),
            merchant_key=config.MERCHANT_KEY
        )
        
        # Translate response back to our domain model
        return self._translate_result(external_result)
```

#### B. Microservices Boundaries from DDD

Each bounded context typically becomes a microservice:

```
┌──────────────────────────────────────────┐
│         E-commerce Domain                │
│                                          │
│  ┌────────────┐      ┌──────────────┐   │
│  │  Catalog   │      │   Shopping   │   │
│  │  Service   │      │   Service    │   │
│  │            │      │              │   │
│  │  Product   │──────│  Cart        │   │
│  │  Category  │      │  CartItem    │   │
│  │  Inventory │      │              │   │
│  └────────────┘      └──────────────┘   │
│         │                     │          │
│         │                     │          │
│  ┌──────▼───────┐    ┌────────▼──────┐  │
│  │   Order      │    │   Payment     │  │
│  │   Service    │    │   Service     │  │
│  │              │    │               │  │
│  │  Order       │────│  Transaction  │  │
│  │  OrderItem   │    │  PaymentMethod│  │
│  └──────────────┘    └───────────────┘  │
└──────────────────────────────────────────┘
```

**Benefits:**
- Clear service boundaries based on business domains
- Independent scaling and deployment
- Different data storage per service
- Team ownership aligned with business areas

### 3. DDD and Event-Driven Architecture

DDD naturally leads to event-driven architecture:

**Traditional (RPC-style):**
```python
def place_order(order):
    order_service.create_order(order)
    inventory_service.reserve_items(order.items)  # Synchronous call
    payment_service.charge(order.total)           # Blocks if slow
    shipping_service.create_shipment(order)       # More blocking
```

**Event-Driven (DDD style):**
```python
def place_order(order):
    order.confirm()  # State change
    event_bus.publish(OrderPlaced(order))  # Publish event, return immediately
    
# Elsewhere:
@subscribe(OrderPlaced)
def handle_order_placed(event):
    inventory_service.reserve_items(event.items)

@subscribe(OrderPlaced)
def handle_order_placed(event):
    payment_service.charge(event.total)

@subscribe(OrderPlaced)
def handle_order_placed(event):
    shipping_service.create_shipment(event)
```

### 4. Common DDD Anti-Patterns

| Anti-Pattern | Problem | Solution |
|--------------|---------|----------|
| **Anemic Domain Model** | Entities are just data holders with no behavior | Put business logic in domain objects, not services |
| **God Aggregate** | One giant aggregate containing everything | Break into smaller aggregates with clear boundaries |
| **Shared Database** | Multiple services access same database | Each bounded context gets its own database |
| **Missing Ubiquitous Language** | Code uses different terms than business | Align code with business terminology |
| **Technical Bounded Contexts** | Contexts based on tech layers (UI, DB, API) | Context boundaries should match business domains |
| **Too Many Events** | Publishing events for every tiny change | Only publish significant domain events |

---

## 💡 Real-World Use Cases

- **Amazon:** Uses DDD to separate product catalog, shopping cart, orders, and fulfillment into distinct bounded contexts
- **Uber:** Driver context (location, availability) vs Rider context (trip request, payment) vs Pricing context
- **Banking Systems:** Account Management context vs Transaction Processing context vs Risk Assessment context
- **Netflix:** Content Management context vs Recommendation context vs Streaming context

---

## ✏️ Design Challenge

### Problem

You are designing a food delivery platform (like Uber Eats or DoorDash). Identify the key bounded contexts, define the aggregates within each context, and design how they communicate via domain events.

**Requirements:**
- Customers browse restaurants and place orders
- Restaurants receive orders and prepare food
- Delivery drivers pick up and deliver orders
- Payments are processed
- Real-time order tracking

**Design:**
1. Identify at least 4 bounded contexts
2. Define the aggregate roots in each context
3. List key domain events
4. Explain how contexts interact

### Solution

#### 🧩 Step 1: Identify Bounded Contexts

```
┌──────────────────────────────────────────────────────────┐
│              Food Delivery Platform                       │
│                                                           │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │  Restaurant  │  │   Order      │  │   Delivery   │   │
│  │   Catalog    │  │ Management   │  │  Dispatch    │   │
│  └──────────────┘  └──────────────┘  └──────────────┘   │
│                                                           │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │   Payment    │  │   Customer   │  │   Tracking   │   │
│  │   Billing    │  │   Account    │  │   Location   │   │
│  └──────────────┘  └──────────────┘  └──────────────┘   │
└──────────────────────────────────────────────────────────┘
```

#### ✅ Context 1: Restaurant Catalog Context

**Purpose:** Manage restaurant listings, menus, and availability

**Aggregates:**
```python
class Restaurant(AggregateRoot):
    restaurant_id: UUID
    name: str
    address: Address  # Value Object
    cuisine_type: str
    operating_hours: OperatingHours  # Value Object
    is_accepting_orders: bool
    menu: Menu
    
    def update_menu(self, menu_items: List[MenuItem]):
        self.menu.update_items(menu_items)
        self.raise_event(MenuUpdated(self.restaurant_id, menu_items))
    
    def open_for_orders(self):
        self.is_accepting_orders = True
        self.raise_event(RestaurantOpened(self.restaurant_id))
    
    def close_for_orders(self):
        self.is_accepting_orders = False
        self.raise_event(RestaurantClosed(self.restaurant_id))

class Menu:  # Part of Restaurant aggregate
    menu_items: List[MenuItem]
    
class MenuItem(Entity):
    item_id: UUID
    name: str
    description: str
    price: Money  # Value Object
    is_available: bool
```

**Domain Events:**
- `MenuUpdated`
- `RestaurantOpened`
- `RestaurantClosed`
- `MenuItemOutOfStock`

#### ✅ Context 2: Order Management Context

**Purpose:** Handle customer orders from placement to completion

**Aggregates:**
```python
class Order(AggregateRoot):
    order_id: UUID
    customer_id: UUID  # Reference to Customer context
    restaurant_id: UUID  # Reference to Restaurant context
    items: List[OrderItem]
    delivery_address: Address  # Value Object
    status: OrderStatus  # PENDING, CONFIRMED, PREPARING, READY, DELIVERED
    total: Money
    estimated_delivery_time: datetime
    
    def place(self):
        if len(self.items) == 0:
            raise EmptyOrderException()
        self.status = OrderStatus.CONFIRMED
        self.raise_event(OrderPlaced(
            order_id=self.order_id,
            customer_id=self.customer_id,
            restaurant_id=self.restaurant_id,
            items=self.items,
            total=self.total,
            delivery_address=self.delivery_address
        ))
    
    def mark_preparing(self):
        self.status = OrderStatus.PREPARING
        self.raise_event(OrderPreparationStarted(self.order_id))
    
    def mark_ready(self):
        self.status = OrderStatus.READY
        self.raise_event(OrderReadyForPickup(
            order_id=self.order_id,
            restaurant_id=self.restaurant_id,
            delivery_address=self.delivery_address
        ))
    
    def mark_delivered(self):
        self.status = OrderStatus.DELIVERED
        self.raise_event(OrderDelivered(
            order_id=self.order_id,
            customer_id=self.customer_id
        ))

class OrderItem(Entity):
    item_id: UUID
    menu_item_id: UUID  # Reference to Restaurant context
    quantity: int
    price: Money
    special_instructions: str
```

**Domain Events:**
- `OrderPlaced`
- `OrderPreparationStarted`
- `OrderReadyForPickup`
- `OrderDelivered`
- `OrderCancelled`

#### ✅ Context 3: Delivery Dispatch Context

**Purpose:** Assign orders to available drivers and manage deliveries

**Aggregates:**
```python
class Delivery(AggregateRoot):
    delivery_id: UUID
    order_id: UUID  # Reference to Order context
    driver_id: UUID  # Reference to Driver
    pickup_location: Location  # Value Object
    dropoff_location: Location
    status: DeliveryStatus  # PENDING, ASSIGNED, PICKED_UP, IN_TRANSIT, DELIVERED
    assigned_at: datetime
    picked_up_at: datetime
    delivered_at: datetime
    
    def assign_driver(self, driver_id: UUID):
        self.driver_id = driver_id
        self.status = DeliveryStatus.ASSIGNED
        self.assigned_at = datetime.now()
        self.raise_event(DriverAssigned(
            delivery_id=self.delivery_id,
            order_id=self.order_id,
            driver_id=driver_id
        ))
    
    def mark_picked_up(self):
        self.status = DeliveryStatus.PICKED_UP
        self.picked_up_at = datetime.now()
        self.raise_event(OrderPickedUp(
            delivery_id=self.delivery_id,
            order_id=self.order_id,
            driver_id=self.driver_id
        ))
    
    def mark_delivered(self):
        self.status = DeliveryStatus.DELIVERED
        self.delivered_at = datetime.now()
        self.raise_event(DeliveryCompleted(
            delivery_id=self.delivery_id,
            order_id=self.order_id,
            driver_id=self.driver_id
        ))

class Driver(AggregateRoot):
    driver_id: UUID
    name: str
    vehicle_type: VehicleType
    current_location: Location
    status: DriverStatus  # AVAILABLE, BUSY, OFFLINE
    rating: Rating
    
    def go_online(self):
        self.status = DriverStatus.AVAILABLE
        self.raise_event(DriverWentOnline(self.driver_id, self.current_location))
    
    def accept_delivery(self, delivery_id: UUID):
        self.status = DriverStatus.BUSY
        self.raise_event(DriverAcceptedDelivery(self.driver_id, delivery_id))
```

**Domain Events:**
- `DriverAssigned`
- `OrderPickedUp`
- `DeliveryCompleted`
- `DriverLocationUpdated`
- `DriverWentOnline`

#### ✅ Context 4: Payment & Billing Context

**Purpose:** Process payments and manage billing

**Aggregates:**
```python
class Payment(AggregateRoot):
    payment_id: UUID
    order_id: UUID  # Reference to Order context
    customer_id: UUID
    amount: Money
    payment_method: PaymentMethod  # Value Object
    status: PaymentStatus  # PENDING, AUTHORIZED, CAPTURED, FAILED, REFUNDED
    transaction_id: str
    
    def authorize(self):
        # Call payment gateway
        result = payment_gateway.authorize(self.payment_method, self.amount)
        if result.success:
            self.status = PaymentStatus.AUTHORIZED
            self.transaction_id = result.transaction_id
            self.raise_event(PaymentAuthorized(
                payment_id=self.payment_id,
                order_id=self.order_id,
                amount=self.amount
            ))
        else:
            self.status = PaymentStatus.FAILED
            self.raise_event(PaymentFailed(
                payment_id=self.payment_id,
                order_id=self.order_id,
                reason=result.error_message
            ))
    
    def capture(self):
        self.status = PaymentStatus.CAPTURED
        self.raise_event(PaymentCaptured(
            payment_id=self.payment_id,
            order_id=self.order_id
        ))
    
    def refund(self, amount: Money):
        self.status = PaymentStatus.REFUNDED
        self.raise_event(PaymentRefunded(
            payment_id=self.payment_id,
            order_id=self.order_id,
            amount=amount
        ))

class PaymentMethod(ValueObject):
    type: str  # CARD, WALLET, CASH
    card_last_four: str
    expiry: str
```

**Domain Events:**
- `PaymentAuthorized`
- `PaymentCaptured`
- `PaymentFailed`
- `PaymentRefunded`

#### ✅ Step 2: Context Interactions (Event Flow)

**Scenario: Customer Places an Order**

```
1. Customer Context
   └─→ OrderPlaced event

2. Order Management Context
   │  (consumes OrderPlaced)
   │  Validates order
   └─→ OrderConfirmed event

3. Payment Context
   │  (consumes OrderConfirmed)
   │  Authorizes payment
   └─→ PaymentAuthorized event

4. Restaurant Catalog Context
   │  (consumes PaymentAuthorized)
   │  Notifies restaurant
   └─→ OrderPreparationStarted event

5. Delivery Dispatch Context
   │  (consumes OrderPreparationStarted)
   │  Finds available driver
   └─→ DriverAssigned event

6. Tracking Context
   │  (consumes DriverAssigned)
   │  Starts real-time tracking
   └─→ TrackingStarted event

7. Restaurant Context
   │  Prepares food
   └─→ OrderReadyForPickup event

8. Delivery Context
   │  (consumes OrderReadyForPickup)
   │  Driver picks up
   └─→ OrderPickedUp event

9. Tracking Context
   │  (consumes OrderPickedUp)
   │  Updates customer
   └─→ TrackingUpdated event

10. Delivery Context
    │  Driver delivers
    └─→ DeliveryCompleted event

11. Payment Context
    │  (consumes DeliveryCompleted)
    │  Captures payment
    └─→ PaymentCaptured event

12. Order Context
    │  (consumes DeliveryCompleted)
    │  Marks order complete
    └─→ OrderCompleted event
```

#### ✅ Step 3: Benefits of This Design

| Benefit | Explanation |
|---------|-------------|
| **Clear Boundaries** | Each context has well-defined responsibilities |
| **Independent Scaling** | Can scale restaurant catalog separately from delivery dispatch |
| **Team Ownership** | Different teams own different contexts |
| **Resilience** | Failure in tracking doesn't break order placement |
| **Eventual Consistency** | Contexts stay in sync via events |
| **Technology Freedom** | Each context can use different tech stack |

#### ✅ Step 4: Anti-Corruption Layers

**Restaurant Context ↔ External Menu API:**
```python
class RestaurantMenuAdapter:  # ACL
    def __init__(self, external_menu_api):
        self._api = external_menu_api
    
    def import_menu(self, restaurant_id: UUID) -> Menu:
        # External API uses different structure
        external_menu = self._api.get_menu(restaurant_id)
        
        # Translate to our domain model
        menu_items = [
            MenuItem(
                item_id=UUID(item['id']),
                name=item['itemName'],  # They use 'itemName'
                price=Money(Decimal(item['priceInCents']) / 100, 'USD'),
                is_available=item['inStock']  # They use 'inStock'
            )
            for item in external_menu['items']
        ]
        
        return Menu(menu_items)
```

#### ✅ Final Summary

| Context | Aggregate Roots | Key Events | Communication |
|---------|----------------|------------|---------------|
| **Restaurant Catalog** | Restaurant, Menu | MenuUpdated, RestaurantOpened | Publishes menu changes |
| **Order Management** | Order | OrderPlaced, OrderCompleted | Orchestrates order flow |
| **Delivery Dispatch** | Delivery, Driver | DriverAssigned, DeliveryCompleted | Manages driver assignment |
| **Payment & Billing** | Payment | PaymentAuthorized, PaymentCaptured | Handles financial transactions |
| **Tracking** | TrackingSession | TrackingStarted, LocationUpdated | Real-time updates |

**Key Insight:** DDD provides a structured approach to breaking down complex domains into manageable, loosely-coupled contexts that align with business capabilities.

