# HLD Architecture Handbook - Cursor Rules

## Project Structure

This is a system design learning repository organized into:
- `01-principles/` - Core theoretical concepts
- `02-components/` - Deep dive into system components (organized into 6 categories)
  - `2.0-communication/` - Communication protocols, APIs, real-time communication
  - `2.1-databases/` - 15 database deep dives (SQL, NoSQL, specialized)
  - `2.2-caching/` - Caching systems and strategies
  - `2.3-messaging-streaming/` - Message queues, Kafka, Spark, Flink
  - `2.4-security-observability/` - Security fundamentals and observability
  - `2.5-algorithms/` - Distributed algorithms (rate limiting, consensus, locking)
- `03-challenges/` - Real-world design problems with detailed solutions

---

## Component File Structure (02-components)

**Directory Organization:** Component files are organized into 6 logical subdirectories:
- Files are located in `02-components/[category]/[filename].md`
- Example: `02-components/2.1-databases/2.1.7-postgresql-deep-dive.md` (SQL database)
- Example: `02-components/2.1-databases/2.1.9-cassandra-deep-dive.md` (NoSQL database)
- Example: `02-components/2.3-messaging-streaming/2.3.7-apache-spark-deep-dive.md` (Stream processing)

All component deep dive files in `02-components/` MUST follow this structure:

### Required Structure:

1. **Title:** `# [ID] [Topic Name]: [Subtitle]`
2. **Intuitive Explanation** section
3. **In-Depth Analysis** section with subsections
4. **When to Use** section
5. **Real-World Examples** section
6. **Common Anti-Patterns** section (with ‚ùå and ‚úÖ examples)
7. **Trade-offs Summary** section (table format)
8. **References** section
9. **‚úèÔ∏è Design Challenge** section (REQUIRED at end)

### Design Challenge Format (END OF EVERY COMPONENT FILE):

**REQUIRED at the end of ALL component files:**

```markdown
---

## ‚úèÔ∏è Design Challenge

### Problem

[A practical scenario/question that applies the concepts from the component]

Requirements:
1. [Requirement 1]
2. [Requirement 2]
3. [Requirement 3]

**Question:** [Specific design question that requires deep understanding]

### Solution

#### üß© Scenario

- **System:** [System description]
- **Scale:** [Scale metrics]
- **Requirements:** [Detailed requirements list]
- **Query/Access patterns:** [How data is accessed]

#### ‚úÖ Goal

- [Goal 1]
- [Goal 2]
- [Goal 3]

#### ‚öôÔ∏è Solution: [Chosen Approach]

**Why [This Choice]?**

[Comparison table showing why this technology/approach was chosen]

**Design Decisions:**

[Detailed explanation of key design choices with code examples/schemas]

**Example Implementation:**

[Code examples, schemas, or configuration]

#### ‚ö†Ô∏è Trade-offs and Challenges

**Challenge 1: [Challenge Name]**

**Problem:** [What's the problem]

**Solution:** [How to solve it]

[Repeat for 2-3 challenges]

#### üß† Practical Considerations

[Real-world architecture, scaling strategies, cost analysis]

#### ‚úÖ Final Answer

| Aspect | Decision | Reason |
|--------|----------|--------|
| **[Aspect 1]** | [Decision] | [Rationale] |
| **[Aspect 2]** | [Decision] | [Rationale] |
| **Trade-off Accepted** | [What you sacrifice] | [What you gain] |

**Performance Metrics:**
- [Metric 1]: [Value]
- [Metric 2]: [Value]

**Why NOT [Alternative]:**
- [Reason 1]
- [Reason 2]

**When to Reconsider:**
- [Condition 1]
- [Condition 2]
```

### Examples of Component Design Challenges:

- **PostgreSQL:** "Can PostgreSQL handle search, geospatial, and inventory consistency, or do you need multiple databases?"
- **Cassandra:** "How would you design a time-series IoT platform with 100K writes/sec and proper partition key strategy?"
- **Redis:** "How would you build a gaming leaderboard with 10M players using Redis sorted sets?"
- **MongoDB:** "How would you model a social media profile system with varying fields and handle the celebrity problem?"
- **Elasticsearch:** "How would you design a multi-tenant SaaS search platform with data isolation and real-time sync from PostgreSQL?"
- **MySQL:** "How would you design an e-commerce order system with ACID transactions and read replicas?"
- **DynamoDB:** "How would you design a serverless shopping cart that handles 100x traffic spikes on Black Friday?"

### Component File Template:

```markdown
# [ID] [Topic Name]: [Subtitle]

## Intuitive Explanation

[Simple, high-level explanation with analogies]

## In-Depth Analysis

### 1. [Topic 1]

[Detailed explanation]

### 2. [Topic 2]

[Detailed explanation]

[... continue with 10-15 major sections ...]

### [N]. When to Use [Technology]

#### ‚úÖ Use [Technology] When:

1. [Use case 1]
2. [Use case 2]

#### ‚ùå Don't Use [Technology] When:

1. [Anti-use case 1]
2. [Anti-use case 2]

### [N+1]. Real-World Examples

| Company | Use Case | Why [Technology]? |
|---------|----------|-------------------|
| **Company 1** | [Use case] | [Reason] |

### [N+2]. [Technology] vs. Other [Category]

| Feature | [Technology] | [Alternative 1] | [Alternative 2] |
|---------|-------------|-----------------|-----------------|

### [N+3]. Common Anti-Patterns

#### ‚ùå **1. [Anti-Pattern Name]**

**Problem:** [What's wrong]

**Solution:** [How to fix]

### [N+4]. Trade-offs Summary

| What You Gain | What You Sacrifice |
|---------------|-------------------|
| ‚úÖ [Benefit 1] | ‚ùå [Cost 1] |

### [N+5]. References

- **[Official Docs]:** [URL]
- **Related Chapters:**
  - [Link to related chapter 1]
  - [Link to related chapter 2]

---

## ‚úèÔ∏è Design Challenge

[REQUIRED: See Design Challenge Format above]
```

### Key Requirements for Component Files:

1. ‚úÖ **Comprehensive:** 500-700+ lines
2. ‚úÖ **Practical:** Real-world examples, code samples, schemas
3. ‚úÖ **Comparative:** Compare with alternatives (vs. other databases)
4. ‚úÖ **Anti-patterns:** Show ‚ùå bad and ‚úÖ good approaches
5. ‚úÖ **Design challenge:** MUST include practical design challenge at end
6. ‚úÖ **Trade-offs:** Explicit what you gain vs. what you sacrifice
7. ‚ùå **NO:** Generic theory without practical application
8. ‚ùå **NO:** Missing design challenge (every component MUST have one)

---

## Design Challenge Structure

Each design challenge in `03-challenges/` follows this exact structure:

```
03-challenges/
‚îú‚îÄ‚îÄ 3.x.y-problem-name/
‚îÇ   ‚îú‚îÄ‚îÄ 3.x.y-design-problem-name.md    # FULL comprehensive guide (main file)
‚îÇ   ‚îú‚îÄ‚îÄ README.md                        # Identical or similar to main file
‚îÇ   ‚îú‚îÄ‚îÄ hld-diagram.md                   # ONLY Mermaid architecture diagrams with explanations
‚îÇ   ‚îú‚îÄ‚îÄ sequence-diagrams.md             # ONLY Mermaid sequence diagrams with explanations
‚îÇ   ‚îú‚îÄ‚îÄ this-over-that.md                # In-depth discussion of design choices, trade-offs, and alternatives
‚îÇ   ‚îî‚îÄ‚îÄ pseudocode.md                    # OPTIONAL: Detailed algorithm implementations (if needed)
```

### File Content Guidelines

## ‚ö†Ô∏è CRITICAL FORMAT REQUIREMENTS ‚ö†Ô∏è

### EXACT FORMAT FOR ALL MAIN FILES AND README FILES

**ALL main challenge files (`3.x.y-design-problem-name.md`) and README files MUST follow this EXACT structure:**

```markdown
# 3.x.y Challenge Title

> üìö **Note on Implementation Details:**
> This document focuses on high-level design concepts and architectural decisions. 
> For detailed algorithm implementations, see **[pseudocode.md](./pseudocode.md)**.

## üìä Visual Diagrams & Resources

- **[High-Level Design Diagrams](./hld-diagram.md)** - System architecture, component design, data flow
- **[Sequence Diagrams](./sequence-diagrams.md)** - Detailed interaction flows and failure scenarios
- **[Design Decisions (This Over That)](./this-over-that.md)** - In-depth analysis of architectural choices
- **[Pseudocode Implementations](./pseudocode.md)** - Detailed algorithm implementations

---

## 1. Problem Statement

[Content here]

---

## 2. Requirements and Scale Estimation

[Content here]

---

## 3. High-Level Architecture

[Content here]

---

## 4. [Next Section]

[Continue with sequential numbering: 4, 5, 6, 7, etc.]
```

### ‚ö†Ô∏è CRITICAL SECTION NUMBERING RULES ‚ö†Ô∏è

**NEVER create duplicate section numbers!**

‚úÖ **CORRECT:**
```markdown
## 1. Problem Statement
## 2. Requirements and Scale Estimation
## 3. High-Level Architecture
## 4. Detailed Component Design
## 5. Availability and Fault Tolerance
## 6. Bottlenecks and Optimizations
```

‚ùå **WRONG:**
```markdown
## 1. Problem Statement
## 2. Requirements and Scale Estimation
## 2. High-Level Architecture  ‚Üê DUPLICATE 2!
## 3. Detailed Component Design
```

**VALIDATION STEP:** After creating any main file, run:
```bash
grep "^## [0-9]" your-file.md
```
Verify numbers are: 1, 2, 3, 4, 5... (sequential, no duplicates)

---

## ‚ö†Ô∏è CRITICAL: COMPREHENSIVE CONTENT RULE ‚ö†Ô∏è

### **BOTH Main File AND README MUST Be Comprehensive**

**Key Principle:** The README is NOT a "quick overview" or "summary" file. It is a **full, standalone comprehensive guide** similar to the main file.

### **Main File Requirements:**
- **Minimum Length:** 800-1200+ lines for most challenges
- **Depth:** Deep explanations of ALL components, design decisions, trade-offs
- **Content:** 10-15 major sections covering full system design
- **Reference Examples:**
  - URL Shortener: 1,153 lines ‚úÖ
  - Live Chat System: 1,233 lines ‚úÖ
  - Global Rate Limiter: 735 lines ‚úÖ

### **README Requirements:**
- **Minimum Length:** 75-120% of main file line count (typically 77-100%)
- **Same Sections:** Include ALL major sections from main file
- **Same Depth:** Full explanations, not summaries
- **Same Tables:** Complete tables for estimation, trade-offs, comparisons
- **Same Diagrams:** ASCII diagrams where appropriate
- **Reference Examples:**
  - URL Shortener: 886 lines (77% of 1,153) ‚úÖ
  - Live Chat System: 955 lines (77% of 1,233) ‚úÖ

### **Validation Commands:**

**After creating files, run:**
```bash
cd /path/to/challenge-folder

# 1. Check main file length
MAIN_LINES=$(wc -l < 3.x.y-design-problem-name.md)
echo "Main file: $MAIN_LINES lines"

# 2. Check README length
README_LINES=$(wc -l < README.md)
echo "README: $README_LINES lines"

# 3. Calculate ratio
RATIO=$(echo "scale=0; $README_LINES * 100 / $MAIN_LINES" | bc)
echo "README is $RATIO% of main file"

# 4. Validate ratio (should be 75-120%)
if [ $RATIO -lt 75 ] || [ $RATIO -gt 120 ]; then
    echo "‚ùå FAILED: README should be 75-120% of main file"
else
    echo "‚úÖ PASSED: README length is within acceptable range"
fi
```

### **Content Parity Checklist:**

Both main file AND README must include:
- ‚úÖ Problem Statement (full paragraph)
- ‚úÖ Requirements & Scale Estimation (complete tables with calculations)
- ‚úÖ High-Level Architecture (ASCII diagram + component descriptions)
- ‚úÖ Detailed Component Design (ALL subsections)
- ‚úÖ Data Models (schemas, structures)
- ‚úÖ Key Algorithms (described in words, reference pseudocode.md)
- ‚úÖ "Why This Over That?" sections (inline design justifications)
- ‚úÖ Bottlenecks & Solutions (4-6 major bottlenecks)
- ‚úÖ Common Anti-Patterns (3-5 patterns with ‚ùå bad vs ‚úÖ good)
- ‚úÖ Alternative Approaches (2-3 alternatives)
- ‚úÖ Monitoring & Observability (metrics, alerts)
- ‚úÖ Trade-offs Summary (what we gained vs sacrificed)
- ‚úÖ Real-World Examples (how companies solve this)
- ‚úÖ References (links to other chapters)

### **What's Different Between Main File and README:**

| Aspect | Main File | README |
|--------|-----------|--------|
| **Section Numbering** | MUST have numbers (## 1., ## 2., ## 3.) | MAY omit numbers (## Problem Statement) |
| **Depth of Detail** | Slightly more detailed | Slightly more concise, but still comprehensive |
| **Length** | 100% (reference) | 75-120% of main file (typically 77-100%) |
| **Purpose** | Primary comprehensive document | Standalone comprehensive guide (users can read either) |

**IMPORTANT:** The only acceptable difference is that README may be *slightly* more concise (75% minimum), but it must still include ALL sections with FULL explanations.

---

#### Main Challenge File (`3.x.y-design-problem-name.md`):
- **Complete standalone document** with all content
- **MUST follow EXACT format shown above** (no variations allowed)
- **Line-by-line requirements:**
  1. **Line 1:** Title: `# [ID] [Challenge Name]`
  2. **Line 2:** Blank line
  3. **Line 3:** Start of note block: `> üìö **Note on Implementation Details:**`
  4. **Lines 4-5:** Note content (see format above)
  5. **Line 6:** Blank line
  6. **Line 7:** `## üìä Visual Diagrams & Resources`
  7. **Lines 8-12:** Links to all 4 supplementary files
  8. **Line 13:** `---` separator
  9. **Line 14:** Blank line
  10. **Line 15:** `## 1. Problem Statement` ‚Üê **MUST BE NUMBERED "1"**
  11. Continue with `## 2.`, `## 3.`, `## 4.` etc. (SEQUENTIAL, NO GAPS, NO DUPLICATES)
- Includes ASCII diagrams inline using triple backticks without language specification
- Contains full explanations, high-level algorithms (NO detailed pseudocode)
- **NO programming language code** - only high-level logic descriptions and conceptual explanations
- **NO detailed pseudocode implementations** - describe algorithms in words, reference `pseudocode.md::function_name()` for implementation
- Includes "Why This Over That?" sections highlighting key design choices
- For every major choice (DB, cache, sync/async), explain the rationale with bullet points
- Links to diagram files, this-over-that.md, and pseudocode.md for detailed implementations
- Focus on WHAT and WHY, delegate HOW to pseudocode.md
- **Typical sections (numbered):** 1. Problem Statement, 2. Requirements & Scale Estimation, 3. High-Level Architecture, 4. Data Model, 5. Component Design, 6. Bottlenecks, 7. Anti-Patterns, 8. Alternative Approaches, 9. Monitoring, 10. Trade-offs Summary, 11. Real-World Examples, 12. References

#### README.md:
- **‚ö†Ô∏è CRITICAL: README MUST BE COMPREHENSIVE LIKE MAIN FILE** - NOT a quick overview
- **MUST follow EXACT SAME format as main file** (see format above)
- **Content Requirements:**
  - **Similar length to main file** (within 75-120% line count, typically 77-100%)
  - **Include ALL major sections** from main file (Requirements, Architecture, Component Design, Bottlenecks, Anti-Patterns, Trade-offs, etc.)
  - **Full explanations** for all design decisions, not just summaries
  - **Complete tables** for scale estimation, technology choices, trade-offs
  - **ASCII diagrams** inline where appropriate
  - **Example:** URL Shortener README (887 lines = 77% of 1,153 main file) ‚úÖ
- **Line-by-line requirements (SAME as main file):**
  1. Title
  2. Blank line
  3. Note block (3 lines)
  4. Blank line
  5. `## üìä Visual Diagrams & Resources`
  6. Links to all 4 files
  7. `---` separator
  8. Blank line
  9. `## Problem Statement` (can omit section numbers in README, but include all content)
  10. Continue with ALL sections from main file
- **NO detailed pseudocode implementations** - only basic definitions and implementation descriptions
- Reference `pseudocode.md::function_name()` for all algorithm implementations
- **Purpose:** README serves as a standalone comprehensive guide that users can read without opening main file

#### hld-diagram.md:
- **REQUIRED FORMAT:**
  ```markdown
  # [Challenge Name] - High-Level Design
  
  ## Table of Contents
  
  1. [Section 1 Name](#section-1-name)
  2. [Section 2 Name](#section-2-name)
  3. [Section 3 Name](#section-3-name)
  ...
  
  ---
  
  ## Section 1 Name
  
  **Flow Explanation:** [explanation here]
  
  [Mermaid diagram here]
  ```
- **‚ö†Ô∏è MUST have Table of Contents** at the top (after title, before first diagram)
- Contains ONLY Mermaid diagrams for:
  - System architecture
  - Component design
  - Data flow
  - Scaling strategies
  - Storage architecture
  - Multi-region deployment
  - Monitoring dashboards
- Each diagram should be in a Mermaid code block (```mermaid)
- **CRITICAL: MUST include flow explanations** above or below EVERY diagram
- Flow explanations should include:
  - **Flow Explanation:** heading (bold)
  - Brief description of what the diagram shows
  - **Key components/steps** enumerated (numbered list)
  - **Benefits/trade-offs** of the design shown (bullet points)
  - **Performance characteristics** if applicable (latency, throughput)
  - Example format:
    ```
    **Flow Explanation:**
    
    This diagram shows X doing Y.
    
    **Steps:**
    1. Component A receives request
    2. A ‚Üí B: Data flows from A to B
    3. C processes and returns result
    
    **Benefits:**
    - Fast: <10ms latency
    - Scalable: Horizontal scaling supported
    - Resilient: Handles node failures
    
    **Trade-offs:**
    - Eventual consistency
    - Higher infrastructure cost
    ```
- Typical diagrams count: 10-15 diagrams per challenge

#### sequence-diagrams.md:
- **REQUIRED FORMAT:**
  ```markdown
  # [Challenge Name] - Sequence Diagrams
  
  ## Table of Contents
  
  1. [Flow 1 Name](#flow-1-name)
  2. [Flow 2 Name](#flow-2-name)
  3. [Flow 3 Name](#flow-3-name)
  ...
  
  ---
  
  ## Flow 1 Name
  
  **Flow:** [one-line summary]
  
  **Steps:**
  1. [Step description]
  2. [Step description]
  
  [Mermaid sequence diagram here]
  ```
- **‚ö†Ô∏è MUST have Table of Contents** at the top (after title, before first diagram)
- Contains ONLY Mermaid sequence diagrams for:
  - Request/response flows (happy path)
  - Interaction between components
  - Failure scenarios
  - Failover processes
  - Cache hit/miss flows
  - Multi-region replication
  - Rate limiting
  - Cache invalidation
- **CRITICAL: MUST include flow explanations** above or below EVERY diagram
- Flow explanations should describe:
  - **Flow:** One-line summary of the sequence (bold heading)
  - Step-by-step interaction pattern (numbered list)
  - Performance characteristics (latency, throughput)
  - When this flow happens (happy path, error scenario, etc.)
  - Edge cases handled
  - Example format:
    ```
    **Flow:**
    
    Shows the complete flow of a user posting a tweet from client request to fanout completion.
    
    **Steps:**
    1. **Client Request** (0ms): User posts tweet via mobile/web app
    2. **API Gateway** (10ms): JWT validation, rate limit check
    3. **Post Service** (20ms): Validates content, generates ID
    4. **PostgreSQL** (20ms): Inserts tweet (ACID)
    5. **Kafka** (5ms): Publishes event (non-blocking)
    6. **Return to Client** (~100ms total): User doesn't wait for fanout
    
    **Performance:**
    - Client response: <100ms (user doesn't wait for fanout)
    - Fanout completion: ~10 seconds (for 5,000 followers)
    ```
- Typical diagrams count: 10-15 sequence diagrams per challenge

#### this-over-that.md:
- **REQUIRED FILE** - Deep dive into design decisions
- **REQUIRED FORMAT:**
  ```markdown
  # [Challenge Name] - Design Decisions (This Over That)
  
  This document provides in-depth analysis of all major architectural decisions...
  
  ---
  
  ## Table of Contents
  
  1. [Decision 1 Name](#decision-1-name)
  2. [Decision 2 Name](#decision-2-name)
  ...
  
  ---
  
  ## 1. Decision Name
  
  ### The Problem
  [What are we solving?]
  
  ### Options Considered
  [Comparison table]
  
  ### Decision Made
  [What we chose]
  
  ### Rationale
  [Why]
  
  ### Trade-offs Accepted
  [What we sacrifice]
  
  ### When to Reconsider
  [Conditions]
  ```
- **‚ö†Ô∏è MUST have standardized title format:** `# [Challenge Name] - Design Decisions (This Over That)`
- **‚ö†Ô∏è MUST have Table of Contents** at the top
- Contains in-depth discussion of all major architectural choices (typically 5-10 decisions):
  - Primary strategy choice (e.g., fanout strategy, sharding strategy)
  - Database selection (SQL vs NoSQL with specific DB comparisons)
  - Message queue choice (Kafka vs RabbitMQ vs SQS)
  - Cache strategy (Redis vs Memcached)
  - Sync vs Async processing
  - Push vs Pull models
  - Consistency models (ACID vs BASE)
- For each choice, document:
  - **The Problem**: What are we trying to solve? (constraints, requirements)
  - **Options Considered**: All alternatives with detailed comparison tables
    - Include columns: pros, cons, performance, cost, complexity
    - Provide specific metrics where possible
  - **Decision Made**: What we chose and why (3-5 bullet points)
  - **Rationale**: Detailed explanation with numbered points
  - **Implementation Details**: How it's implemented (brief)
  - **Trade-offs Accepted**: What we're sacrificing (table format)
  - **When to Reconsider**: Specific conditions that would change the decision
- Include real-world examples (e.g., "Twitter uses X because...", "Instagram chose Y for...")
- **Summary table** at end comparing all decisions
- Typical length: 15-25 sections (1-2 sections per major decision)

#### pseudocode.md (REQUIRED for most challenges):
- Contains detailed algorithm implementations in pseudocode
- **Main files and README should NEVER contain detailed pseudocode** - they should describe logic in words and reference this file
- Reference format: `*See pseudocode.md::function_name() for implementation*` or `*See pseudocode.md::ClassName for detailed implementation*`
- **REQUIRED FORMAT:**
  ```markdown
  # [Challenge Name] - Pseudocode Implementations
  
  This document contains detailed algorithm implementations for the [Challenge Name] system. The main challenge document references these functions.
  
  ---
  
  ## Table of Contents
  
  1. [Section 1 Name](#section-1-name)
  2. [Section 2 Name](#section-2-name)
  ...
  
  ---
  
  ## Section 1 Name
  
  ### function_name()
  
  **Purpose:** [One-line description]
  
  **Parameters:**
  - param1 (type): description
  
  **Returns:**
  - type: description
  
  **Algorithm:**
  ```
  function function_name(param1):
    // pseudocode here
    return result
  ```
  
  **Time Complexity:** O(n)
  
  **Example Usage:**
  ```
  result = function_name(value)
  ```
  ```
- **‚ö†Ô∏è MUST have standardized title format:** `# [Challenge Name] - Pseudocode Implementations`
- **‚ö†Ô∏è MUST have intro description:** "This document contains detailed algorithm implementations for the [Challenge Name] system. The main challenge document references these functions."
- **‚ö†Ô∏è MUST have Table of Contents** at the top with links to all sections
- **Structure:**
  - Sections organized by functionality (e.g., "## Fanout Strategies", "## Cache Operations", "## Write Path")
  - Each function documented with:
    - **Purpose:** One-line description
    - **Parameters:** List with types and descriptions
    - **Returns:** Return type and description
    - **Algorithm:** Detailed pseudocode implementation (NO language tags, just ```)
    - **Time Complexity:** Big-O analysis
    - **Example Usage:** Sample code showing how to call the function
- **Pseudocode Style:**
  - Use `function function_name(param1, param2):` format
  - Use indentation for blocks (2 or 4 spaces)
  - Use `//` for comments
  - Use `if/else`, `for`, `while` keywords
  - Use descriptive variable names
  - Include error handling (`try/catch`, `throw`)
- Include anti-pattern examples (‚ùå bad vs ‚úÖ good) where relevant
- Use clear function names: `function_name()`, `ClassName`, `method_name()`
- Typical function count: 10-20 functions per challenge
- Only skip this file if the challenge has NO algorithmic complexity (rare)

## Code Block Formatting Rules

**CRITICAL**: Follow these markdown code block rules exactly:

### For Pseudocode/Algorithms (No Language Tag):
```
function example():
  // pseudocode here
  return result
```

### For ASCII Diagrams (No Language Tag):
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Component ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### For SQL Schemas Only (Use Language Tag):
```sql
CREATE TABLE example (
    id BIGINT PRIMARY KEY
);
```

**IMPORTANT**: NO other programming language code (Python, Java, Go, etc.) should be used in challenges. Use pseudocode or describe logic in words instead.

### For Mermaid Diagrams (Always Use `mermaid` Tag):
```mermaid
graph TB
    A[Start] --> B[End]
```

### General Code Block Rules:
- Use triple backticks for code blocks
- For pseudocode/algorithms: NO language tag (just ```)
- For ASCII art/diagrams: NO language tag (just ```)
- For SQL schemas: USE ```sql tag
- For Mermaid diagrams: ALWAYS use ```mermaid
- **NO programming language implementations** (no Python, Java, Go, JavaScript, etc.)
- Never include line numbers in code content
- Never indent the triple backticks (always start at column 0)

## Writing Style

### Technical Content:
- Provide intuitive explanations first, then technical details
- Use tables for comparisons
- Include "Why this over that?" explanations
- Document trade-offs explicitly
- Use LaTeX math notation: $\text{notation}$ for inline, display for blocks

### Structure:
1. Problem Statement
2. Requirements and Scale Estimation  
3. High-Level Architecture
4. Detailed Component Design
5. Bottlenecks and Future Scaling
6. Common Anti-Patterns (with ‚ùå and ‚úÖ)
7. Alternative Approaches
8. Monitoring and Observability
9. Trade-offs Summary

### Design Patterns:
- Start with scale estimation and back-of-envelope calculations
- Always include comparison tables for architectural choices
- Document both the chosen approach AND alternatives not chosen
- Include anti-patterns section with bad vs good examples
- Provide real-world comparison (e.g., "Twitter uses...", "Uber uses...")

## Visual Diagrams

### ASCII Diagrams:
- Use for simple component layouts
- Place inline in main document
- Use box-drawing characters: ‚îå ‚îÄ ‚îê ‚îÇ ‚îî ‚îò ‚î¨ ‚î¥ ‚îú ‚î§ ‚îº
- No language tag in code block

### Mermaid Diagrams:
- Use for complex system architecture
- Place in separate `.md` files (hld-diagram.md, sequence-diagrams.md)
- Link from main document
- Always use ```mermaid code blocks
- Supported types:
  - `graph TB/LR` for flowcharts
  - `sequenceDiagram` for interactions
  - `flowchart TD/LR` for detailed flows

## Examples to Follow

### Reference Implementations:
- **URL Shortener (3.1.1)**: `03-challenges/3.1.1-url-shortener/` - Good example of Base62 encoding, ID generation, caching patterns
- **Distributed Cache (3.1.2)**: `03-challenges/3.1.2-distributed-cache/` - Good example of consistent hashing, eviction policies
- **Distributed ID Generator (3.1.3)**: `03-challenges/3.1.3-distributed-id-generator/` - Good example of Snowflake algorithm, clock drift handling
- **Twitter Timeline (3.2.1)**: `03-challenges/3.2.1-twitter-timeline/` - Good example of fanout strategies, hybrid models, multi-region architecture

### Challenge Categories:
- **3.1.x** (Easy): Caching, databases, basic scaling
- **3.2.x** (Medium): Asynchrony, feeds, microservices, geo-spatial  
- **3.3.x** (Hard): Consistency, transactions, consensus, real-time geo

## Common Mistakes to Avoid

### ‚ö†Ô∏è CRITICAL FORMAT MISTAKES (NEVER DO THESE):

1. ‚ùå **DUPLICATE SECTION NUMBERS** - Check with `grep "^## [0-9]" file.md` after creating
   - Wrong: `## 1. Problem`, `## 2. Requirements`, `## 2. Architecture` ‚Üê DUPLICATE 2!
   - Right: `## 1. Problem`, `## 2. Requirements`, `## 3. Architecture`

2. ‚ùå **MISSING NOTE BLOCK** at top of main file/README
   - Must have: `> üìö **Note on Implementation Details:**` BEFORE any content

3. ‚ùå **MISSING VISUAL DIAGRAMS SECTION** at top
   - Must have: `## üìä Visual Diagrams & Resources` AFTER note, BEFORE `## 1. Problem Statement`

4. ‚ùå **MISSING TABLE OF CONTENTS** in hld-diagram.md and sequence-diagrams.md
   - Both files MUST have `## Table of Contents` section at top

5. ‚ùå **WRONG FIRST SECTION NUMBER** - First content section MUST be `## 1. Problem Statement`
   - Wrong: `## Problem Statement` (no number)
   - Wrong: `## 0. Problem Statement` (wrong number)
   - Right: `## 1. Problem Statement`

### Other Common Mistakes:

6. ‚ùå DO NOT use language tags for pseudocode (use plain ```)
7. ‚ùå DO NOT use language tags for ASCII diagrams (use plain ```)
8. ‚ùå DO NOT create challenge files outside the folder structure
9. ‚ùå DO NOT mix diagram content with theory in main file
10. ‚ùå DO NOT indent triple backticks (always column 0)
11. ‚ùå DO NOT include line numbers in code blocks
12. ‚ùå DO NOT create separate README and main file with different content (keep them similar/identical)
13. ‚ùå DO NOT include programming language code (Python, Java, Go, etc.) - use pseudocode only
14. ‚ùå DO NOT create diagrams without flow explanations - EVERY diagram MUST have explanation
15. ‚ùå DO NOT skip the this-over-that.md file - it's critical for understanding design decisions
16. ‚ùå DO NOT put detailed pseudocode in main challenge files or README - use pseudocode.md and reference it
17. ‚ùå DO NOT forget to verify that pseudocode.md contains ALL functions referenced in main/README files
18. ‚ùå DO NOT create pseudocode functions without clear purpose documentation
19. ‚ùå DO NOT skip Table of Contents in pseudocode.md, hld-diagram.md, or sequence-diagrams.md

## When Adding New Challenges

1. Create folder: `03-challenges/3.x.y-problem-name/`
2. Create main file: `3.x.y-design-problem-name.md` (comprehensive, NO detailed pseudocode, NO programming code)
3. Create `README.md` (similar to main file, NO detailed pseudocode)
4. Create `hld-diagram.md` (Mermaid diagrams WITH flow explanations for EVERY diagram)
5. Create `sequence-diagrams.md` (Mermaid diagrams WITH step-by-step flow explanations for EVERY diagram)
6. Create `this-over-that.md` (in-depth design decision discussions)
7. Create `pseudocode.md` (REQUIRED for most challenges - contains ALL algorithm implementations)
8. Follow existing challenge structure exactly (see `03-challenges/3.1.1-url-shortener/` as reference)
9. Use proper code block formatting (no language for pseudocode/ASCII, SQL for schemas only)
10. Include "Why This Over That?" sections for every major choice
11. Include comprehensive sections: requirements, architecture, bottlenecks, anti-patterns, alternatives
12. NO programming language implementations - only pseudocode in pseudocode.md
13. Verify ALL referenced functions (`pseudocode.md::function_name()`) exist in pseudocode.md
14. Add Table of Contents to pseudocode.md for easy navigation

## Mathematical Notation

Use LaTeX for technical notation:
- Inline: `$\text{notation}$`
- Display: `$$\text{formula}$$`
- Examples: `$\text{QPS}$`, `$\text{O}(1)$`, `$2^{10} = 1024$`

## References and Links

- Link to other chapters using relative paths
- Link to diagram sections within same challenge
- Cross-reference related topics from 01-principles and 02-components
- Include "See also" sections for related concepts
- Reference pseudocode using format: `*See pseudocode.md::function_name() for implementation*`
- Link to supplementary files at top of main document: hld-diagram.md, sequence-diagrams.md, this-over-that.md, pseudocode.md

## Quality Checklist Before Submitting New Challenge

Before considering a challenge complete, verify all 6 required files exist and meet standards:

### ‚ö†Ô∏è CRITICAL FORMAT VALIDATION (DO THIS FIRST):

**Run these validation commands:**

```bash
# Check main file section numbering (must be 1, 2, 3, 4, 5...)
grep "^## [0-9]" 03-challenges/3.x.y-problem-name/3.x.y-design-problem-name.md

# Check for note block in main file
head -10 03-challenges/3.x.y-problem-name/3.x.y-design-problem-name.md | grep "Note on Implementation"

# Check for diagrams section in main file
head -20 03-challenges/3.x.y-problem-name/3.x.y-design-problem-name.md | grep "Visual Diagrams"

# Check for TOC in hld-diagram.md
head -10 03-challenges/3.x.y-problem-name/hld-diagram.md | grep "Table of Contents"

# Check for TOC in sequence-diagrams.md
head -10 03-challenges/3.x.y-problem-name/sequence-diagrams.md | grep "Table of Contents"

# Check pseudocode.md title format
head -1 03-challenges/3.x.y-problem-name/pseudocode.md

# Check this-over-that.md title format
head -1 03-challenges/3.x.y-problem-name/this-over-that.md
```

**VERIFY:**
- [ ] ‚úÖ Main file sections are numbered: 1, 2, 3, 4, 5... (NO duplicates, NO gaps)
- [ ] ‚úÖ Main file has note block BEFORE first section
- [ ] ‚úÖ Main file has "üìä Visual Diagrams & Resources" section BEFORE "## 1. Problem Statement"
- [ ] ‚úÖ README has same format (note + diagrams section at top)
- [ ] ‚úÖ hld-diagram.md has "## Table of Contents" section
- [ ] ‚úÖ sequence-diagrams.md has "## Table of Contents" section
- [ ] ‚úÖ pseudocode.md has correct title: `# [Challenge Name] - Pseudocode Implementations`
- [ ] ‚úÖ pseudocode.md has Table of Contents
- [ ] ‚úÖ this-over-that.md has correct title: `# [Challenge Name] - Design Decisions (This Over That)`
- [ ] ‚úÖ this-over-that.md has Table of Contents

### File Existence (6 files):
- [ ] `3.x.y-design-problem-name.md` exists (main comprehensive file)
- [ ] `README.md` exists (similar to main file)
- [ ] `hld-diagram.md` exists (10-15 diagrams with explanations)
- [ ] `sequence-diagrams.md` exists (10-15 diagrams with explanations)
- [ ] `this-over-that.md` exists (5-10 major design decisions)
- [ ] `pseudocode.md` exists (10-20 function implementations)

### ‚ö†Ô∏è Comprehensive Content Validation (CRITICAL):

**Run validation script:**
```bash
cd /path/to/challenge-folder

# Check line counts
MAIN=$(wc -l < 3.x.y-design-problem-name.md)
README=$(wc -l < README.md)
RATIO=$(echo "scale=0; $README * 100 / $MAIN" | bc)

echo "Main file: $MAIN lines"
echo "README: $README lines"
echo "Ratio: $RATIO%"

# Validate
if [ $MAIN -lt 800 ]; then
    echo "‚ùå Main file too short (minimum 800 lines)"
elif [ $RATIO -lt 75 ] || [ $RATIO -gt 120 ]; then
    echo "‚ùå README ratio out of range (should be 75-120%)"
else
    echo "‚úÖ Length validation passed"
fi
```

**Checklist:**
- [ ] ‚úÖ **Main file ‚â• 800 lines** (most challenges should be 1000+ lines)
- [ ] ‚úÖ **README is 75-120% of main file** (typically 77-100%, run validation script above)
- [ ] ‚úÖ **README includes ALL sections** from main file (not just a subset)
- [ ] ‚úÖ **Both files have complete tables** (not summary tables)
- [ ] ‚úÖ **Both files have full explanations** (not "see main file for details")

### Content Quality - Main File:
- [ ] ‚úÖ **EXACT FORMAT:** Title ‚Üí Note ‚Üí Diagrams Section ‚Üí `## 1. Problem Statement` ‚Üí `## 2. Requirements...`
- [ ] ‚úÖ **SECTION NUMBERING:** Sequential (1, 2, 3, 4...) with NO duplicates
- [ ] Has note at top referencing pseudocode.md
- [ ] NO detailed pseudocode (only descriptions + references to pseudocode.md)
- [ ] Includes: Problem, Requirements, Scale Estimation, Architecture, Data Model, Component Design, Bottlenecks, Anti-Patterns, Alternatives, Monitoring, Trade-offs, Real-World Examples, References
- [ ] "Why This Over That?" sections explain major choices inline (DB, cache, sync/async, etc.)
- [ ] ASCII diagrams use box-drawing characters
- [ ] LaTeX notation for technical symbols ($\text{QPS}$, $\text{O}(1)$, etc.)
- [ ] Scale estimation with back-of-envelope calculations
- [ ] Comparison tables for architectural choices
- [ ] Real-world examples (e.g., "Twitter uses X because...")

### Content Quality - README:
- [ ] ‚úÖ **SAME FORMAT as main file:** Title ‚Üí Note ‚Üí Diagrams Section ‚Üí Content
- [ ] ‚úÖ **COMPREHENSIVE (similar length to main file):** 75-120% of main file line count (typically 77-100%)
- [ ] ‚úÖ **ALL major sections included:** Requirements, Architecture, Component Design, Bottlenecks, Anti-Patterns, Trade-offs
- [ ] Has visual diagrams section at top with links to all files
- [ ] NO detailed pseudocode (only descriptions + references to pseudocode.md)
- [ ] References all supplementary files
- [ ] **Line count check:** README lines ‚â• 75% of main file lines

### Content Quality - Diagrams:
- [ ] ‚úÖ **hld-diagram.md has Table of Contents** at top
- [ ] ‚úÖ **sequence-diagrams.md has Table of Contents** at top
- [ ] ALL diagrams in hld-diagram.md have detailed flow explanations (with Steps, Benefits, Trade-offs)
- [ ] ALL diagrams in sequence-diagrams.md have detailed flow explanations (with numbered steps, performance)
- [ ] All Mermaid diagrams use ```mermaid tag
- [ ] Diagram count: 10-15 in hld-diagram.md, 10-15 in sequence-diagrams.md

### Content Quality - Design Decisions:
- [ ] this-over-that.md covers all major design decisions (typically 5-10)
- [ ] Each decision includes: Problem, Options Considered (with table), Decision Made, Rationale, Trade-offs, When to Reconsider
- [ ] Includes summary table at end
- [ ] Real-world examples included

### Content Quality - Pseudocode:
- [ ] ‚úÖ **pseudocode.md has standardized title:** `# [Challenge Name] - Pseudocode Implementations`
- [ ] ‚úÖ **pseudocode.md has intro description** (see format above)
- [ ] ‚úÖ **pseudocode.md has Table of Contents** at top
- [ ] Each function documented: Purpose, Parameters, Returns, Algorithm, Time Complexity, Example Usage
- [ ] ALL functions referenced via `pseudocode.md::function_name()` in main/README actually exist
- [ ] No language tags on pseudocode blocks (just ```)
- [ ] Includes anti-pattern examples where relevant
- [ ] Typical count: 10-20 functions

### Content Quality - This Over That:
- [ ] ‚úÖ **this-over-that.md has standardized title:** `# [Challenge Name] - Design Decisions (This Over That)`
- [ ] ‚úÖ **this-over-that.md has Table of Contents** at top

### Code Block Formatting:
- [ ] No programming language code (Python, Java, Go, etc.) anywhere
- [ ] Pseudocode uses NO language tag (just ```)
- [ ] ASCII diagrams use NO language tag (just ```)
- [ ] SQL schemas use ```sql tag
- [ ] Mermaid diagrams use ```mermaid tag
- [ ] Never indent triple backticks (column 0)
- [ ] Never include line numbers in code content

### Cross-Reference Verification:
- [ ] All pseudocode references in main file exist in pseudocode.md
- [ ] All pseudocode references in README exist in pseudocode.md
- [ ] All diagram links in main file point to correct sections
- [ ] All internal links work correctly

---

## üîß Automated Format Validation

### Run These Commands to Verify ALL Challenges Are Consistent:

```bash
# 1. Check section numbering in ALL main files (must be sequential: 1, 2, 3, 4...)
cd /path/to/hld-architecture-handbook/03-challenges
for dir in 3.*/; do 
  echo "=== $dir ===" 
  grep "^## [0-9]" "$dir"3.*.md | head -10
done

# 2. Verify ALL main files and READMEs have note + diagrams section at top
for dir in 3.*/; do
  echo "=== $dir MAIN ===" 
  head -20 "$dir"3.*.md | grep -E "^#|^>|^##"
  echo "=== $dir README ==="
  head -20 "$dir"README.md | grep -E "^#|^>|^##"
done

# 3. Verify ALL diagram files have Table of Contents
for dir in 3.*/; do
  echo "=== $dir ===" 
  echo "HLD TOC:" 
  head -5 "$dir"hld-diagram.md | grep "Table of Contents"
  echo "SEQ TOC:" 
  head -5 "$dir"sequence-diagrams.md | grep "Table of Contents"
done

# 4. Verify pseudocode.md and this-over-that.md title format
echo "=== PSEUDOCODE.MD TITLES ==="
for dir in 3.*/; do head -1 "$dir"pseudocode.md; done

echo "=== THIS-OVER-THAT.MD TITLES ==="
for dir in 3.*/; do head -1 "$dir"this-over-that.md; done
```

### Expected Output (All Challenges Should Match This):

**Main File Format:**
```
# 3.x.y Challenge Title
> üìö **Note on Implementation Details:**
## üìä Visual Diagrams & Resources
## 1. Problem Statement
## 2. Requirements and Scale Estimation
## 3. High-Level Architecture
## 4. [Next Section]
```

**Section Numbering (NO duplicates):**
```
## 1. Problem Statement
## 2. Requirements and Scale Estimation
## 3. High-Level Architecture
## 4. Detailed Component Design
## 5. [Continue sequentially...]
```

**Diagram Files (MUST have TOC):**
```
# [Challenge] - High-Level Design
## Table of Contents
```

**Pseudocode Files (MUST have standard title):**
```
# [Challenge Name] - Pseudocode Implementations
This document contains detailed algorithm implementations...
## Table of Contents
```

**This Over That Files (MUST have standard title):**
```
# [Challenge Name] - Design Decisions (This Over That)
This document provides in-depth analysis...
## Table of Contents
```

---

