# HLD Architecture Handbook - Cursor Rules

## Project Structure

This is a system design learning repository organized into:
- `01-principles/` - Core theoretical concepts
- `02-components/` - Deep dive into system components  
- `03-challenges/` - Real-world design problems with detailed solutions

## Design Challenge Structure

Each design challenge in `03-challenges/` follows this exact structure:

```
03-challenges/
├── 3.x.y-problem-name/
│   ├── 3.x.y-design-problem-name.md    # FULL comprehensive guide (main file)
│   ├── README.md                        # Identical or similar to main file
│   ├── hld-diagram.md                   # ONLY Mermaid architecture diagrams with explanations
│   ├── sequence-diagrams.md             # ONLY Mermaid sequence diagrams with explanations
│   ├── this-over-that.md                # In-depth discussion of design choices, trade-offs, and alternatives
│   └── pseudocode.md                    # OPTIONAL: Detailed algorithm implementations (if needed)
```

### File Content Guidelines

#### Main Challenge File (`3.x.y-design-problem-name.md`):
- **Complete standalone document** with all content
- **Must include note at top** referencing pseudocode.md if algorithms are present:
  ```
  > 📚 **Note on Implementation Details:**
  > This document focuses on high-level design concepts and architectural decisions. 
  > For detailed algorithm implementations, see **[pseudocode.md](./pseudocode.md)**.
  ```
- Includes ASCII diagrams inline using triple backticks without language specification
- Contains full explanations, high-level algorithms (NO detailed pseudocode)
- **NO programming language code** - only high-level logic descriptions and conceptual explanations
- **NO detailed pseudocode implementations** - describe algorithms in words, reference `pseudocode.md::function_name()` for implementation
- Includes "Why This Over That?" sections highlighting key design choices
- For every major choice (DB, cache, sync/async), explain the rationale with bullet points
- Links to diagram files, this-over-that.md, and pseudocode.md for detailed implementations
- Focus on WHAT and WHY, delegate HOW to pseudocode.md
- **Typical sections:** Problem Statement, Requirements, Scale Estimation, High-Level Architecture, Data Model, Component Design, Bottlenecks, Anti-Patterns, Alternative Approaches, Monitoring, Trade-offs Summary, Real-World Examples, References

#### README.md:
- Similar or identical to main challenge file (can be slightly condensed)
- **Must include visual diagrams section** at top with links:
  ```
  ## 📊 Visual Diagrams & Resources
  - **[High-Level Design Diagrams](./hld-diagram.md)** - System architecture, component design, data flow
  - **[Sequence Diagrams](./sequence-diagrams.md)** - Detailed interaction flows and failure scenarios
  - **[Design Decisions (This Over That)](./this-over-that.md)** - In-depth analysis of architectural choices
  - **[Pseudocode Implementations](./pseudocode.md)** - Detailed algorithm implementations
  ```
- **NO detailed pseudocode implementations** - only basic definitions and implementation descriptions
- Reference `pseudocode.md::function_name()` for all algorithm implementations
- Can include quick overview tables for key metrics, design decisions, and technology choices

#### hld-diagram.md:
- Contains ONLY Mermaid diagrams for:
  - System architecture
  - Component design
  - Data flow
  - Scaling strategies
  - Storage architecture
  - Multi-region deployment
  - Monitoring dashboards
- Each diagram should be in a Mermaid code block (```mermaid)
- **CRITICAL: MUST include flow explanations** above or below EVERY diagram
- Flow explanations should include:
  - **Flow Explanation:** heading (bold)
  - Brief description of what the diagram shows
  - **Key components/steps** enumerated (numbered list)
  - **Benefits/trade-offs** of the design shown (bullet points)
  - **Performance characteristics** if applicable (latency, throughput)
  - Example format:
    ```
    **Flow Explanation:**
    
    This diagram shows X doing Y.
    
    **Steps:**
    1. Component A receives request
    2. A → B: Data flows from A to B
    3. C processes and returns result
    
    **Benefits:**
    - Fast: <10ms latency
    - Scalable: Horizontal scaling supported
    - Resilient: Handles node failures
    
    **Trade-offs:**
    - Eventual consistency
    - Higher infrastructure cost
    ```
- Typical diagrams count: 10-15 diagrams per challenge

#### sequence-diagrams.md:
- Contains ONLY Mermaid sequence diagrams for:
  - Request/response flows (happy path)
  - Interaction between components
  - Failure scenarios
  - Failover processes
  - Cache hit/miss flows
  - Multi-region replication
  - Rate limiting
  - Cache invalidation
- **CRITICAL: MUST include flow explanations** above or below EVERY diagram
- Flow explanations should describe:
  - **Flow:** One-line summary of the sequence (bold heading)
  - Step-by-step interaction pattern (numbered list)
  - Performance characteristics (latency, throughput)
  - When this flow happens (happy path, error scenario, etc.)
  - Edge cases handled
  - Example format:
    ```
    **Flow:**
    
    Shows the complete flow of a user posting a tweet from client request to fanout completion.
    
    **Steps:**
    1. **Client Request** (0ms): User posts tweet via mobile/web app
    2. **API Gateway** (10ms): JWT validation, rate limit check
    3. **Post Service** (20ms): Validates content, generates ID
    4. **PostgreSQL** (20ms): Inserts tweet (ACID)
    5. **Kafka** (5ms): Publishes event (non-blocking)
    6. **Return to Client** (~100ms total): User doesn't wait for fanout
    
    **Performance:**
    - Client response: <100ms (user doesn't wait for fanout)
    - Fanout completion: ~10 seconds (for 5,000 followers)
    ```
- Typical diagrams count: 10-15 sequence diagrams per challenge

#### this-over-that.md:
- **REQUIRED FILE** - Deep dive into design decisions
- Contains in-depth discussion of all major architectural choices (typically 5-10 decisions):
  - Primary strategy choice (e.g., fanout strategy, sharding strategy)
  - Database selection (SQL vs NoSQL with specific DB comparisons)
  - Message queue choice (Kafka vs RabbitMQ vs SQS)
  - Cache strategy (Redis vs Memcached)
  - Sync vs Async processing
  - Push vs Pull models
  - Consistency models (ACID vs BASE)
- For each choice, document:
  - **The Problem**: What are we trying to solve? (constraints, requirements)
  - **Options Considered**: All alternatives with detailed comparison tables
    - Include columns: pros, cons, performance, cost, complexity
    - Provide specific metrics where possible
  - **Decision Made**: What we chose and why (3-5 bullet points)
  - **Rationale**: Detailed explanation with numbered points
  - **Implementation Details**: How it's implemented (brief)
  - **Trade-offs Accepted**: What we're sacrificing (table format)
  - **When to Reconsider**: Specific conditions that would change the decision
- Include real-world examples (e.g., "Twitter uses X because...", "Instagram chose Y for...")
- **Summary table** at end comparing all decisions
- Typical length: 15-25 sections (1-2 sections per major decision)

#### pseudocode.md (REQUIRED for most challenges):
- Contains detailed algorithm implementations in pseudocode
- **Main files and README should NEVER contain detailed pseudocode** - they should describe logic in words and reference this file
- Reference format: `*See pseudocode.md::function_name() for implementation*` or `*See pseudocode.md::ClassName for detailed implementation*`
- **Structure:**
  - **Title:** "# Pseudocode Implementations: [Challenge Name]"
  - **Description:** Brief intro paragraph
  - **Table of Contents** at the top with links to all sections
  - Sections organized by functionality (e.g., "## Fanout Strategies", "## Cache Operations", "## Write Path")
  - Each function documented with:
    - **Purpose:** One-line description
    - **Parameters:** List with types and descriptions
    - **Returns:** Return type and description
    - **Algorithm:** Detailed pseudocode implementation (NO language tags, just ```)
    - **Time Complexity:** Big-O analysis
    - **Example Usage:** Sample code showing how to call the function
- **Pseudocode Style:**
  - Use `function function_name(param1, param2):` format
  - Use indentation for blocks (2 or 4 spaces)
  - Use `//` for comments
  - Use `if/else`, `for`, `while` keywords
  - Use descriptive variable names
  - Include error handling (`try/catch`, `throw`)
- Include anti-pattern examples (❌ bad vs ✅ good) where relevant
- Use clear function names: `function_name()`, `ClassName`, `method_name()`
- Typical function count: 10-20 functions per challenge
- Only skip this file if the challenge has NO algorithmic complexity (rare)

## Code Block Formatting Rules

**CRITICAL**: Follow these markdown code block rules exactly:

### For Pseudocode/Algorithms (No Language Tag):
```
function example():
  // pseudocode here
  return result
```

### For ASCII Diagrams (No Language Tag):
```
┌─────────────┐
│   Component │
└─────────────┘
```

### For SQL Schemas Only (Use Language Tag):
```sql
CREATE TABLE example (
    id BIGINT PRIMARY KEY
);
```

**IMPORTANT**: NO other programming language code (Python, Java, Go, etc.) should be used in challenges. Use pseudocode or describe logic in words instead.

### For Mermaid Diagrams (Always Use `mermaid` Tag):
```mermaid
graph TB
    A[Start] --> B[End]
```

### General Code Block Rules:
- Use triple backticks for code blocks
- For pseudocode/algorithms: NO language tag (just ```)
- For ASCII art/diagrams: NO language tag (just ```)
- For SQL schemas: USE ```sql tag
- For Mermaid diagrams: ALWAYS use ```mermaid
- **NO programming language implementations** (no Python, Java, Go, JavaScript, etc.)
- Never include line numbers in code content
- Never indent the triple backticks (always start at column 0)

## Writing Style

### Technical Content:
- Provide intuitive explanations first, then technical details
- Use tables for comparisons
- Include "Why this over that?" explanations
- Document trade-offs explicitly
- Use LaTeX math notation: $\text{notation}$ for inline, display for blocks

### Structure:
1. Problem Statement
2. Requirements and Scale Estimation  
3. High-Level Architecture
4. Detailed Component Design
5. Bottlenecks and Future Scaling
6. Common Anti-Patterns (with ❌ and ✅)
7. Alternative Approaches
8. Monitoring and Observability
9. Trade-offs Summary

### Design Patterns:
- Start with scale estimation and back-of-envelope calculations
- Always include comparison tables for architectural choices
- Document both the chosen approach AND alternatives not chosen
- Include anti-patterns section with bad vs good examples
- Provide real-world comparison (e.g., "Twitter uses...", "Uber uses...")

## Visual Diagrams

### ASCII Diagrams:
- Use for simple component layouts
- Place inline in main document
- Use box-drawing characters: ┌ ─ ┐ │ └ ┘ ┬ ┴ ├ ┤ ┼
- No language tag in code block

### Mermaid Diagrams:
- Use for complex system architecture
- Place in separate `.md` files (hld-diagram.md, sequence-diagrams.md)
- Link from main document
- Always use ```mermaid code blocks
- Supported types:
  - `graph TB/LR` for flowcharts
  - `sequenceDiagram` for interactions
  - `flowchart TD/LR` for detailed flows

## Examples to Follow

### Reference Implementations:
- **URL Shortener (3.1.1)**: `03-challenges/3.1.1-url-shortener/` - Good example of Base62 encoding, ID generation, caching patterns
- **Distributed Cache (3.1.2)**: `03-challenges/3.1.2-distributed-cache/` - Good example of consistent hashing, eviction policies
- **Distributed ID Generator (3.1.3)**: `03-challenges/3.1.3-distributed-id-generator/` - Good example of Snowflake algorithm, clock drift handling
- **Twitter Timeline (3.2.1)**: `03-challenges/3.2.1-twitter-timeline/` - Good example of fanout strategies, hybrid models, multi-region architecture

### Challenge Categories:
- **3.1.x** (Easy): Caching, databases, basic scaling
- **3.2.x** (Medium): Asynchrony, feeds, microservices, geo-spatial  
- **3.3.x** (Hard): Consistency, transactions, consensus, real-time geo

## Common Mistakes to Avoid

1. ❌ DO NOT use language tags for pseudocode (use plain ```)
2. ❌ DO NOT use language tags for ASCII diagrams (use plain ```)
3. ❌ DO NOT create challenge files outside the folder structure
4. ❌ DO NOT mix diagram content with theory in main file
5. ❌ DO NOT indent triple backticks (always column 0)
6. ❌ DO NOT include line numbers in code blocks
7. ❌ DO NOT create separate README and main file with different content (keep them similar/identical)
8. ❌ DO NOT include programming language code (Python, Java, Go, etc.) - use pseudocode only
9. ❌ DO NOT create diagrams without flow explanations - EVERY diagram MUST have explanation
10. ❌ DO NOT skip the this-over-that.md file - it's critical for understanding design decisions
11. ❌ DO NOT put detailed pseudocode in main challenge files or README - use pseudocode.md and reference it
12. ❌ DO NOT forget to verify that pseudocode.md contains ALL functions referenced in main/README files
13. ❌ DO NOT create pseudocode functions without clear purpose documentation
14. ❌ DO NOT skip Table of Contents in pseudocode.md - helps navigation

## When Adding New Challenges

1. Create folder: `03-challenges/3.x.y-problem-name/`
2. Create main file: `3.x.y-design-problem-name.md` (comprehensive, NO detailed pseudocode, NO programming code)
3. Create `README.md` (similar to main file, NO detailed pseudocode)
4. Create `hld-diagram.md` (Mermaid diagrams WITH flow explanations for EVERY diagram)
5. Create `sequence-diagrams.md` (Mermaid diagrams WITH step-by-step flow explanations for EVERY diagram)
6. Create `this-over-that.md` (in-depth design decision discussions)
7. Create `pseudocode.md` (REQUIRED for most challenges - contains ALL algorithm implementations)
8. Follow existing challenge structure exactly (see `03-challenges/3.1.1-url-shortener/` as reference)
9. Use proper code block formatting (no language for pseudocode/ASCII, SQL for schemas only)
10. Include "Why This Over That?" sections for every major choice
11. Include comprehensive sections: requirements, architecture, bottlenecks, anti-patterns, alternatives
12. NO programming language implementations - only pseudocode in pseudocode.md
13. Verify ALL referenced functions (`pseudocode.md::function_name()`) exist in pseudocode.md
14. Add Table of Contents to pseudocode.md for easy navigation

## Mathematical Notation

Use LaTeX for technical notation:
- Inline: `$\text{notation}$`
- Display: `$$\text{formula}$$`
- Examples: `$\text{QPS}$`, `$\text{O}(1)$`, `$2^{10} = 1024$`

## References and Links

- Link to other chapters using relative paths
- Link to diagram sections within same challenge
- Cross-reference related topics from 01-principles and 02-components
- Include "See also" sections for related concepts
- Reference pseudocode using format: `*See pseudocode.md::function_name() for implementation*`
- Link to supplementary files at top of main document: hld-diagram.md, sequence-diagrams.md, this-over-that.md, pseudocode.md

## Quality Checklist Before Submitting New Challenge

Before considering a challenge complete, verify all 6 required files exist and meet standards:

### File Existence (6 files):
- [ ] `3.x.y-design-problem-name.md` exists (main comprehensive file)
- [ ] `README.md` exists (similar to main file)
- [ ] `hld-diagram.md` exists (10-15 diagrams with explanations)
- [ ] `sequence-diagrams.md` exists (10-15 diagrams with explanations)
- [ ] `this-over-that.md` exists (5-10 major design decisions)
- [ ] `pseudocode.md` exists (10-20 function implementations)

### Content Quality - Main File:
- [ ] Has note at top referencing pseudocode.md
- [ ] NO detailed pseudocode (only descriptions + references to pseudocode.md)
- [ ] Includes: Problem, Requirements, Scale Estimation, Architecture, Data Model, Component Design, Bottlenecks, Anti-Patterns, Alternatives, Monitoring, Trade-offs, Real-World Examples, References
- [ ] "Why This Over That?" sections explain major choices inline (DB, cache, sync/async, etc.)
- [ ] ASCII diagrams use box-drawing characters
- [ ] LaTeX notation for technical symbols ($\text{QPS}$, $\text{O}(1)$, etc.)
- [ ] Scale estimation with back-of-envelope calculations
- [ ] Comparison tables for architectural choices
- [ ] Real-world examples (e.g., "Twitter uses X because...")

### Content Quality - README:
- [ ] Has visual diagrams section at top with links to all files
- [ ] NO detailed pseudocode (only descriptions + references to pseudocode.md)
- [ ] References all supplementary files

### Content Quality - Diagrams:
- [ ] ALL diagrams in hld-diagram.md have detailed flow explanations (with Steps, Benefits, Trade-offs)
- [ ] ALL diagrams in sequence-diagrams.md have detailed flow explanations (with numbered steps, performance)
- [ ] All Mermaid diagrams use ```mermaid tag
- [ ] Diagram count: 10-15 in hld-diagram.md, 10-15 in sequence-diagrams.md

### Content Quality - Design Decisions:
- [ ] this-over-that.md covers all major design decisions (typically 5-10)
- [ ] Each decision includes: Problem, Options Considered (with table), Decision Made, Rationale, Trade-offs, When to Reconsider
- [ ] Includes summary table at end
- [ ] Real-world examples included

### Content Quality - Pseudocode:
- [ ] pseudocode.md has Table of Contents
- [ ] Each function documented: Purpose, Parameters, Returns, Algorithm, Time Complexity, Example Usage
- [ ] ALL functions referenced via `pseudocode.md::function_name()` in main/README actually exist
- [ ] No language tags on pseudocode blocks (just ```)
- [ ] Includes anti-pattern examples where relevant
- [ ] Typical count: 10-20 functions

### Code Block Formatting:
- [ ] No programming language code (Python, Java, Go, etc.) anywhere
- [ ] Pseudocode uses NO language tag (just ```)
- [ ] ASCII diagrams use NO language tag (just ```)
- [ ] SQL schemas use ```sql tag
- [ ] Mermaid diagrams use ```mermaid tag
- [ ] Never indent triple backticks (column 0)
- [ ] Never include line numbers in code content

### Cross-Reference Verification:
- [ ] All pseudocode references in main file exist in pseudocode.md
- [ ] All pseudocode references in README exist in pseudocode.md
- [ ] All diagram links in main file point to correct sections
- [ ] All internal links work correctly

