# HLD Architecture Handbook - Cursor Rules

## Project Structure

This is a system design learning repository organized into:
- `01-principles/` - Core theoretical concepts
- `02-components/` - Deep dive into system components  
- `03-challenges/` - Real-world design problems with detailed solutions

## Design Challenge Structure

Each design challenge in `03-challenges/` follows this exact structure:

```
03-challenges/
‚îú‚îÄ‚îÄ 3.x.y-problem-name/
‚îÇ   ‚îú‚îÄ‚îÄ 3.x.y-design-problem-name.md    # FULL comprehensive guide (main file)
‚îÇ   ‚îú‚îÄ‚îÄ README.md                        # Identical or similar to main file
‚îÇ   ‚îú‚îÄ‚îÄ hld-diagram.md                   # ONLY Mermaid architecture diagrams with explanations
‚îÇ   ‚îú‚îÄ‚îÄ sequence-diagrams.md             # ONLY Mermaid sequence diagrams with explanations
‚îÇ   ‚îú‚îÄ‚îÄ this-over-that.md                # In-depth discussion of design choices, trade-offs, and alternatives
‚îÇ   ‚îî‚îÄ‚îÄ pseudocode.md                    # OPTIONAL: Detailed algorithm implementations (if needed)
```

### File Content Guidelines

#### Main Challenge File (`3.x.y-design-problem-name.md`):
- **Complete standalone document** with all content
- **Must include note at top** referencing pseudocode.md if algorithms are present:
  ```
  > üìö **Note on Implementation Details:**
  > This document focuses on high-level design concepts and architectural decisions. 
  > For detailed algorithm implementations, see **[pseudocode.md](./pseudocode.md)**.
  ```
- Includes ASCII diagrams inline using triple backticks without language specification
- Contains full explanations, high-level algorithms (NO detailed pseudocode)
- **NO programming language code** - only high-level logic descriptions and conceptual explanations
- **NO detailed pseudocode implementations** - describe algorithms in words, reference `pseudocode.md::function_name()` for implementation
- Includes "Why This Over That?" sections highlighting key design choices
- For every major choice (DB, cache, sync/async), explain the rationale with bullet points
- Links to diagram files, this-over-that.md, and pseudocode.md for detailed implementations
- Focus on WHAT and WHY, delegate HOW to pseudocode.md
- **Typical sections:** Problem Statement, Requirements, Scale Estimation, High-Level Architecture, Data Model, Component Design, Bottlenecks, Anti-Patterns, Alternative Approaches, Monitoring, Trade-offs Summary, Real-World Examples, References

#### README.md:
- Similar or identical to main challenge file (can be slightly condensed)
- **Must include visual diagrams section** at top with links:
  ```
  ## üìä Visual Diagrams & Resources
  - **[High-Level Design Diagrams](./hld-diagram.md)** - System architecture, component design, data flow
  - **[Sequence Diagrams](./sequence-diagrams.md)** - Detailed interaction flows and failure scenarios
  - **[Design Decisions (This Over That)](./this-over-that.md)** - In-depth analysis of architectural choices
  - **[Pseudocode Implementations](./pseudocode.md)** - Detailed algorithm implementations
  ```
- **NO detailed pseudocode implementations** - only basic definitions and implementation descriptions
- Reference `pseudocode.md::function_name()` for all algorithm implementations
- Can include quick overview tables for key metrics, design decisions, and technology choices

#### hld-diagram.md:
- Contains ONLY Mermaid diagrams for:
  - System architecture
  - Component design
  - Data flow
  - Scaling strategies
  - Storage architecture
  - Multi-region deployment
  - Monitoring dashboards
- Each diagram should be in a Mermaid code block (```mermaid)
- **CRITICAL: MUST include flow explanations** above or below EVERY diagram
- Flow explanations should include:
  - **Flow Explanation:** heading (bold)
  - Brief description of what the diagram shows
  - **Key components/steps** enumerated (numbered list)
  - **Benefits/trade-offs** of the design shown (bullet points)
  - **Performance characteristics** if applicable (latency, throughput)
  - Example format:
    ```
    **Flow Explanation:**
    
    This diagram shows X doing Y.
    
    **Steps:**
    1. Component A receives request
    2. A ‚Üí B: Data flows from A to B
    3. C processes and returns result
    
    **Benefits:**
    - Fast: <10ms latency
    - Scalable: Horizontal scaling supported
    - Resilient: Handles node failures
    
    **Trade-offs:**
    - Eventual consistency
    - Higher infrastructure cost
    ```
- Typical diagrams count: 10-15 diagrams per challenge

#### sequence-diagrams.md:
- Contains ONLY Mermaid sequence diagrams for:
  - Request/response flows (happy path)
  - Interaction between components
  - Failure scenarios
  - Failover processes
  - Cache hit/miss flows
  - Multi-region replication
  - Rate limiting
  - Cache invalidation
- **CRITICAL: MUST include flow explanations** above or below EVERY diagram
- Flow explanations should describe:
  - **Flow:** One-line summary of the sequence (bold heading)
  - Step-by-step interaction pattern (numbered list)
  - Performance characteristics (latency, throughput)
  - When this flow happens (happy path, error scenario, etc.)
  - Edge cases handled
  - Example format:
    ```
    **Flow:**
    
    Shows the complete flow of a user posting a tweet from client request to fanout completion.
    
    **Steps:**
    1. **Client Request** (0ms): User posts tweet via mobile/web app
    2. **API Gateway** (10ms): JWT validation, rate limit check
    3. **Post Service** (20ms): Validates content, generates ID
    4. **PostgreSQL** (20ms): Inserts tweet (ACID)
    5. **Kafka** (5ms): Publishes event (non-blocking)
    6. **Return to Client** (~100ms total): User doesn't wait for fanout
    
    **Performance:**
    - Client response: <100ms (user doesn't wait for fanout)
    - Fanout completion: ~10 seconds (for 5,000 followers)
    ```
- Typical diagrams count: 10-15 sequence diagrams per challenge

#### this-over-that.md:
- **REQUIRED FILE** - Deep dive into design decisions
- Contains in-depth discussion of all major architectural choices (typically 5-10 decisions):
  - Primary strategy choice (e.g., fanout strategy, sharding strategy)
  - Database selection (SQL vs NoSQL with specific DB comparisons)
  - Message queue choice (Kafka vs RabbitMQ vs SQS)
  - Cache strategy (Redis vs Memcached)
  - Sync vs Async processing
  - Push vs Pull models
  - Consistency models (ACID vs BASE)
- For each choice, document:
  - **The Problem**: What are we trying to solve? (constraints, requirements)
  - **Options Considered**: All alternatives with detailed comparison tables
    - Include columns: pros, cons, performance, cost, complexity
    - Provide specific metrics where possible
  - **Decision Made**: What we chose and why (3-5 bullet points)
  - **Rationale**: Detailed explanation with numbered points
  - **Implementation Details**: How it's implemented (brief)
  - **Trade-offs Accepted**: What we're sacrificing (table format)
  - **When to Reconsider**: Specific conditions that would change the decision
- Include real-world examples (e.g., "Twitter uses X because...", "Instagram chose Y for...")
- **Summary table** at end comparing all decisions
- Typical length: 15-25 sections (1-2 sections per major decision)

#### pseudocode.md (REQUIRED for most challenges):
- Contains detailed algorithm implementations in pseudocode
- **Main files and README should NEVER contain detailed pseudocode** - they should describe logic in words and reference this file
- Reference format: `*See pseudocode.md::function_name() for implementation*` or `*See pseudocode.md::ClassName for detailed implementation*`
- **Structure:**
  - **Title:** "# Pseudocode Implementations: [Challenge Name]"
  - **Description:** Brief intro paragraph
  - **Table of Contents** at the top with links to all sections
  - Sections organized by functionality (e.g., "## Fanout Strategies", "## Cache Operations", "## Write Path")
  - Each function documented with:
    - **Purpose:** One-line description
    - **Parameters:** List with types and descriptions
    - **Returns:** Return type and description
    - **Algorithm:** Detailed pseudocode implementation (NO language tags, just ```)
    - **Time Complexity:** Big-O analysis
    - **Example Usage:** Sample code showing how to call the function
- **Pseudocode Style:**
  - Use `function function_name(param1, param2):` format
  - Use indentation for blocks (2 or 4 spaces)
  - Use `//` for comments
  - Use `if/else`, `for`, `while` keywords
  - Use descriptive variable names
  - Include error handling (`try/catch`, `throw`)
- Include anti-pattern examples (‚ùå bad vs ‚úÖ good) where relevant
- Use clear function names: `function_name()`, `ClassName`, `method_name()`
- Typical function count: 10-20 functions per challenge
- Only skip this file if the challenge has NO algorithmic complexity (rare)

## Code Block Formatting Rules

**CRITICAL**: Follow these markdown code block rules exactly:

### For Pseudocode/Algorithms (No Language Tag):
```
function example():
  // pseudocode here
  return result
```

### For ASCII Diagrams (No Language Tag):
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Component ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### For SQL Schemas Only (Use Language Tag):
```sql
CREATE TABLE example (
    id BIGINT PRIMARY KEY
);
```

**IMPORTANT**: NO other programming language code (Python, Java, Go, etc.) should be used in challenges. Use pseudocode or describe logic in words instead.

### For Mermaid Diagrams (Always Use `mermaid` Tag):
```mermaid
graph TB
    A[Start] --> B[End]
```

### General Code Block Rules:
- Use triple backticks for code blocks
- For pseudocode/algorithms: NO language tag (just ```)
- For ASCII art/diagrams: NO language tag (just ```)
- For SQL schemas: USE ```sql tag
- For Mermaid diagrams: ALWAYS use ```mermaid
- **NO programming language implementations** (no Python, Java, Go, JavaScript, etc.)
- Never include line numbers in code content
- Never indent the triple backticks (always start at column 0)

## Writing Style

### Technical Content:
- Provide intuitive explanations first, then technical details
- Use tables for comparisons
- Include "Why this over that?" explanations
- Document trade-offs explicitly
- Use LaTeX math notation: $\text{notation}$ for inline, display for blocks

### Structure:
1. Problem Statement
2. Requirements and Scale Estimation  
3. High-Level Architecture
4. Detailed Component Design
5. Bottlenecks and Future Scaling
6. Common Anti-Patterns (with ‚ùå and ‚úÖ)
7. Alternative Approaches
8. Monitoring and Observability
9. Trade-offs Summary

### Design Patterns:
- Start with scale estimation and back-of-envelope calculations
- Always include comparison tables for architectural choices
- Document both the chosen approach AND alternatives not chosen
- Include anti-patterns section with bad vs good examples
- Provide real-world comparison (e.g., "Twitter uses...", "Uber uses...")

## Visual Diagrams

### ASCII Diagrams:
- Use for simple component layouts
- Place inline in main document
- Use box-drawing characters: ‚îå ‚îÄ ‚îê ‚îÇ ‚îî ‚îò ‚î¨ ‚î¥ ‚îú ‚î§ ‚îº
- No language tag in code block

### Mermaid Diagrams:
- Use for complex system architecture
- Place in separate `.md` files (hld-diagram.md, sequence-diagrams.md)
- Link from main document
- Always use ```mermaid code blocks
- Supported types:
  - `graph TB/LR` for flowcharts
  - `sequenceDiagram` for interactions
  - `flowchart TD/LR` for detailed flows

## Examples to Follow

### Reference Implementations:
- **URL Shortener (3.1.1)**: `03-challenges/3.1.1-url-shortener/` - Good example of Base62 encoding, ID generation, caching patterns
- **Distributed Cache (3.1.2)**: `03-challenges/3.1.2-distributed-cache/` - Good example of consistent hashing, eviction policies
- **Distributed ID Generator (3.1.3)**: `03-challenges/3.1.3-distributed-id-generator/` - Good example of Snowflake algorithm, clock drift handling
- **Twitter Timeline (3.2.1)**: `03-challenges/3.2.1-twitter-timeline/` - Good example of fanout strategies, hybrid models, multi-region architecture

### Challenge Categories:
- **3.1.x** (Easy): Caching, databases, basic scaling
- **3.2.x** (Medium): Asynchrony, feeds, microservices, geo-spatial  
- **3.3.x** (Hard): Consistency, transactions, consensus, real-time geo

## Common Mistakes to Avoid

1. ‚ùå DO NOT use language tags for pseudocode (use plain ```)
2. ‚ùå DO NOT use language tags for ASCII diagrams (use plain ```)
3. ‚ùå DO NOT create challenge files outside the folder structure
4. ‚ùå DO NOT mix diagram content with theory in main file
5. ‚ùå DO NOT indent triple backticks (always column 0)
6. ‚ùå DO NOT include line numbers in code blocks
7. ‚ùå DO NOT create separate README and main file with different content (keep them similar/identical)
8. ‚ùå DO NOT include programming language code (Python, Java, Go, etc.) - use pseudocode only
9. ‚ùå DO NOT create diagrams without flow explanations - EVERY diagram MUST have explanation
10. ‚ùå DO NOT skip the this-over-that.md file - it's critical for understanding design decisions
11. ‚ùå DO NOT put detailed pseudocode in main challenge files or README - use pseudocode.md and reference it
12. ‚ùå DO NOT forget to verify that pseudocode.md contains ALL functions referenced in main/README files
13. ‚ùå DO NOT create pseudocode functions without clear purpose documentation
14. ‚ùå DO NOT skip Table of Contents in pseudocode.md - helps navigation

## When Adding New Challenges

1. Create folder: `03-challenges/3.x.y-problem-name/`
2. Create main file: `3.x.y-design-problem-name.md` (comprehensive, NO detailed pseudocode, NO programming code)
3. Create `README.md` (similar to main file, NO detailed pseudocode)
4. Create `hld-diagram.md` (Mermaid diagrams WITH flow explanations for EVERY diagram)
5. Create `sequence-diagrams.md` (Mermaid diagrams WITH step-by-step flow explanations for EVERY diagram)
6. Create `this-over-that.md` (in-depth design decision discussions)
7. Create `pseudocode.md` (REQUIRED for most challenges - contains ALL algorithm implementations)
8. Follow existing challenge structure exactly (see `03-challenges/3.1.1-url-shortener/` as reference)
9. Use proper code block formatting (no language for pseudocode/ASCII, SQL for schemas only)
10. Include "Why This Over That?" sections for every major choice
11. Include comprehensive sections: requirements, architecture, bottlenecks, anti-patterns, alternatives
12. NO programming language implementations - only pseudocode in pseudocode.md
13. Verify ALL referenced functions (`pseudocode.md::function_name()`) exist in pseudocode.md
14. Add Table of Contents to pseudocode.md for easy navigation

## Mathematical Notation

Use LaTeX for technical notation:
- Inline: `$\text{notation}$`
- Display: `$$\text{formula}$$`
- Examples: `$\text{QPS}$`, `$\text{O}(1)$`, `$2^{10} = 1024$`

## References and Links

- Link to other chapters using relative paths
- Link to diagram sections within same challenge
- Cross-reference related topics from 01-principles and 02-components
- Include "See also" sections for related concepts
- Reference pseudocode using format: `*See pseudocode.md::function_name() for implementation*`
- Link to supplementary files at top of main document: hld-diagram.md, sequence-diagrams.md, this-over-that.md, pseudocode.md

## Quality Checklist Before Submitting New Challenge

Before considering a challenge complete, verify all 6 required files exist and meet standards:

### File Existence (6 files):
- [ ] `3.x.y-design-problem-name.md` exists (main comprehensive file)
- [ ] `README.md` exists (similar to main file)
- [ ] `hld-diagram.md` exists (10-15 diagrams with explanations)
- [ ] `sequence-diagrams.md` exists (10-15 diagrams with explanations)
- [ ] `this-over-that.md` exists (5-10 major design decisions)
- [ ] `pseudocode.md` exists (10-20 function implementations)

### Content Quality - Main File:
- [ ] Has note at top referencing pseudocode.md
- [ ] NO detailed pseudocode (only descriptions + references to pseudocode.md)
- [ ] Includes: Problem, Requirements, Scale Estimation, Architecture, Data Model, Component Design, Bottlenecks, Anti-Patterns, Alternatives, Monitoring, Trade-offs, Real-World Examples, References
- [ ] "Why This Over That?" sections explain major choices inline (DB, cache, sync/async, etc.)
- [ ] ASCII diagrams use box-drawing characters
- [ ] LaTeX notation for technical symbols ($\text{QPS}$, $\text{O}(1)$, etc.)
- [ ] Scale estimation with back-of-envelope calculations
- [ ] Comparison tables for architectural choices
- [ ] Real-world examples (e.g., "Twitter uses X because...")

### Content Quality - README:
- [ ] Has visual diagrams section at top with links to all files
- [ ] NO detailed pseudocode (only descriptions + references to pseudocode.md)
- [ ] References all supplementary files

### Content Quality - Diagrams:
- [ ] ALL diagrams in hld-diagram.md have detailed flow explanations (with Steps, Benefits, Trade-offs)
- [ ] ALL diagrams in sequence-diagrams.md have detailed flow explanations (with numbered steps, performance)
- [ ] All Mermaid diagrams use ```mermaid tag
- [ ] Diagram count: 10-15 in hld-diagram.md, 10-15 in sequence-diagrams.md

### Content Quality - Design Decisions:
- [ ] this-over-that.md covers all major design decisions (typically 5-10)
- [ ] Each decision includes: Problem, Options Considered (with table), Decision Made, Rationale, Trade-offs, When to Reconsider
- [ ] Includes summary table at end
- [ ] Real-world examples included

### Content Quality - Pseudocode:
- [ ] pseudocode.md has Table of Contents
- [ ] Each function documented: Purpose, Parameters, Returns, Algorithm, Time Complexity, Example Usage
- [ ] ALL functions referenced via `pseudocode.md::function_name()` in main/README actually exist
- [ ] No language tags on pseudocode blocks (just ```)
- [ ] Includes anti-pattern examples where relevant
- [ ] Typical count: 10-20 functions

### Code Block Formatting:
- [ ] No programming language code (Python, Java, Go, etc.) anywhere
- [ ] Pseudocode uses NO language tag (just ```)
- [ ] ASCII diagrams use NO language tag (just ```)
- [ ] SQL schemas use ```sql tag
- [ ] Mermaid diagrams use ```mermaid tag
- [ ] Never indent triple backticks (column 0)
- [ ] Never include line numbers in code content

### Cross-Reference Verification:
- [ ] All pseudocode references in main file exist in pseudocode.md
- [ ] All pseudocode references in README exist in pseudocode.md
- [ ] All diagram links in main file point to correct sections
- [ ] All internal links work correctly

