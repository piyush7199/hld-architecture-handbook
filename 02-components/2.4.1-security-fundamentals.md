# 2.4.1 Security Fundamentals: AuthN, AuthZ, and Encryption

## Intuitive Explanation

Security in a large system is built on three pillars:

- **Authentication (AuthN):** Who are you? (Proof of identity, like a password or token).
- **Authorization (AuthZ):** What are you allowed to do? (Permissions, like read-only or admin access).
- **Encryption:** Keeping secrets safe in transit and at rest ($\text{HTTPS}$, $\text{TLS}$).

---

## In-Depth Analysis

### 1. Authentication (AuthN)

The process of verifying a user's identity.

- **Sessions and Cookies:** Traditional method where the server generates a session $\text{ID}$ after login and stores
  it in a cookie. The server maintains the session state in a dedicated store ($\text{Redis}$).
- **JWT (JSON Web Tokens):** A modern, stateless approach. The server encodes user identity and permissions into a
  self-contained token signed with a secret key.
    - **Pros:** $\text{Stateless}$ (the $\text{API}$ $\text{Gateway}$ can validate the token without hitting the
      database on every request).
    - **Cons:** Tokens cannot be revoked instantly (the user remains authenticated until the token expires, or the token
      is added to a centralized "blacklist").

### 2. Authorization (AuthZ)

The process of granting or denying access to a specific resource or action.

- **Role-Based Access Control (RBAC):** Users are assigned to **Roles
  ** ($\text{Admin}$, $\text{Editor}$, $\text{Viewer}$), and
  permissions are granted to the roles. Simple and widely used.
- **Attribute-Based Access Control (ABAC):** Access is granted based on attributes of the user, resource, and
  environment (
  e.g., "Only allow employees in the $\text{UK}$ to modify $\text{UK}$ customer records during working hours"). Highly
  flexible but complex.

### 3. Encryption (Data Protection)

#### A. Encryption in Transit (TLS/SSL)

- **Mechanism:** $\text{Transport}$ $\text{Layer}$ $\text{Security}$ ($\text{TLS}$) uses a cryptographic protocol to
  secure communication over a network (i.e., $\text{HTTPS}$).
- **Benefit:** Prevents eavesdropping and Man-in-the-Middle attacks. **Must be enforced** for all communication,
  especially client-server (North-South) and service-to-service (East-West via $\text{mTLS}$ in
  a $\text{Service}$ $\text{Mesh}$).

#### B. Encryption at Rest

- **Mechanism:** Encrypting data when it is stored on disk (databases, file systems, object storage).
- **Benefit:** Protects data even if the storage hardware is physically stolen.

### 4. Common Web Vulnerabilities

- **XSS (Cross-Site Scripting):** Injecting malicious code (usually JavaScript) into a website viewed by other users.
    - **Mitigation:** Always sanitize all user input before rendering it.
- CSRF (Cross-Site Request Forgery): Forcing an authenticated user to unknowingly submit a malicious request to your
  website.
    - **Mitigation**: Use anti-$\text{CSRF}$ tokens or enforce same-site cookies.
- **SQL Injection:** Injecting malicious $\text{SQL}$ commands into input fields to query or modify the database.
    - **Mitigation:** Use Parameterized Queries (prepared statements).

---

## ‚úèÔ∏è Design Challenge

### Problem

You are designing an $\text{API}$ for a financial application. Explain why you would choose JWTs over traditional
server-side $\text{Sessions}$ for authentication at the $\text{API}$ $\text{Gateway}$, and describe the critical
drawback of $\text{JWTs}$ you must solve using a refresh token mechanism.

### Solution

#### üß© Scenario Summary

| Aspect                   | Requirement                                     |
|--------------------------|-------------------------------------------------|
| **System type**          | Financial API (requires security + scalability) |
| **Traffic nature**       | Distributed, stateless microservices            |
| **Authentication layer** | API Gateway (edge of system)                    |

#### ‚úÖ Why Choose JWTs Over Server-Side Sessions

**1. Stateless Authentication (Scalable Across Microservices)**

- JWTs are self-contained tokens ‚Äî they carry user identity, roles, and claims inside the token itself.
- The API Gateway can verify tokens locally (using a public key) without calling a session store or central DB.
- Ideal for microservice or multi-region deployments where session replication is expensive.

> **‚úÖ Benefit:** No dependency on a shared session cache (like Redis) ‚Üí improves scalability and reduces latency.

**2. Decoupled and Cross-Service Usability**

- Each microservice can independently validate JWTs ‚Äî no centralized session validation call.
- Works well with API Gateways, service meshes, and federated identity systems (like OAuth2 / OpenID Connect).

> **‚úÖ Benefit**: Clean separation between authentication and business logic.

**3. Improved Caching and Performance**

- Since JWTs are stateless, they can be cached at the edge (e.g., CDN or Gateway).
- Reduces authentication round-trips and load on authentication servers.

#### ‚ö†Ô∏è The Critical Drawback of JWTs

**‚ùå Non-Revocability Problem**

- Once a JWT is issued, it remains valid until expiry ‚Äî even if:
    - A user logs out,
    - Credentials are compromised, or
    - The user‚Äôs access rights change.

Because JWTs are not stored on the server, there‚Äôs no centralized way to ‚Äúinvalidate‚Äù them mid-lifecycle.

> ‚ö†Ô∏è Risk: If a token is stolen, an attacker can use it until it expires.

#### ‚úÖ Solution ‚Äî Use a Refresh Token Mechanism

How It Works

1. **Short-lived Access Token (JWT)** ‚Äî expires quickly (e.g., 5‚Äì15 minutes).
2. **Long-lived Refresh Token** ‚Äî securely stored and used to request new access tokens.
3. When access token expires, client sends the refresh token to the auth server for a new JWT.
4. The server can revoke refresh tokens in its database, effectively invalidating future access tokens.

> üí° Refresh tokens reintroduce controlled state ‚Äî allowing revocation while keeping access tokens stateless.

#### ‚öñÔ∏è Trade-offs

| Mechanism               | Pros                                       | Cons                                        |
|-------------------------|--------------------------------------------|---------------------------------------------|
| **JWT (Stateless)**     | Fast, scalable, works across microservices | Hard to revoke, larger payloads             |
| **Sessions (Stateful)** | Easy to revoke or expire centrally         | Harder to scale across distributed services |

#### ‚úÖ Final Summary

| Aspect            | Design Decision                           | Reason                                        |
|-------------------|-------------------------------------------|-----------------------------------------------|
| **Auth Type**     | **JWT-based (stateless)**                 | Scalable, independent verification at gateway |
| **Critical Risk** | Tokens can‚Äôt be revoked immediately       | JWTs are self-contained, no central state     |
| **Mitigation**    | **Use short-lived JWTs + refresh tokens** | Enables revocation & reissue flow securely    |
