# 2.4.4 OAuth 2.0 & JWT Deep Dive: Modern Authentication and Authorization

## Intuitive Explanation

Imagine you want to use a photo printing service, but it needs access to your Google Photos. Instead of giving the service your Google password (risky!), you use **OAuth 2.0** to grant limited access. Google shows you a consent screen: "Photo Printing Service wants to view your photos. Allow?" You click "Allow," and Google gives the service a **token (JWT)** that proves you authorized it‚Äîwithout ever sharing your password.

**In distributed systems:**
- **OAuth 2.0:** Authorization framework for granting limited access to resources
- **JWT (JSON Web Token):** Self-contained token format that encodes user identity and permissions
- **Goal:** Secure, scalable authentication without sharing passwords
- **Benefit:** Stateless authentication, fine-grained permissions, industry standard

---

## In-Depth Analysis

### 1. What is OAuth 2.0?

**OAuth 2.0** is an authorization framework that allows applications to obtain limited access to user accounts on HTTP services.

**Key Concepts:**
- **Resource Owner:** The user (owns the data)
- **Client:** The application requesting access
- **Authorization Server:** Issues tokens (e.g., Google, GitHub)
- **Resource Server:** Hosts protected resources (e.g., Google Photos API)

**Flow:**
```
User ‚Üí Client: "I want to access my photos"
Client ‚Üí Authorization Server: "User wants access"
Authorization Server ‚Üí User: "Do you allow this?"
User ‚Üí Authorization Server: "Yes, allow"
Authorization Server ‚Üí Client: "Here's a token"
Client ‚Üí Resource Server: "Here's the token, give me photos"
Resource Server ‚Üí Client: "Here are the photos"
```

### 2. OAuth 2.0 Grant Types

#### A. Authorization Code Flow (Most Common)

**Use Case:** Web applications, mobile apps

**Flow:**
```
1. User ‚Üí Client: Clicks "Login with Google"
2. Client ‚Üí Authorization Server: Redirects to authorization URL
   GET /authorize?client_id=xxx&redirect_uri=yyy&response_type=code&scope=photos
3. Authorization Server ‚Üí User: Shows consent screen
4. User ‚Üí Authorization Server: Clicks "Allow"
5. Authorization Server ‚Üí Client: Redirects with authorization code
   GET /callback?code=abc123
6. Client ‚Üí Authorization Server: Exchanges code for token
   POST /token
     grant_type=authorization_code
     code=abc123
     client_id=xxx
     client_secret=yyy
     redirect_uri=yyy
7. Authorization Server ‚Üí Client: Returns access token + refresh token
   {
     "access_token": "eyJhbGc...",
     "refresh_token": "def456",
     "expires_in": 3600,
     "token_type": "Bearer"
   }
8. Client ‚Üí Resource Server: Uses access token
   GET /api/photos
   Authorization: Bearer eyJhbGc...
```

**Security Features:**
- **Authorization Code:** Short-lived, single-use
- **Client Secret:** Proves client identity
- **Redirect URI:** Prevents code interception

#### B. Client Credentials Flow

**Use Case:** Service-to-service authentication (no user involved)

**Flow:**
```
1. Client ‚Üí Authorization Server: Request token
   POST /token
     grant_type=client_credentials
     client_id=xxx
     client_secret=yyy
     scope=api:read
2. Authorization Server ‚Üí Client: Returns access token
   {
     "access_token": "eyJhbGc...",
     "expires_in": 3600,
     "token_type": "Bearer"
   }
3. Client ‚Üí Resource Server: Uses access token
   GET /api/data
   Authorization: Bearer eyJhbGc...
```

**Use Cases:**
- Microservice-to-microservice communication
- Background jobs
- API-to-API calls

#### C. Resource Owner Password Credentials Flow

**Use Case:** Trusted first-party applications (not recommended for third-party)

**Flow:**
```
1. Client ‚Üí Authorization Server: Request token with username/password
   POST /token
     grant_type=password
     username=user@example.com
     password=secret123
     client_id=xxx
2. Authorization Server ‚Üí Client: Returns access token
```

**‚ö†Ô∏è Security Risk:** Client sees user password (only use for trusted apps)

#### D. Refresh Token Flow

**Use Case:** Extend session without re-authentication

**Flow:**
```
1. Client ‚Üí Authorization Server: Access token expired
2. Client ‚Üí Authorization Server: Request new token
   POST /token
     grant_type=refresh_token
     refresh_token=def456
     client_id=xxx
     client_secret=yyy
3. Authorization Server ‚Üí Client: Returns new access token
   {
     "access_token": "eyJhbGc...",
     "refresh_token": "ghi789",
     "expires_in": 3600
   }
```

**Benefits:**
- User doesn't need to re-authenticate
- Can revoke refresh token (logout everywhere)
- Shorter access token lifetime (more secure)

### 3. OAuth 2.0 Scopes

**Scopes** define what permissions the client is requesting.

**Examples:**
```
Google OAuth Scopes:
  - https://www.googleapis.com/auth/photoslibrary.readonly (read photos)
  - https://www.googleapis.com/auth/photoslibrary.appendonly (add photos)
  - https://www.googleapis.com/auth/userinfo.email (read email)

GitHub OAuth Scopes:
  - read:user (read user profile)
  - repo (full repository access)
  - public_repo (public repository access only)
```

**Principle of Least Privilege:**
```
‚ùå Bad: Request all scopes
  scope=read write delete admin

‚úÖ Good: Request only needed scopes
  scope=read photos
```

### 4. What is JWT?

**JWT (JSON Web Token)** is a compact, URL-safe token format for securely transmitting information between parties.

**JWT Structure:**
```
Header.Payload.Signature

Example:
eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.
SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

**Parts:**

**1. Header:**
```json
{
  "alg": "HS256",  // Algorithm (HMAC SHA-256)
  "typ": "JWT"     // Type
}
```

**2. Payload (Claims):**
```json
{
  "sub": "1234567890",           // Subject (user ID)
  "name": "John Doe",            // Name
  "iat": 1516239022,            // Issued at
  "exp": 1516242622,            // Expiration
  "scope": "read photos",       // OAuth scope
  "aud": "api.example.com"      // Audience
}
```

**3. Signature:**
```
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)
```

### 5. JWT Claims

**Standard Claims (RFC 7519):**
- **iss (Issuer):** Who issued the token
- **sub (Subject):** User ID
- **aud (Audience):** Intended recipient
- **exp (Expiration):** Token expiration time
- **iat (Issued At):** When token was issued
- **nbf (Not Before):** Token not valid before this time
- **jti (JWT ID):** Unique token identifier

**Custom Claims:**
```json
{
  "sub": "123",
  "roles": ["admin", "user"],
  "permissions": ["read:users", "write:orders"],
  "department": "engineering"
}
```

### 6. JWT Validation

**Validation Steps:**
```
1. Check Format:
   - Has 3 parts (header.payload.signature)
   - Base64URL encoded

2. Verify Signature:
   - Decode header (get algorithm)
   - Verify signature using secret/public key
   - Prevents tampering

3. Validate Claims:
   - exp: Token not expired
   - nbf: Token is valid (not before)
   - iss: Issuer matches expected
   - aud: Audience matches expected

4. Extract Claims:
   - sub: User ID
   - roles: User roles
   - permissions: User permissions
```

**Signature Algorithms:**

**HS256 (HMAC):**
```
- Symmetric (same secret for signing/verification)
- Fast
- Use case: Single server, internal services
```

**RS256 (RSA):**
```
- Asymmetric (private key signs, public key verifies)
- More secure
- Use case: Multiple services, public APIs
```

### 7. JWT vs. Session Tokens

| Aspect | JWT | Session Token |
|--------|-----|---------------|
| **Storage** | Client (cookie/localStorage) | Server (Redis, database) |
| **Stateless** | Yes | No (needs session store) |
| **Scalability** | Excellent (no server state) | Limited (needs shared session store) |
| **Revocation** | Difficult (until expiration) | Easy (delete session) |
| **Size** | Larger (includes claims) | Smaller (just ID) |
| **Security** | Depends on implementation | Server-controlled |

### 8. Token Management

#### A. Access Token Lifetime

**Short-Lived Tokens:**
```
Lifetime: 15 minutes
Benefits:
  - Less damage if stolen
  - Forces refresh token usage
  - Better security

Trade-off: More refresh token requests
```

**Long-Lived Tokens:**
```
Lifetime: 24 hours
Benefits:
  - Fewer refresh requests
  - Better user experience

Trade-off: Higher risk if stolen
```

#### B. Refresh Token Strategy

**Refresh Token Rotation:**
```
1. Client uses refresh token to get new access token
2. Server issues new refresh token
3. Old refresh token invalidated
4. Benefits: Detects token theft, limits damage
```

**Refresh Token Revocation:**
```
- User logs out ‚Üí Revoke refresh token
- User changes password ‚Üí Revoke all refresh tokens
- Suspicious activity ‚Üí Revoke refresh token
```

#### C. Token Storage

**Client-Side Storage Options:**

**HttpOnly Cookies:**
```
‚úÖ Good:
  - Not accessible to JavaScript (XSS protection)
  - Sent automatically with requests
  - Secure flag (HTTPS only)

‚ùå Bad:
  - CSRF vulnerability (mitigate with SameSite)
```

**localStorage:**
```
‚úÖ Good:
  - Easy to use
  - Persists across sessions

‚ùå Bad:
  - Accessible to JavaScript (XSS risk)
  - Not sent automatically
```

**Memory:**
```
‚úÖ Good:
  - Most secure (cleared on page close)
  - Not accessible to other scripts

‚ùå Bad:
  - Lost on page refresh
  - Not suitable for long sessions
```

### 9. OAuth 2.0 + JWT Integration

**Typical Flow:**
```
1. User authenticates via OAuth 2.0 (Authorization Code Flow)
2. Authorization Server issues JWT access token
3. Client stores JWT (cookie/localStorage)
4. Client sends JWT in Authorization header
5. Resource Server validates JWT (signature, claims)
6. Resource Server grants access based on JWT claims
```

**JWT as Access Token:**
```
Benefits:
  - Self-contained (no database lookup)
  - Stateless (scales horizontally)
  - Includes user info (no extra API call)

Example JWT:
{
  "sub": "user123",
  "scope": "read photos",
  "exp": 1516242622
}
```

### 10. OpenID Connect (OIDC)

**OIDC** extends OAuth 2.0 with authentication (not just authorization).

**Key Difference:**
- **OAuth 2.0:** Authorization (what can you access?)
- **OIDC:** Authentication + Authorization (who are you? + what can you access?)

**ID Token (JWT):**
```
OIDC adds ID token (in addition to access token):
{
  "sub": "user123",
  "email": "user@example.com",
  "name": "John Doe",
  "email_verified": true,
  "iss": "https://accounts.google.com",
  "aud": "client-id",
  "exp": 1516242622
}
```

**Use Cases:**
- Single Sign-On (SSO)
- User profile information
- Identity verification

---

## When to Use OAuth 2.0 & JWT

### ‚úÖ Use OAuth 2.0 When:

1. **Third-Party Access:** Allowing external apps to access user data
2. **API Access:** Providing API access to clients
3. **Single Sign-On (SSO):** Users authenticate once, access multiple services
4. **Delegated Authorization:** User grants limited permissions
5. **Microservices:** Service-to-service authentication

### ‚úÖ Use JWT When:

1. **Stateless Authentication:** No server-side session storage
2. **Microservices:** Services can validate tokens independently
3. **Mobile Apps:** Token stored on device
4. **API Authentication:** Stateless API authentication
5. **Distributed Systems:** No shared session store needed

### ‚ùå Don't Use OAuth 2.0 When:

1. **Simple Internal Auth:** Single application, no third-party access
2. **Low Security Needs:** Internal tools, development
3. **Complexity Not Needed:** Simple username/password sufficient

### ‚ùå Don't Use JWT When:

1. **Token Revocation Needed:** Need to revoke tokens immediately
2. **Large Payloads:** JWT size becomes issue (use session token)
3. **Sensitive Data:** Don't store sensitive data in JWT (it's readable)

---

## Real-World Examples

### Google OAuth 2.0

**Use Case:** Third-party apps access Google services

**Flow:**
- Authorization Code Flow
- Scopes: Gmail, Drive, Photos, Calendar
- JWT access tokens
- Refresh token rotation

**Scale:**
- Millions of OAuth clients
- Billions of token requests per day

### GitHub OAuth 2.0

**Use Case:** Third-party apps access GitHub repositories

**Flow:**
- Authorization Code Flow
- Scopes: repo, user, admin
- JWT access tokens
- Fine-grained permissions

### Auth0 / Okta

**Use Case:** Identity-as-a-Service (IDaaS)

**Features:**
- OAuth 2.0 / OIDC provider
- JWT tokens
- Social login (Google, Facebook, etc.)
- Multi-factor authentication

---

## OAuth 2.0 & JWT vs. Other Solutions

| Solution | Best For | Security | Complexity | Scalability |
|----------|----------|----------|------------|-------------|
| **OAuth 2.0 + JWT** | APIs, third-party access | High | Medium | Excellent |
| **Session Cookies** | Traditional web apps | Medium | Low | Limited |
| **API Keys** | Service-to-service | Low | Low | Excellent |
| **SAML** | Enterprise SSO | High | High | Good |
| **Basic Auth** | Internal tools | Low | Very Low | Excellent |

---

## Common Anti-Patterns

### ‚ùå **1. Storing Sensitive Data in JWT**

**Problem:** JWT is readable (just base64 encoded)

**Solution:** Don't store secrets in JWT

```
‚ùå Bad:
{
  "sub": "user123",
  "password": "secret123",  // NEVER!
  "credit_card": "1234-5678-9012-3456"  // NEVER!
}

‚úÖ Good:
{
  "sub": "user123",
  "roles": ["user"],
  "permissions": ["read:photos"]
}
```

### ‚ùå **2. Long-Lived Access Tokens**

**Problem:** Stolen token valid for long time

**Solution:** Use short-lived access tokens + refresh tokens

```
‚ùå Bad:
Access token: 24 hours (too long)

‚úÖ Good:
Access token: 15 minutes
Refresh token: 30 days
```

### ‚ùå **3. No Token Revocation**

**Problem:** Can't revoke compromised tokens

**Solution:** Implement token revocation (blacklist, refresh token rotation)

```
‚ùå Bad:
JWT valid until expiration (no way to revoke)

‚úÖ Good:
- Refresh token rotation (detects theft)
- Token blacklist (Redis) for revoked tokens
- Short access token lifetime
```

### ‚ùå **4. Weak JWT Secret**

**Problem:** Weak secret = tokens can be forged

**Solution:** Use strong, random secrets

```
‚ùå Bad:
Secret: "password123" (weak, guessable)

‚úÖ Good:
Secret: Random 256-bit key (generated securely)
```

---

## Trade-offs Summary

| Aspect | What You Gain | What You Sacrifice |
|--------|---------------|-------------------|
| **OAuth 2.0** | Industry standard, fine-grained permissions | Implementation complexity |
| **JWT** | Stateless, scalable | Token revocation difficulty |
| **Short-Lived Tokens** | Better security | More refresh requests |
| **Refresh Tokens** | Extended sessions | Additional complexity |
| **Stateless Auth** | Horizontal scalability | Can't revoke easily |

---

## References

- **OAuth 2.0 RFC:** [https://oauth.net/2/](https://oauth.net/2/)
- **JWT RFC 7519:** [https://jwt.io/introduction](https://jwt.io/introduction)
- **OIDC Specification:** [https://openid.net/connect/](https://openid.net/connect/)
- **Related Chapters:**
  - [2.4.1 Security Fundamentals](./2.4.1-security-fundamentals.md) - High-level security concepts
  - [2.0.5 API Gateway Deep Dive](../2.0-communication/2.0.5-api-gateway-deep-dive.md) - JWT validation in API Gateway

---

## ‚úèÔ∏è Design Challenge

### Problem

You are designing an authentication system for a SaaS platform with 1 million users that must:

1. **Support OAuth 2.0** (third-party apps can access user data)
2. **Issue JWT tokens** (stateless authentication)
3. **Handle 10,000 logins per minute** (peak traffic)
4. **Support refresh tokens** (extend sessions without re-authentication)
5. **Revoke tokens** (user logout, password change, suspicious activity)
6. **Multi-tenant** (different clients have different scopes)

**Constraints:**
- Must be stateless (no shared session store)
- Token validation <10ms (API Gateway validates tokens)
- Support token revocation
- High availability (99.99%)

Design an OAuth 2.0 + JWT strategy that:
- Handles high login volume
- Issues and validates JWT tokens efficiently
- Supports token revocation
- Enables multi-tenant scopes
- Ensures high availability

### Solution

#### üß© Scenario

- **Users:** 1 million
- **Logins:** 10,000 per minute = 167 per second
- **Token Validation:** <10ms (API Gateway)
- **Multi-Tenant:** Different clients, different scopes

**Calculations:**
- **Token Issuance:** 167 tokens/second (handled by auth server)
- **Token Validation:** 10,000+ validations/second (API Gateway)
- **Token Storage:** JWT (stateless, no storage needed)
- **Revocation:** Token blacklist (Redis)

#### ‚úÖ Step 1: OAuth 2.0 Architecture

**Choice: Authorization Code Flow + PKCE**

**Why:**
- **Authorization Code Flow:** Most secure for web/mobile apps
- **PKCE (Proof Key for Code Exchange):** Additional security for public clients
- **Industry Standard:** Widely supported

**Architecture:**
```
Authorization Server:
  - OAuth 2.0 endpoints (/authorize, /token)
  - JWT token issuance
  - Refresh token management
  - Token revocation (blacklist)
```

#### ‚úÖ Step 2: JWT Token Structure

**Access Token (JWT):**
```json
{
  "iss": "https://auth.example.com",
  "sub": "user123",
  "aud": "api.example.com",
  "exp": 1699123456,
  "iat": 1699120056,
  "scope": "read:photos write:photos",
  "client_id": "app-123",
  "tenant_id": "tenant-456",
  "jti": "token-uuid-789"
}
```

**Refresh Token (Opaque):**
```
- Stored in database (not JWT)
- Linked to user + client
- Can be revoked
- Rotated on each use
```

**Token Lifetime:**
```
Access Token: 15 minutes (short-lived)
Refresh Token: 30 days (long-lived)
```

#### ‚úÖ Step 3: Token Issuance

**Authorization Code Flow:**
```
1. User ‚Üí Client: Clicks "Login"
2. Client ‚Üí Auth Server: Redirects to /authorize
   GET /authorize?
     client_id=app-123
     &redirect_uri=https://app.example.com/callback
     &response_type=code
     &scope=read:photos write:photos
     &state=random-state
     &code_challenge=sha256(verifier)
     &code_challenge_method=S256
3. Auth Server ‚Üí User: Shows consent screen
4. User ‚Üí Auth Server: Clicks "Allow"
5. Auth Server ‚Üí Client: Redirects with code
   GET /callback?code=abc123&state=random-state
6. Client ‚Üí Auth Server: Exchanges code for token
   POST /token
     grant_type=authorization_code
     code=abc123
     client_id=app-123
     client_secret=secret-xyz
     redirect_uri=https://app.example.com/callback
     code_verifier=original-verifier
7. Auth Server ‚Üí Client: Returns tokens
   {
     "access_token": "eyJhbGc...",
     "refresh_token": "refresh-abc-123",
     "expires_in": 900,
     "token_type": "Bearer",
     "scope": "read:photos write:photos"
   }
```

**JWT Signing:**
```
Algorithm: RS256 (RSA)
- Private key: Signs tokens (auth server)
- Public key: Verifies tokens (API Gateway, resource servers)
- Benefits: Asymmetric (more secure), multiple verifiers
```

#### ‚úÖ Step 4: Token Validation

**API Gateway Validation:**
```
1. Client ‚Üí API Gateway: Request with JWT
   GET /api/photos
   Authorization: Bearer eyJhbGc...
2. API Gateway: Validates JWT
   - Decode JWT (header, payload, signature)
   - Verify signature (using public key)
   - Validate claims (exp, iss, aud)
   - Check token blacklist (Redis)
3. API Gateway ‚Üí Resource Server: Forward request with user context
   X-User-ID: user123
   X-Scope: read:photos write:photos
```

**Validation Performance:**
```
JWT Validation Steps:
  1. Decode: <1ms
  2. Signature verification: <5ms (RSA)
  3. Claims validation: <1ms
  4. Blacklist check: <3ms (Redis)
  Total: <10ms (meets requirement)
```

#### ‚úÖ Step 5: Token Revocation

**Token Blacklist (Redis):**
```
Revoked Token Storage:
  - Key: jwt:blacklist:{jti}
  - Value: expiration timestamp
  - TTL: Same as access token lifetime (15 minutes)

Revocation Flow:
  1. User logs out ‚Üí Add JWT jti to blacklist
  2. User changes password ‚Üí Add all user tokens to blacklist
  3. Suspicious activity ‚Üí Add token to blacklist
  4. Token validation ‚Üí Check blacklist (Redis lookup)
```

**Refresh Token Revocation:**
```
Refresh Token Storage (Database):
  - Table: refresh_tokens
  - Columns: token_hash, user_id, client_id, expires_at, revoked
  - Revocation: Set revoked=true

Benefits:
  - Can revoke specific refresh tokens
  - Can revoke all user tokens (password change)
  - Can track token usage
```

#### ‚úÖ Step 6: Refresh Token Flow

**Token Refresh:**
```
1. Client ‚Üí Auth Server: Access token expired
2. Client ‚Üí Auth Server: Request new token
   POST /token
     grant_type=refresh_token
     refresh_token=refresh-abc-123
     client_id=app-123
     client_secret=secret-xyz
3. Auth Server: Validates refresh token
   - Check database (exists, not revoked, not expired)
   - Verify client_id matches
4. Auth Server ‚Üí Client: Returns new tokens
   {
     "access_token": "eyJhbGc...",
     "refresh_token": "refresh-def-456",  // New refresh token
     "expires_in": 900
   }
5. Auth Server: Revokes old refresh token
   - Set revoked=true in database
```

**Refresh Token Rotation:**
```
Benefits:
  - Detects token theft (if old token used, it's revoked)
  - Limits damage (stolen token only valid until next refresh)
  - Better security
```

#### ‚úÖ Step 7: Multi-Tenant Scopes

**Scope Management:**
```
Per-Client Scopes:
  Client A: scope=read:photos write:photos
  Client B: scope=read:photos (read-only)
  Client C: scope=read:photos write:photos delete:photos

Scope Validation:
  - Auth Server: Issues tokens with client-specific scopes
  - API Gateway: Validates scope before forwarding request
  - Resource Server: Checks scope for operation
```

**Scope in JWT:**
```json
{
  "sub": "user123",
  "scope": "read:photos write:photos",
  "client_id": "app-123",
  "tenant_id": "tenant-456"
}
```

#### ‚úÖ Step 8: High Availability

**Authorization Server:**
```
Architecture:
  - 3 instances (load balanced)
  - Shared database (refresh tokens)
  - Shared Redis (token blacklist)
  - Public key distribution (JWKS endpoint)

Failover:
  - If one instance fails, others continue
  - Database replication (high availability)
  - Redis cluster (high availability)
```

**Token Validation:**
```
API Gateway:
  - Multiple instances
  - Public key caching (JWKS)
  - Redis cluster (blacklist)
  - No single point of failure
```

#### ‚úÖ Complete Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              Clients (Web, Mobile, Third-Party)          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ   Authorization Server       ‚îÇ
        ‚îÇ   (3 instances, load balanced)‚îÇ
        ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
        ‚îÇ   ‚îÇ /authorize           ‚îÇ  ‚îÇ
        ‚îÇ   ‚îÇ /token               ‚îÇ  ‚îÇ
        ‚îÇ   ‚îÇ /revoke              ‚îÇ  ‚îÇ
        ‚îÇ   ‚îÇ JWT Signing (RS256)  ‚îÇ  ‚îÇ
        ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ   Database (Refresh Tokens)  ‚îÇ
        ‚îÇ   - refresh_tokens table     ‚îÇ
        ‚îÇ   - user_id, client_id       ‚îÇ
        ‚îÇ   - revoked flag             ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ   Redis Cluster              ‚îÇ
        ‚îÇ   - Token blacklist (jti)    ‚îÇ
        ‚îÇ   - TTL: 15 minutes          ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ   API Gateway                ‚îÇ
        ‚îÇ   (JWT Validation)            ‚îÇ
        ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
        ‚îÇ   ‚îÇ Public Key (JWKS)     ‚îÇ  ‚îÇ
        ‚îÇ   ‚îÇ Blacklist Check       ‚îÇ  ‚îÇ
        ‚îÇ   ‚îÇ Scope Validation      ‚îÇ  ‚îÇ
        ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ   Resource Servers           ‚îÇ
        ‚îÇ   (API Services)              ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Request Flow:**
```
1. User ‚Üí Client: Login request
2. Client ‚Üí Auth Server: Authorization request
3. Auth Server ‚Üí User: Consent screen
4. User ‚Üí Auth Server: Approves
5. Auth Server ‚Üí Client: Authorization code
6. Client ‚Üí Auth Server: Exchange code for JWT
7. Auth Server ‚Üí Client: JWT access token + refresh token
8. Client ‚Üí API Gateway: Request with JWT
9. API Gateway: Validates JWT (signature, claims, blacklist)
10. API Gateway ‚Üí Resource Server: Request with user context
11. Resource Server ‚Üí Client: Response
```

#### ‚öñÔ∏è Trade-offs Summary

| Decision | What We Gain | What We Sacrifice |
|----------|--------------|-------------------|
| **JWT Access Tokens** | Stateless, scalable | Revocation complexity (blacklist needed) |
| **Short-Lived Tokens (15m)** | Better security | More refresh requests |
| **Refresh Token Rotation** | Theft detection | Additional database writes |
| **Token Blacklist (Redis)** | Immediate revocation | Additional lookup (3ms) |
| **RS256 (RSA)** | Multiple verifiers, secure | Slower than HS256 (5ms vs 1ms) |

#### ‚úÖ Final Summary

**OAuth 2.0 + JWT Strategy:**
- **OAuth Flow:** Authorization Code + PKCE
- **Access Token:** JWT (RS256, 15 minutes)
- **Refresh Token:** Opaque (database, 30 days, rotated)
- **Revocation:** Token blacklist (Redis) + refresh token revocation (database)
- **Validation:** API Gateway (public key, blacklist check, <10ms)
- **Multi-Tenant:** Per-client scopes in JWT

**Performance:**
- **Token Issuance:** 167 tokens/second (handled by 3 auth servers)
- **Token Validation:** <10ms (meets requirement)
- **Availability:** 99.99% (3 instances, HA database/Redis)

**Result:**
- ‚úÖ Supports OAuth 2.0 (Authorization Code Flow)
- ‚úÖ Issues JWT tokens (stateless)
- ‚úÖ Handles 10,000 logins/minute
- ‚úÖ Supports refresh tokens (30 days, rotated)
- ‚úÖ Token revocation (blacklist + database)
- ‚úÖ Multi-tenant scopes
- ‚úÖ High availability (99.99%)

