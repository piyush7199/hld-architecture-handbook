# 2.4.1 Security Fundamentals: AuthN, AuthZ, and Encryption

## Intuitive Explanation

Security in a large system is built on three pillars:

- **Authentication (AuthN):** Who are you? (Proof of identity, like a password or token).
- **Authorization (AuthZ):** What are you allowed to do? (Permissions, like read-only or admin access).
- **Encryption:** Keeping secrets safe in transit and at rest ($\text{HTTPS}$, $\text{TLS}$).

---

## In-Depth Analysis

### 1. Authentication (AuthN)

The process of verifying a user's identity.

- **Sessions and Cookies:** Traditional method where the server generates a session $\text{ID}$ after login and stores
  it in a cookie. The server maintains the session state in a dedicated store ($\text{Redis}$).
- **JWT (JSON Web Tokens):** A modern, stateless approach. The server encodes user identity and permissions into a
  self-contained token signed with a secret key.
    - **Pros:** $\text{Stateless}$ (the $\text{API}$ $\text{Gateway}$ can validate the token without hitting the
      database on every request).
    - **Cons:** Tokens cannot be revoked instantly (the user remains authenticated until the token expires, or the token
      is added to a centralized "blacklist").

### 2. Authorization (AuthZ)

The process of granting or denying access to a specific resource or action.

- **Role-Based Access Control (RBAC):** Users are assigned to **Roles
  ** ($\text{Admin}$, $\text{Editor}$, $\text{Viewer}$), and
  permissions are granted to the roles. Simple and widely used.
- **Attribute-Based Access Control (ABAC):** Access is granted based on attributes of the user, resource, and
  environment (
  e.g., "Only allow employees in the $\text{UK}$ to modify $\text{UK}$ customer records during working hours"). Highly
  flexible but complex.

### 3. Encryption (Data Protection)

#### A. Encryption in Transit (TLS/SSL)

- **Mechanism:** $\text{Transport}$ $\text{Layer}$ $\text{Security}$ ($\text{TLS}$) uses a cryptographic protocol to
  secure communication over a network (i.e., $\text{HTTPS}$).
- **Benefit:** Prevents eavesdropping and Man-in-the-Middle attacks. **Must be enforced** for all communication,
  especially client-server (North-South) and service-to-service (East-West via $\text{mTLS}$ in
  a $\text{Service}$ $\text{Mesh}$).

#### B. Encryption at Rest

- **Mechanism:** Encrypting data when it is stored on disk (databases, file systems, object storage).
- **Benefit:** Protects data even if the storage hardware is physically stolen.

### 4. Common Web Vulnerabilities

- **XSS (Cross-Site Scripting):** Injecting malicious code (usually JavaScript) into a website viewed by other users.
    - **Mitigation:** Always sanitize all user input before rendering it.
- CSRF (Cross-Site Request Forgery): Forcing an authenticated user to unknowingly submit a malicious request to your
  website.
    - **Mitigation**: Use anti-$\text{CSRF}$ tokens or enforce same-site cookies.
- **SQL Injection:** Injecting malicious $\text{SQL}$ commands into input fields to query or modify the database.
    - **Mitigation:** Use Parameterized Queries (prepared statements).

---

## üîê Authentication & Authorization Comparison

### Authentication Methods Comparison

| Method | How It Works | Security Level | Scalability | Use Case | Pros | Cons |
|--------|-------------|---------------|-------------|----------|------|------|
| **Session Cookies** | Server stores session, sends cookie ID | Medium | Limited (needs session store) | Traditional web apps | Simple, server controls sessions | Doesn't scale horizontally well |
| **JWT** | Self-contained token with signature | High | Excellent | Modern APIs, microservices | Stateless, scalable | Can't revoke easily, larger payload |
| **OAuth 2.0** | Delegated authorization protocol | High | Excellent | Third-party auth, API access | Industry standard, flexible | Complex to implement |
| **API Keys** | Static token for identification | Low | Excellent | Public APIs, rate limiting | Simple | No user context, hard to rotate |
| **SAML** | XML-based SSO | High | Good | Enterprise SSO | Mature, enterprise features | Complex, XML overhead |
| **Basic Auth** | Username:password in header | Low | Excellent | Internal tools, dev | Very simple | Credentials in every request |
| **Multi-Factor (MFA)** | Password + second factor | Very High | Good | High-security apps | Very secure | User friction |

### Authorization Models Comparison

| Model | How It Works | Complexity | Flexibility | Best For |
|-------|-------------|------------|-------------|----------|
| **RBAC** (Role-Based) | Users ‚Üí Roles ‚Üí Permissions | Low | Medium | Most applications |
| **ABAC** (Attribute-Based) | Policies based on attributes (user, resource, environment) | High | Very High | Complex enterprise systems |
| **ACL** (Access Control List) | Per-resource permission lists | Low | Low | File systems, simple apps |
| **ReBAC** (Relationship-Based) | Permissions based on relationships | Medium | High | Social networks, collaborative apps |
| **PBAC** (Policy-Based) | Centralized policy engine | High | Very High | Regulated industries, fine-grained control |

---

## ‚ö†Ô∏è Common Security Anti-Patterns

### Anti-Pattern 1: Storing Passwords in Plain Text

**Problem:**
```python
# ‚ùå CATASTROPHICALLY BAD!
def create_user(username, password):
    db.execute("""
        INSERT INTO users (username, password)
        VALUES (?, ?)
    """, username, password)
    # Password stored as "mypassword123"

# If database is compromised:
# - All user passwords exposed
# - Users who reuse passwords on other sites compromised
# - Company reputation destroyed
```

**Why It's Wrong:**
- Database breach exposes all passwords
- Insider threats can see passwords
- Violates compliance (GDPR, PCI-DSS)
- Users reuse passwords across sites

**Better Approach:**
```python
import bcrypt

# ‚úÖ Hash passwords with salt
def create_user(username, password):
    # Generate salt and hash
    password_hash = bcrypt.hashpw(
        password.encode('utf-8'),
        bcrypt.gensalt(rounds=12)
    )
    
    db.execute("""
        INSERT INTO users (username, password_hash)
        VALUES (?, ?)
    """, username, password_hash)

# Verify password
def verify_password(username, password):
    user = db.get_user(username)
    return bcrypt.checkpw(
        password.encode('utf-8'),
        user['password_hash']
    )

# Even if database is compromised:
# - Hashes are useless without rainbow table attacks
# - Salts prevent rainbow tables
# - bcrypt is slow (prevents brute force)
```

---

### Anti-Pattern 2: Rolling Your Own Crypto

**Problem:**
```python
# ‚ùå Homemade "encryption"
def encrypt(data, key):
    result = ""
    for i, char in enumerate(data):
        result += chr(ord(char) ^ ord(key[i % len(key)]))
    return result

# Trivial to break with frequency analysis!
```

**Why It's Wrong:**
- Home-brew crypto is almost always broken
- Missing: proper IV, authenticated encryption, key derivation
- Vulnerable to known attacks
- No security review

**Better Approach:**
```python
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2

# ‚úÖ Use battle-tested libraries
def encrypt_data(data, password, salt):
    # Derive key from password
    kdf = PBKDF2(
        algorithm=hashes.SHA256(),
        length=32,
        salt=salt,
        iterations=100000,
    )
    key = base64.urlsafe_b64encode(kdf.derive(password.encode()))
    
    # Encrypt with Fernet (AES-128-CBC + HMAC)
    f = Fernet(key)
    encrypted = f.encrypt(data.encode())
    return encrypted

def decrypt_data(encrypted_data, password, salt):
    kdf = PBKDF2(
        algorithm=hashes.SHA256(),
        length=32,
        salt=salt,
        iterations=100000,
    )
    key = base64.urlsafe_b64encode(kdf.derive(password.encode()))
    
    f = Fernet(key)
    decrypted = f.decrypt(encrypted_data)
    return decrypted.decode()
```

---

### Anti-Pattern 3: Exposing Sensitive Data in URLs

**Problem:**
```javascript
// ‚ùå Password reset with token in URL
GET /reset-password?token=SECRET_TOKEN&email=user@example.com

// Problems:
// 1. Token logged in server access logs
// 2. Token in browser history
// 3. Token in referrer headers
// 4. Token visible to proxies
```

**Why It's Wrong:**
- URLs are logged everywhere (server, proxy, browser)
- URLs shared accidentally (screenshots, emails)
- Referrer leakage to third parties

**Better Approach:**
```javascript
// ‚úÖ Sensitive data in POST body or headers
POST /reset-password
Headers: {
  "Authorization": "Bearer SECRET_TOKEN"
}
Body: {
  "email": "user@example.com",
  "new_password": "..."
}

// Or use session-based approach
GET /reset-password/:token
// Token verified server-side, not in logs
```

---

### Anti-Pattern 4: No Rate Limiting on Auth Endpoints

**Problem:**
```python
@app.route('/login', methods=['POST'])
def login():
    username = request.json['username']
    password = request.json['password']
    
    user = authenticate(username, password)
    if user:
        return {"token": generate_token(user)}
    else:
        return {"error": "Invalid credentials"}, 401

# Attacker can brute force passwords:
# - Try 1,000,000 passwords per minute
# - No delay, no lockout, no detection
```

**Why It's Wrong:**
- Enables brute force attacks
- Credential stuffing attacks
- Account enumeration
- DoS attacks

**Better Approach:**
```python
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

limiter = Limiter(
    app,
    key_func=get_remote_address,
    default_limits=["200 per day", "50 per hour"]
)

@app.route('/login', methods=['POST'])
@limiter.limit("5 per minute")  # Max 5 attempts per minute
def login():
    username = request.json['username']
    password = request.json['password']
    
    # Check failed attempts
    attempts = redis.get(f"login_attempts:{username}") or 0
    if int(attempts) >= 5:
        return {"error": "Account temporarily locked"}, 429
    
    user = authenticate(username, password)
    if user:
        # Reset attempts on success
        redis.delete(f"login_attempts:{username}")
        return {"token": generate_token(user)}
    else:
        # Increment failed attempts
        redis.incr(f"login_attempts:{username}")
        redis.expire(f"login_attempts:{username}", 900)  # 15 min lockout
        
        # Add exponential backoff
        sleep_time = min(2 ** int(attempts), 30)  # Max 30 seconds
        time.sleep(sleep_time)
        
        return {"error": "Invalid credentials"}, 401
```

---

### Anti-Pattern 5: Trusting Client-Side Validation

**Problem:**
```javascript
// Frontend validation only
function submitForm() {
    const email = document.getElementById('email').value;
    const age = document.getElementById('age').value;
    
    // ‚ùå Only client-side checks
    if (!email.includes('@')) {
        alert('Invalid email');
        return;
    }
    if (age < 18) {
        alert('Must be 18+');
        return;
    }
    
    // Send to server
    fetch('/api/register', {
        method: 'POST',
        body: JSON.stringify({email, age})
    });
}

// Attacker bypasses JavaScript:
// curl -X POST https://api.example.com/api/register \
//   -d '{"email":"hacker","age":1}'
```

**Why It's Wrong:**
- Attackers bypass client-side checks easily
- Browser DevTools can modify code
- API calls can be crafted manually

**Better Approach:**
```python
# ‚úÖ Always validate on server
from marshmallow import Schema, fields, validates, ValidationError

class RegistrationSchema(Schema):
    email = fields.Email(required=True)
    age = fields.Integer(required=True)
    
    @validates('age')
    def validate_age(self, value):
        if value < 18:
            raise ValidationError('Must be 18 or older')

@app.route('/api/register', methods=['POST'])
def register():
    schema = RegistrationSchema()
    
    try:
        # Validate input
        data = schema.load(request.json)
    except ValidationError as err:
        return {"errors": err.messages}, 400
    
    # Safe to process
    create_user(data['email'], data['age'])
    return {"status": "success"}
```

---

### Anti-Pattern 6: Insufficient Access Control

**Problem:**
```python
@app.route('/api/user/<user_id>/profile', methods=['GET'])
@login_required
def get_user_profile(user_id):
    # ‚ùå No check if current user can access this profile!
    user = db.get_user(user_id)
    return jsonify(user)

# Attacker can access any user's profile:
# GET /api/user/1/profile
# GET /api/user/2/profile
# GET /api/user/999/profile (admin!)
```

**Why It's Wrong:**
- Authenticated but not authorized
- Horizontal privilege escalation
- Data breach (access others' data)

**Better Approach:**
```python
@app.route('/api/user/<user_id>/profile', methods=['GET'])
@login_required
def get_user_profile(user_id):
    current_user = get_current_user()
    
    # ‚úÖ Check authorization
    if str(current_user.id) != str(user_id) and not current_user.is_admin:
        return {"error": "Forbidden"}, 403
    
    user = db.get_user(user_id)
    return jsonify(user)

# Better: Use decorator for reusability
def require_owner_or_admin(f):
    @wraps(f)
    def decorated_function(user_id, *args, **kwargs):
        current_user = get_current_user()
        if str(current_user.id) != str(user_id) and not current_user.is_admin:
            abort(403)
        return f(user_id, *args, **kwargs)
    return decorated_function

@app.route('/api/user/<user_id>/profile', methods=['GET'])
@login_required
@require_owner_or_admin
def get_user_profile(user_id):
    user = db.get_user(user_id)
    return jsonify(user)
```

---

### Anti-Pattern 7: Logging Sensitive Data

**Problem:**
```python
def process_payment(credit_card_number, cvv, amount):
    logger.info(f"Processing payment: card={credit_card_number}, cvv={cvv}, amount={amount}")
    # ‚ùå PCI-DSS violation! Sensitive data in logs
    
    result = payment_gateway.charge(credit_card_number, cvv, amount)
    
    logger.info(f"Payment result: {result}")
    return result

# Logs:
# 2024-10-25 10:30:15 - Processing payment: card=4532-1234-5678-9010, cvv=123, amount=99.99
# Compliance violation! Regulatory fine! Data breach!
```

**Why It's Wrong:**
- Violates PCI-DSS, GDPR, HIPAA
- Logs are stored insecurely
- Log aggregation systems expose data
- Regulatory fines ($$$)

**Better Approach:**
```python
def mask_sensitive_data(data, visible_chars=4):
    """Mask all but last N characters"""
    if len(data) <= visible_chars:
        return '*' * len(data)
    return '*' * (len(data) - visible_chars) + data[-visible_chars:]

def process_payment(credit_card_number, cvv, amount):
    # ‚úÖ Mask sensitive data in logs
    masked_card = mask_sensitive_data(credit_card_number, 4)
    logger.info(f"Processing payment: card={masked_card}, amount={amount}")
    # Logs: card=************9010, amount=99.99
    
    result = payment_gateway.charge(credit_card_number, cvv, amount)
    
    logger.info(f"Payment result: status={result['status']}, transaction_id={result['id']}")
    return result

# Never log:
# - Passwords
# - Credit card numbers (except last 4 digits)
# - CVV/CVC codes
# - Social Security Numbers
# - API keys/secrets
# - Session tokens
```

---

### Anti-Pattern 8: Hardcoded Secrets

**Problem:**
```python
# ‚ùå Secrets in code
DATABASE_URL = "postgresql://admin:SuperSecret123@db.example.com/prod"
API_KEY = "sk_live_51H123456789abcdef"
JWT_SECRET = "my-super-secret-key-dont-tell-anyone"

# Problems:
# 1. Committed to Git (public/private repos)
# 2. Visible to all developers
# 3. Hard to rotate
# 4. Leaked in error messages
```

**Why It's Wrong:**
- Secrets in version control history forever
- Can't rotate without code deploy
- Visible to all developers
- Accidental exposure (screenshots, logs)

**Better Approach:**
```python
import os
from dotenv import load_dotenv

# ‚úÖ Load secrets from environment
load_dotenv()

DATABASE_URL = os.getenv('DATABASE_URL')
API_KEY = os.getenv('API_KEY')
JWT_SECRET = os.getenv('JWT_SECRET')

if not all([DATABASE_URL, API_KEY, JWT_SECRET]):
    raise ValueError("Missing required environment variables")

# Use secrets management service
from azure.keyvault.secrets import SecretClient
from azure.identity import DefaultAzureCredential

credential = DefaultAzureCredential()
client = SecretClient(vault_url="https://myvault.vault.azure.net/", credential=credential)

DATABASE_URL = client.get_secret("database-url").value
API_KEY = client.get_secret("api-key").value

# Or AWS Secrets Manager, HashiCorp Vault, etc.
```

---

## üí° Security Best Practices

| Practice | Description | Benefit |
|----------|-------------|---------|
| **Hash passwords** | bcrypt/Argon2, never plain text | Protect user accounts |
| **Use HTTPS everywhere** | TLS 1.3 for all connections | Prevent MITM attacks |
| **Implement MFA** | TOTP, SMS, hardware keys | Extra security layer |
| **Rate limit auth endpoints** | Prevent brute force | Stop credential attacks |
| **Validate server-side** | Never trust client input | Prevent injection attacks |
| **Use parameterized queries** | Prevent SQL injection | Database security |
| **Implement RBAC** | Role-based access control | Proper authorization |
| **Rotate secrets regularly** | API keys, certificates | Limit breach impact |
| **Log security events** | Failed logins, permission changes | Audit and detection |
| **Keep dependencies updated** | Patch security vulnerabilities | Reduce attack surface |

---

## ‚úèÔ∏è Design Challenge

### Problem

You are designing an $\text{API}$ for a financial application. Explain why you would choose JWTs over traditional
server-side $\text{Sessions}$ for authentication at the $\text{API}$ $\text{Gateway}$, and describe the critical
drawback of $\text{JWTs}$ you must solve using a refresh token mechanism.

### Solution

#### üß© Scenario Summary

| Aspect                   | Requirement                                     |
|--------------------------|-------------------------------------------------|
| **System type**          | Financial API (requires security + scalability) |
| **Traffic nature**       | Distributed, stateless microservices            |
| **Authentication layer** | API Gateway (edge of system)                    |

#### ‚úÖ Why Choose JWTs Over Server-Side Sessions

**1. Stateless Authentication (Scalable Across Microservices)**

- JWTs are self-contained tokens ‚Äî they carry user identity, roles, and claims inside the token itself.
- The API Gateway can verify tokens locally (using a public key) without calling a session store or central DB.
- Ideal for microservice or multi-region deployments where session replication is expensive.

> **‚úÖ Benefit:** No dependency on a shared session cache (like Redis) ‚Üí improves scalability and reduces latency.

**2. Decoupled and Cross-Service Usability**

- Each microservice can independently validate JWTs ‚Äî no centralized session validation call.
- Works well with API Gateways, service meshes, and federated identity systems (like OAuth2 / OpenID Connect).

> **‚úÖ Benefit**: Clean separation between authentication and business logic.

**3. Improved Caching and Performance**

- Since JWTs are stateless, they can be cached at the edge (e.g., CDN or Gateway).
- Reduces authentication round-trips and load on authentication servers.

#### ‚ö†Ô∏è The Critical Drawback of JWTs

**‚ùå Non-Revocability Problem**

- Once a JWT is issued, it remains valid until expiry ‚Äî even if:
    - A user logs out,
    - Credentials are compromised, or
    - The user‚Äôs access rights change.

Because JWTs are not stored on the server, there‚Äôs no centralized way to ‚Äúinvalidate‚Äù them mid-lifecycle.

> ‚ö†Ô∏è Risk: If a token is stolen, an attacker can use it until it expires.

#### ‚úÖ Solution ‚Äî Use a Refresh Token Mechanism

How It Works

1. **Short-lived Access Token (JWT)** ‚Äî expires quickly (e.g., 5‚Äì15 minutes).
2. **Long-lived Refresh Token** ‚Äî securely stored and used to request new access tokens.
3. When access token expires, client sends the refresh token to the auth server for a new JWT.
4. The server can revoke refresh tokens in its database, effectively invalidating future access tokens.

> üí° Refresh tokens reintroduce controlled state ‚Äî allowing revocation while keeping access tokens stateless.

#### ‚öñÔ∏è Trade-offs

| Mechanism               | Pros                                       | Cons                                        |
|-------------------------|--------------------------------------------|---------------------------------------------|
| **JWT (Stateless)**     | Fast, scalable, works across microservices | Hard to revoke, larger payloads             |
| **Sessions (Stateful)** | Easy to revoke or expire centrally         | Harder to scale across distributed services |

#### ‚úÖ Final Summary

| Aspect            | Design Decision                           | Reason                                        |
|-------------------|-------------------------------------------|-----------------------------------------------|
| **Auth Type**     | **JWT-based (stateless)**                 | Scalable, independent verification at gateway |
| **Critical Risk** | Tokens can‚Äôt be revoked immediately       | JWTs are self-contained, no central state     |
| **Mitigation**    | **Use short-lived JWTs + refresh tokens** | Enables revocation & reissue flow securely    |
