# 2.1.14 Neo4j Deep Dive: The Graph Database

## Intuitive Explanation

Neo4j is a **native graph database** that stores data as **nodes** (entities) and **relationships** (connections between entities). Unlike relational databases that use tables and joins, Neo4j stores relationships as first-class citizens, making it extremely efficient for traversing connected data. Think of it as modeling data the way your brain naturally thinks: as a network of interconnected things.

- **Nodes:** Entities (users, products, locations)
- **Relationships:** Connections between nodes (FOLLOWS, PURCHASED, LOCATED_IN)
- **Properties:** Attributes on nodes and relationships (name, age, since_date)
- **Use Cases:** Social networks, fraud detection, recommendation engines, knowledge graphs

**The Power:** In SQL, finding "friends of friends" requires multiple self-joins (slow). In Neo4j, it's a simple graph traversal ($\text{O}(hops)$ vs. $\text{O}(n^2)$).

---

## In-Depth Analysis

### 1. Graph Model: Nodes, Relationships, Properties

**Graph Structure:**

```
┌─────────────────────────────────────────────────┐
│              Graph Database Model                │
├─────────────────────────────────────────────────┤
│                                                  │
│  (Alice) ─[FOLLOWS]→ (Bob)                      │
│     │                   │                        │
│     │                   │                        │
│  [LIKES]            [POSTED]                     │
│     │                   │                        │
│     ▼                   ▼                        │
│  (Photo)            (Tweet)                      │
│                                                  │
│  Nodes: Entities (Alice, Bob, Photo, Tweet)     │
│  Relationships: Connections (FOLLOWS, LIKES)    │
│  Properties: Attributes (name, created_at)      │
└─────────────────────────────────────────────────┘
```

**Example in Cypher (Neo4j Query Language):**

```cypher
// Create nodes
CREATE (alice:Person {name: 'Alice', age: 30})
CREATE (bob:Person {name: 'Bob', age: 25})
CREATE (tweet:Tweet {content: 'Hello World', created_at: datetime()})

// Create relationships
CREATE (alice)-[:FOLLOWS {since: date('2024-01-01')}]->(bob)
CREATE (bob)-[:POSTED]->(tweet)
CREATE (alice)-[:LIKES]->(tweet)

// Return the graph
RETURN alice, bob, tweet
```

**Key Concepts:**

| Concept | SQL Equivalent | Neo4j Representation |
|---------|----------------|----------------------|
| **Node** | Row | `(n:Person {name: 'Alice'})` |
| **Relationship** | Foreign key + JOIN | `(alice)-[:FOLLOWS]->(bob)` |
| **Label** | Table name | `:Person`, `:Tweet` |
| **Property** | Column | `{name: 'Alice', age: 30}` |
| **Traversal** | JOIN | `MATCH (a)-[:FOLLOWS]->(b)` |

---

### 2. Cypher Query Language

Cypher is Neo4j's declarative query language (similar to SQL but for graphs):

#### **2.1 Basic Queries**

**Find all people:**

```cypher
MATCH (p:Person)
RETURN p.name, p.age
```

**Find who Alice follows:**

```cypher
MATCH (alice:Person {name: 'Alice'})-[:FOLLOWS]->(friend)
RETURN friend.name
```

**Find friends of friends (2 hops):**

```cypher
MATCH (alice:Person {name: 'Alice'})-[:FOLLOWS]->()-[:FOLLOWS]->(fof)
RETURN DISTINCT fof.name
```

**Shortest path between two people:**

```cypher
MATCH path = shortestPath(
  (alice:Person {name: 'Alice'})-[:FOLLOWS*]-(bob:Person {name: 'Bob'})
)
RETURN path
```

#### **2.2 Advanced Queries**

**Recommendation: People you may know (mutual friends):**

```cypher
MATCH (me:Person {name: 'Alice'})-[:FOLLOWS]->(friend)-[:FOLLOWS]->(recommendation)
WHERE NOT (me)-[:FOLLOWS]->(recommendation) AND me <> recommendation
RETURN recommendation.name, COUNT(friend) AS mutual_friends
ORDER BY mutual_friends DESC
LIMIT 10
```

**Find influencers (most followed):**

```cypher
MATCH (p:Person)<-[:FOLLOWS]-(follower)
RETURN p.name, COUNT(follower) AS follower_count
ORDER BY follower_count DESC
LIMIT 10
```

**Detect fraud: Find users with suspicious patterns:**

```cypher
// Find users who share the same email AND phone AND address (fraud indicator)
MATCH (u1:User)-[:HAS_EMAIL]->(e:Email)<-[:HAS_EMAIL]-(u2:User),
      (u1)-[:HAS_PHONE]->(ph:Phone)<-[:HAS_PHONE]-(u2),
      (u1)-[:HAS_ADDRESS]->(a:Address)<-[:HAS_ADDRESS]-(u2)
WHERE u1 <> u2
RETURN u1.name, u2.name, e.email, ph.number, a.street
```

---

### 3. Indexing and Performance

#### **3.1 Indexes**

**Create index on node property:**

```cypher
CREATE INDEX user_email FOR (u:User) ON (u.email)
CREATE INDEX person_name FOR (p:Person) ON (p.name)
```

**Composite index (Neo4j 4.0+):**

```cypher
CREATE INDEX user_name_age FOR (u:User) ON (u.name, u.age)
```

**Full-text search index:**

```cypher
CALL db.index.fulltext.createNodeIndex("userNameIndex", ["User"], ["name", "bio"])

// Search
CALL db.index.fulltext.queryNodes("userNameIndex", "alice software") YIELD node, score
RETURN node.name, score
```

#### **3.2 Query Optimization**

**Explain Plan:**

```cypher
EXPLAIN
MATCH (alice:Person {name: 'Alice'})-[:FOLLOWS]->(friend)
RETURN friend.name
```

**Profile Query:**

```cypher
PROFILE
MATCH (alice:Person {name: 'Alice'})-[:FOLLOWS*1..3]->(connection)
RETURN connection.name
```

**Best Practices:**

- ✅ **Start with specific nodes:** Use indexed properties (e.g., `WHERE id = 123`)
- ✅ **Limit traversal depth:** Use bounded paths (e.g., `[:FOLLOWS*1..3]`)
- ✅ **Use `LIMIT`:** Avoid returning millions of results
- ❌ **Avoid unbounded paths:** `[:FOLLOWS*]` without limit can explode

---

### 4. Data Modeling Patterns

#### **4.1 Social Network**

```cypher
// Users
CREATE (alice:User {id: 1, name: 'Alice', email: 'alice@example.com'})
CREATE (bob:User {id: 2, name: 'Bob', email: 'bob@example.com'})

// Friendships (bidirectional)
CREATE (alice)-[:FRIENDS_WITH {since: date('2020-01-01')}]->(bob)
CREATE (bob)-[:FRIENDS_WITH {since: date('2020-01-01')}]->(alice)

// Posts
CREATE (post:Post {id: 101, content: 'Hello World', created_at: datetime()})
CREATE (alice)-[:POSTED]->(post)

// Likes
CREATE (bob)-[:LIKES {liked_at: datetime()}]->(post)

// Comments
CREATE (comment:Comment {content: 'Great post!'})
CREATE (bob)-[:COMMENTED]->(comment)
CREATE (comment)-[:ON]->(post)
```

#### **4.2 E-commerce Recommendation**

```cypher
// Products
CREATE (laptop:Product {id: 1, name: 'Laptop', category: 'Electronics'})
CREATE (mouse:Product {id: 2, name: 'Mouse', category: 'Accessories'})

// Users and purchases
CREATE (alice:User {name: 'Alice'})
CREATE (alice)-[:PURCHASED {date: date('2024-01-15')}]->(laptop)
CREATE (alice)-[:PURCHASED]->(mouse)

// Recommendation query: "Customers who bought X also bought Y"
MATCH (u:User)-[:PURCHASED]->(p1:Product {name: 'Laptop'}),
      (u)-[:PURCHASED]->(p2:Product)
WHERE p1 <> p2
RETURN p2.name, COUNT(u) AS co_purchased_count
ORDER BY co_purchased_count DESC
LIMIT 5
```

#### **4.3 Fraud Detection**

```cypher
// Model shared entities
CREATE (u1:User {name: 'User1'})
CREATE (u2:User {name: 'User2'})
CREATE (email:Email {address: 'shared@example.com'})
CREATE (phone:Phone {number: '555-1234'})
CREATE (card:CreditCard {last4: '1234'})

CREATE (u1)-[:HAS_EMAIL]->(email)
CREATE (u2)-[:HAS_EMAIL]->(email)
CREATE (u1)-[:HAS_PHONE]->(phone)
CREATE (u2)-[:HAS_PHONE]->(phone)
CREATE (u1)-[:HAS_CARD]->(card)
CREATE (u2)-[:HAS_CARD]->(card)

// Fraud detection: Find users sharing 3+ identifiers
MATCH (u1:User)-[:HAS_EMAIL|HAS_PHONE|HAS_CARD]->(shared)<-[:HAS_EMAIL|HAS_PHONE|HAS_CARD]-(u2:User)
WHERE u1 <> u2
WITH u1, u2, COUNT(shared) AS shared_count
WHERE shared_count >= 3
RETURN u1.name, u2.name, shared_count
```

---

### 5. Scaling and Performance

#### **5.1 Neo4j Architecture**

```
┌────────────────────────────────────────────┐
│         Neo4j Cluster (Causal Cluster)     │
├────────────────────────────────────────────┤
│  ┌──────────────┐                          │
│  │   Core 1     │  (Leader - handles writes)│
│  └──────┬───────┘                          │
│         │ Raft consensus                    │
│  ┌──────▼───────┐  ┌──────────────┐       │
│  │   Core 2     │  │   Core 3     │       │
│  └──────────────┘  └──────────────┘       │
│         │                  │               │
│         ▼                  ▼               │
│  ┌──────────────┐  ┌──────────────┐       │
│  │  Read Replica│  │  Read Replica│       │
│  │  (Read-only) │  │  (Read-only) │       │
│  └──────────────┘  └──────────────┘       │
└────────────────────────────────────────────┘
```

**Causal Cluster:**

- **Core servers (3-5):** Use Raft consensus for writes (similar to Paxos)
- **Read replicas (N):** Async replication for read scaling
- **Consistency:** Causal consistency (reads see previous writes)

#### **5.2 Sharding (Neo4j Fabric)**

**Neo4j Fabric** allows querying across multiple sharded databases:

```cypher
// Query across shards
USE fabric.graphA, fabric.graphB
MATCH (u:User {name: 'Alice'})
RETURN u
```

**Sharding Strategy:**

- Shard by **tenant_id** (multi-tenant applications)
- Shard by **region** (geographic distribution)
- Shard by **time period** (historical data)

---

### 6. Graph Algorithms (Neo4j Graph Data Science)

Neo4j includes a library of graph algorithms:

#### **6.1 Centrality Algorithms**

**PageRank (Find influential nodes):**

```cypher
CALL gds.pageRank.stream('myGraph')
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).name AS name, score
ORDER BY score DESC
LIMIT 10
```

**Betweenness Centrality (Find bridges):**

```cypher
CALL gds.betweenness.stream('myGraph')
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).name AS name, score
ORDER BY score DESC
```

#### **6.2 Community Detection**

**Louvain (Find communities/clusters):**

```cypher
CALL gds.louvain.stream('myGraph')
YIELD nodeId, communityId
RETURN communityId, COUNT(nodeId) AS community_size
ORDER BY community_size DESC
```

#### **6.3 Pathfinding**

**Shortest Path:**

```cypher
MATCH (start:Person {name: 'Alice'}), (end:Person {name: 'Bob'})
CALL gds.shortestPath.dijkstra.stream('myGraph', {
    sourceNode: start,
    targetNode: end
})
YIELD path
RETURN path
```

---

### 7. When to Use Neo4j

#### **✅ Use Neo4j When:**

1. **Highly connected data** — Social networks, fraud detection, knowledge graphs
2. **Relationship queries** — "Friends of friends", "Shortest path", "Influence analysis"
3. **Recommendations** — Collaborative filtering, "Users who bought X also bought Y"
4. **Fraud detection** — Identifying patterns across shared entities
5. **Knowledge graphs** — Semantic networks, ontologies
6. **Network analysis** — Supply chain, transportation networks
7. **Access control** — Complex permission hierarchies

#### **❌ Don't Use Neo4j When:**

1. **Simple CRUD operations** — PostgreSQL is simpler and faster
2. **Transactional workloads** — High-volume writes (use PostgreSQL/MySQL)
3. **Large blobs/documents** — Use document store (MongoDB) or object storage (S3)
4. **Time-series data** — Use TimescaleDB or ClickHouse
5. **Full-text search** — Use Elasticsearch
6. **Analytical queries (OLAP)** — Use data warehouse (Redshift, BigQuery)

---

### 8. Real-World Examples

| Company | Use Case | Why Neo4j? |
|---------|----------|------------|
| **LinkedIn** | "People You May Know" | Graph traversal for mutual connections |
| **eBay** | Fraud detection | Pattern matching across shared entities |
| **Walmart** | Product recommendations | Collaborative filtering based on purchase graphs |
| **NASA** | Knowledge graphs | Complex relationships in scientific data |
| **Cisco** | Network topology | Model network devices and connections |
| **UBS** | Risk analysis | Financial network analysis |

---

### 9. Neo4j vs. Other Databases

| Feature | Neo4j | PostgreSQL | MongoDB |
|---------|-------|------------|---------|
| **Data model** | Graph (nodes, relationships) | Relational (tables) | Document (JSON) |
| **Traversal performance** | ✅ Excellent ($\text{O}(hops)$) | ❌ Slow (multiple JOINs) | ❌ Not optimized |
| **Relationship queries** | ✅ Native | ⚠️ Requires JOINs | ❌ Requires aggregation |
| **ACID** | ✅ Yes | ✅ Yes | ✅ Yes (4.0+) |
| **Scalability** | Horizontal (with Fabric) | Vertical (limited horizontal) | Horizontal |
| **Use case** | Highly connected data | General purpose | Flexible documents |

---

### 10. Common Anti-Patterns

#### ❌ **1. Modeling Everything as a Graph**

**Problem:** Using Neo4j for simple lookups.

```cypher
// Bad: Simple key-value lookup (use Redis instead)
MATCH (u:User {id: 123})
RETURN u
```

**Solution:** Use PostgreSQL for simple CRUD, Neo4j for relationship queries.

#### ❌ **2. Unbounded Traversals**

**Problem:** Traversing entire graph without limits.

```cypher
// Bad: Could traverse millions of nodes
MATCH (alice:Person {name: 'Alice'})-[:FOLLOWS*]->(connection)
RETURN connection
```

**Solution:** Limit depth.

```cypher
// Good: Bounded traversal
MATCH (alice:Person {name: 'Alice'})-[:FOLLOWS*1..3]->(connection)
RETURN connection
LIMIT 100
```

#### ❌ **3. Using Relationships as Nodes**

**Problem:** Modeling "likes" as nodes instead of relationships.

```cypher
// Bad
CREATE (alice)-[:HAS_LIKE]->(like:Like)-[:ON]->(post)

// Good
CREATE (alice)-[:LIKES {liked_at: datetime()}]->(post)
```

---

### 11. Trade-offs Summary

| What You Gain | What You Sacrifice |
|---------------|-------------------|
| ✅ Fast relationship traversal ($\text{O}(hops)$) | ❌ Higher operational complexity (vs. PostgreSQL) |
| ✅ Intuitive data modeling (matches real-world) | ❌ Smaller ecosystem (fewer tools than SQL) |
| ✅ Powerful graph algorithms (PageRank, community detection) | ❌ Not suitable for simple CRUD (overkill) |
| ✅ Flexible schema (like NoSQL) | ❌ Vertical scaling limits (single machine) |
| ✅ ACID transactions | ❌ Sharding complexity (Fabric required) |

---

### 12. References

- **Neo4j Documentation:** [https://neo4j.com/docs/](https://neo4j.com/docs/)
- **Cypher Query Language:** [https://neo4j.com/developer/cypher/](https://neo4j.com/developer/cypher/)
- **Graph Data Science Library:** [https://neo4j.com/product/graph-data-science/](https://neo4j.com/product/graph-data-science/)
- **Neo4j University (Free Courses):** [https://graphacademy.neo4j.com/](https://graphacademy.neo4j.com/)
- **Related Chapters:**
  - [2.1.3 Specialized Databases](./2.1.3-specialized-databases.md) — Graph databases overview
  - [2.1.7 PostgreSQL Deep Dive](./2.1.7-postgresql-deep-dive.md) — When to use relational vs. graph
  - [2.1.10 MongoDB Deep Dive](./2.1.10-mongodb-deep-dive.md) — Document vs. graph modeling

---

## ✏️ Design Challenge

### Problem

You're designing **LinkedIn's "People You May Know" feature** that suggests connections based on mutual friends, shared companies, and common skills. Requirements:

1. **Recommendation algorithm:** Find users with the most mutual connections (not already connected)
2. **Filtering:** Weight recommendations by shared companies, schools, and skills
3. **Performance:** Generate recommendations in <100ms for a user with 1,000 connections
4. **Scale:** 1 billion users, 500M connections
5. **Real-time updates:** New connections should influence recommendations immediately

**Question:** How would you design the data model in Neo4j? What Cypher queries would you use? How would you handle performance for users with 10,000+ connections (celebrities/influencers)?

### Solution

#### 🧩 Scenario

- **System:** LinkedIn "People You May Know"
- **Scale:** 1B users, 500M connections (avg 500 connections/user)
- **Query:** Find top 10 recommendations for a user
- **Latency requirement:** <100ms
- **Celebrity problem:** Some users have 50K+ connections

#### ✅ Goal

- Find users with most mutual connections (not already connected)
- Weight by shared attributes (company, school, skills)
- Handle high-degree nodes (celebrities)
- Real-time updates
- Sub-100ms query performance

#### ⚙️ Solution: Neo4j with Degree Pruning + Caching

**Data Model:**

```cypher
// Users
CREATE (alice:User {
  id: 'user123',
  name: 'Alice',
  title: 'Software Engineer',
  location: 'San Francisco'
})

// Connections (bidirectional relationships)
CREATE (alice)-[:CONNECTED_TO {since: date('2020-01-01')}]->(bob)
CREATE (bob)-[:CONNECTED_TO {since: date('2020-01-01')}]->(alice)

// Shared attributes
CREATE (company:Company {name: 'Google'})
CREATE (school:University {name: 'Stanford'})
CREATE (skill:Skill {name: 'Python'})

CREATE (alice)-[:WORKS_AT]->(company)
CREATE (alice)-[:STUDIED_AT]->(school)
CREATE (alice)-[:HAS_SKILL]->(skill)
```

**Recommendation Query (Basic):**

```cypher
// Find users with mutual connections
MATCH (me:User {id: 'user123'})-[:CONNECTED_TO]->(friend)-[:CONNECTED_TO]->(recommendation)
WHERE NOT (me)-[:CONNECTED_TO]->(recommendation)
  AND me <> recommendation
RETURN 
  recommendation.id,
  recommendation.name,
  COUNT(DISTINCT friend) AS mutual_friends
ORDER BY mutual_friends DESC
LIMIT 10
```

**Advanced Recommendation (With Weighting):**

```cypher
MATCH (me:User {id: 'user123'})

// Mutual connections (weight: 3)
OPTIONAL MATCH (me)-[:CONNECTED_TO]->(friend)-[:CONNECTED_TO]->(rec)
WHERE NOT (me)-[:CONNECTED_TO]->(rec) AND me <> rec
WITH me, rec, COUNT(DISTINCT friend) * 3 AS connection_score

// Shared company (weight: 2)
OPTIONAL MATCH (me)-[:WORKS_AT]->(company)<-[:WORKS_AT]-(rec)
WITH me, rec, connection_score, COUNT(DISTINCT company) * 2 AS company_score

// Shared school (weight: 2)
OPTIONAL MATCH (me)-[:STUDIED_AT]->(school)<-[:STUDIED_AT]-(rec)
WITH me, rec, connection_score, company_score, COUNT(DISTINCT school) * 2 AS school_score

// Shared skills (weight: 1)
OPTIONAL MATCH (me)-[:HAS_SKILL]->(skill)<-[:HAS_SKILL]-(rec)
WITH me, rec, connection_score, company_score, school_score, COUNT(DISTINCT skill) AS skill_score

// Calculate total score
WITH 
  rec,
  connection_score + company_score + school_score + skill_score AS total_score
WHERE total_score > 0
RETURN 
  rec.id,
  rec.name,
  total_score
ORDER BY total_score DESC
LIMIT 10
```

#### ⚠️ Handling High-Degree Nodes (Celebrity Problem)

**Problem:** User with 50K connections causes query to explore millions of nodes.

**Solution 1: Degree Pruning**

```cypher
// Skip users with >10K connections (celebrities)
MATCH (me:User {id: 'user123'})-[:CONNECTED_TO]->(friend)-[:CONNECTED_TO]->(rec)
WHERE NOT (me)-[:CONNECTED_TO]->(rec)
  AND me <> rec
  AND size((friend)-[:CONNECTED_TO]->()) < 10000  // Prune high-degree nodes
WITH rec, COUNT(DISTINCT friend) AS mutual_friends
WHERE mutual_friends >= 2  // Require at least 2 mutual friends
RETURN rec.id, rec.name, mutual_friends
ORDER BY mutual_friends DESC
LIMIT 10
```

**Solution 2: Bounded Depth**

```cypher
// Limit traversal to specific connection count
MATCH (me:User {id: 'user123'})-[:CONNECTED_TO]->(friend)
WITH me, friend
ORDER BY friend.connection_count ASC  // Prioritize low-degree friends
LIMIT 100  // Sample only 100 friends

MATCH (friend)-[:CONNECTED_TO]->(rec)
WHERE NOT (me)-[:CONNECTED_TO]->(rec) AND me <> rec
RETURN rec.id, rec.name, COUNT(friend) AS mutual_friends
ORDER BY mutual_friends DESC
LIMIT 10
```

**Solution 3: Pre-Computed Recommendations (Batch Job)**

```cypher
// Nightly batch job: Pre-compute recommendations
MATCH (user:User)
CALL {
  WITH user
  MATCH (user)-[:CONNECTED_TO]->(friend)-[:CONNECTED_TO]->(rec)
  WHERE NOT (user)-[:CONNECTED_TO]->(rec) AND user <> rec
  RETURN rec, COUNT(friend) AS score
  ORDER BY score DESC
  LIMIT 20
}
CREATE (user)-[:RECOMMENDATION {score: score, computed_at: datetime()}]->(rec)
```

**Query pre-computed recommendations:**

```cypher
MATCH (me:User {id: 'user123'})-[r:RECOMMENDATION]->(rec)
RETURN rec.id, rec.name, r.score
ORDER BY r.score DESC
LIMIT 10
```

#### 🧠 Hybrid Approach (Recommended)

**Architecture:**

```
┌──────────────────────────────────────────┐
│    Recommendation Strategy               │
├──────────────────────────────────────────┤
│  Real-time (for users with <1K connects) │
│    - Direct Cypher query                 │
│    - Latency: 50-100ms                   │
│                                           │
│  Pre-computed (for users with >1K)       │
│    - Nightly batch job                   │
│    - Store in Neo4j as RECOMMENDATION    │
│    - Latency: <10ms (simple lookup)      │
│                                           │
│  Cache (Redis)                            │
│    - Cache top 20 recommendations        │
│    - TTL: 1 hour                         │
│    - Latency: <1ms                       │
└──────────────────────────────────────────┘
```

**Application Logic:**

```python
def get_recommendations(user_id):
    # 1. Check Redis cache
    cached = redis.get(f"recommendations:{user_id}")
    if cached:
        return json.loads(cached)
    
    # 2. Check user connection count
    connection_count = neo4j.run("""
        MATCH (u:User {id: $user_id})-[:CONNECTED_TO]->()
        RETURN COUNT(*) AS count
    """, user_id=user_id).single()['count']
    
    if connection_count < 1000:
        # 3a. Real-time query (fast for small networks)
        results = neo4j.run("""
            MATCH (me:User {id: $user_id})-[:CONNECTED_TO]->(friend)-[:CONNECTED_TO]->(rec)
            WHERE NOT (me)-[:CONNECTED_TO]->(rec) AND me <> rec
            RETURN rec.id, rec.name, COUNT(friend) AS mutual
            ORDER BY mutual DESC
            LIMIT 10
        """, user_id=user_id)
    else:
        # 3b. Pre-computed recommendations
        results = neo4j.run("""
            MATCH (me:User {id: $user_id})-[r:RECOMMENDATION]->(rec)
            RETURN rec.id, rec.name, r.score
            ORDER BY r.score DESC
            LIMIT 10
        """, user_id=user_id)
    
    # 4. Cache in Redis (1 hour TTL)
    recommendations = [dict(r) for r in results]
    redis.setex(f"recommendations:{user_id}", 3600, json.dumps(recommendations))
    
    return recommendations
```

#### ✅ Final Answer

| Aspect | Decision | Reason |
|--------|----------|--------|
| **Database** | **Neo4j** | Native graph traversal, perfect for "friends of friends" |
| **Query Strategy** | Hybrid (real-time + pre-computed) | Balance latency and accuracy |
| **Real-time** | Users with <1K connections | Fast enough (<100ms) |
| **Pre-computed** | Users with >1K connections (celebrities) | Avoid query timeouts |
| **Degree Pruning** | Skip friends with >10K connections | Prevent celebrity explosion |
| **Caching** | Redis (1 hour TTL) | Sub-millisecond lookup |
| **Weighting** | Mutual friends (3x) > Company (2x) > School (2x) > Skills (1x) | Prioritize strongest signals |
| **Trade-off** | Pre-computed = slightly stale (24h) | Gain: Consistent performance for all users |

**Performance Metrics:**
- **Real-time query:** 50-100ms (users with <1K connections)
- **Pre-computed lookup:** 10-20ms (users with >1K connections)
- **Cached lookup:** <1ms (all users after first query)
- **Storage:** ~500 bytes per recommendation × 20 recs × 1B users = ~10TB

**Key Insights:**
- **Graph databases excel** at traversal (2-3 hops fast)
- **Degree pruning essential** to avoid celebrity problem
- **Hybrid approach** balances real-time and performance
- **Caching critical** for production-level latency

**When to Reconsider:**
- If most users have >10K connections → Move entirely to pre-computed
- If recommendations must be real-time (<1s stale) → Use graph streaming (Neo4j + Kafka)
- If scale exceeds single Neo4j cluster → Shard by region using Neo4j Fabric

