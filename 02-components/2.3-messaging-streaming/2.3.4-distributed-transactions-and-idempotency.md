# 2.3.4 Distributed Transactions and Idempotency

## Intuitive Explanation

When your simple system grows into dozens of microservices, a single action (like placing an order) might require
updating data across multiple databases owned by different services. This is a **distributed transaction**.

- **Problem:** If the Payment Service succeeds but the Inventory Service fails, you've charged the customer but lost the
  inventory record.
- **Goal:** Ensure the outcome is either **all success** or **all failure** across all services (Atomicity), but without
  the crippling performance cost of traditional database locks.

---

## In-Depth Analysis

### 1. Distributed Transaction Patterns

Since traditional $\text{ACID}$ transactions (like $\text{2PC}$) are often too slow and complex for microservices, we
use asynchronous patterns:

#### A. Two-Phase Commit ($\text{2PC}$)

- **Mechanism:** A central **Coordinator** asks all participating databases/services to **Prepare** (Phase 1: ensuring
  they can
  commit the change). If all services respond positively, the Coordinator sends the Commit command (Phase 2: making the
  change permanent). If any service fails to prepare, all services are told to $\text{Abort}$.
- **Trade-off: High Consistency**. However, it is slow, creates
  a $\text{Single}$ $\text{Point}$ $\text{of}$ $\text{Failure}$ ($\text{SPOF}$‚Äîthe Coordinator), and holds locks for a
  long time, killing throughput. **Rarely used in modern $\text{HLD}$ for high-traffic paths.**

#### B. The Saga Pattern

- Mechanism: A sequence of local, $\text{ACID}$ transactions within each service. If one local transaction fails, the
  Saga executes **Compensation Transactions** to undo the work of all previous successful transactions.
- **Trade-off: High Availability/Speed.** Requires complex rollback logic and management, leading to **Eventual
  Consistency.**

### 2. Idempotency: Solving the Retry Problem

Idempotency is the property of an operation that ensures executing it multiple times has the same effect as executing it
once. This is critical in distributed systems because network requests often fail, and the client or the service mesh
will **retry** the request.

- **Non-Idempotent (Bad):** A simple `POST /create_order` API. If retried, it creates a duplicate order.
- **Idempotent (Good):** A `POST /create_order` that includes a unique Idempotency Key ($\text{UUID}$ or hash) in the
  header.

### Idempotency Implementation Flow

1. **Client:** Generates a unique `Idempotency-Key: <unique_hash>` for the request.
2. **Service:** Before processing the request, checks a fast Key-Value store (like **Redis**) to see if the key already
   exists.
3. **If Key Exists:** The request is a retry. The service immediately returns the original successful result (or a '409
   Conflict' error) without processing the transaction again.
4. **If Key Does Not Exist**: The key is stored in $\text{Redis}$ (often with a TTL), the transaction is processed, and
   the result is returned.

### Key Concepts / Tradeoffs

| Concept      | Rationale                                                                               | Trade-off / Scalability Issue                                                                                                                                            |
|--------------|-----------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Saga Pattern | Provides eventual consistency and high throughput by avoiding global locks.             | High complexity; requires writing detailed compensation logic, which is hard to test and debug.                                                                          |
| Idempotency  | Prevents duplicate charges, orders, or data when network failures force client retries. | Requires a fast, dedicated storage layer ($\text{Redis}$) to store and check millions of temporary $\text{Idempotency}$ $\text{Keys}$, adding state management overhead. |

---

## ‚úèÔ∏è Design Challenge

### Problem

You are designing the final $\text{API}$ endpoint for submitting a payment to a third-party gateway. The client is known
to sometimes retry a payment request three times if the network is flaky. How would you ensure the customer is charged
exactly once, and what piece of infrastructure is essential for this solution?

### Solution

#### üß© Scenario Summary

| Aspect                  | Description                                                            |
|-------------------------|------------------------------------------------------------------------|
| **API**                 | `/payments/submit`                                                     |
| **Client behavior**     | May retry request 3 times on network timeout                           |
| **Requirement**         | Customer should not be charged multiple times                          |
| **Third-party gateway** | May not be idempotent by default                                       |
| **Goal**                | Make API **idempotent** so duplicate requests produce the same outcome |

#### ‚úÖ Step 1: Understand the Core Problem

When clients retry API calls, the server might:

- Process the same payment multiple times, leading to duplicate charges, or
- Create multiple transaction records, even though only one was intended.

The fix is **idempotency** ‚Äî identical requests should produce the same result without repeating the underlying
side-effect (charging).

#### ‚úÖ Step 2: Introduce an Idempotency Key

Each payment submission request must include a **unique client-generated identifier**, called an **Idempotency Key**.

#### ‚úÖ Step 3: Server-side Logic

When the request hits your API:

1. Check if the **Idempotency Key** exists in your **Idempotency Store** (a durable cache or database).
    - If yes ‚Üí return the previously stored result (no new charge).
    - If no ‚Üí proceed to charge and store the result under that key.

This guarantees that only the first attempt actually triggers the payment gateway, and all subsequent retries reuse the
same result.

#### ‚úÖ Step 4: The Essential Infrastructure Component

> üß± Idempotency Store (Persistent Key-Value Store)

This store tracks processed idempotency keys and their associated outcomes.

| Option                             | Use Case                                           |
|------------------------------------|----------------------------------------------------|
| **Redis**                          | Low-latency caching, time-limited idempotency keys |
| **RDBMS / DynamoDB**               | Persistent storage for guaranteed durability       |
| **Payment Gateway (Stripe-style)** | Some gateways support built-in idempotency         |

#### ‚úÖ Step 5: Why This Works

- **Retry-safe**: Multiple identical requests map to the same key ‚Üí same result.
- **Exactly-once semantics**: Payment is executed at most once.
- **Stateless clients**: The client doesn‚Äôt need to remember if a previous request succeeded.

#### ‚öôÔ∏è Step 6: Failure & Edge Cases

| Case                                                    | Behavior                                                        |
|---------------------------------------------------------|-----------------------------------------------------------------|
| **Client retries with same key**                        | Returns cached response ‚Üí ‚úÖ safe                                |
| **Client retries with new key**                         | Treated as new request ‚Üí üö® possible double charge (client bug) |
| **Server crash after charge but before storing result** | Use atomic DB transaction or idempotent gateway integration     |
| **TTL Expiry**                                          | Typically set to 24‚Äì48h (long enough for retries)               |

#### ‚úÖ Final Summary

| Aspect                  | Design Decision                                     | Reason                                    |
|-------------------------|-----------------------------------------------------|-------------------------------------------|
| **Retry safety**        | Idempotency key required per request                | Ensures single charge                     |
| **Core infrastructure** | **Persistent Idempotency Store (e.g., Redis / DB)** | Tracks processed keys & results           |
| **Client role**         | Generate and reuse same key on retry                | Enables deduplication                     |
| **Server behavior**     | Return cached response for duplicate keys           | Prevents duplicate payments               |
| **Trade-off**           | Slight storage overhead                             | Critical for correctness in payment flows |
