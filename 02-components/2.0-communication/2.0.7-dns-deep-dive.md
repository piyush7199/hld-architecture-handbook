# 2.0.7 DNS Deep Dive: The Internet's Phone Book

## Intuitive Explanation

Imagine you want to call a friend, but you only know their name, not their phone number. You'd look them up in a phone
book. **DNS (Domain Name System)** is the Internet's phone book‚Äîit translates human-readable domain names (like
`google.com`) into IP addresses (like `142.250.191.14`) that computers use to connect.

**In distributed systems:**

- **DNS:** Hierarchical, distributed naming system
- **Goal:** Translate domain names to IP addresses
- **Benefit:** Humans use names, computers use IPs‚ÄîDNS bridges the gap
- **Additional Features:** Load balancing, failover, geographic routing

---

## In-Depth Analysis

### 1. What is DNS?

**DNS (Domain Name System)** is a hierarchical, distributed naming system for computers, services, or resources
connected to the Internet.

**Key Functions:**

- **Name Resolution:** Translate domain names to IP addresses
- **Service Discovery:** Find services by name (SRV records)
- **Load Balancing:** Distribute traffic across multiple IPs
- **Failover:** Route traffic to backup servers
- **Geographic Routing:** Route users to nearest data center

**Domain Hierarchy:**

```
. (root)
‚îú‚îÄ‚îÄ com
‚îÇ   ‚îú‚îÄ‚îÄ google
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ www ‚Üí 142.250.191.14
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ mail ‚Üí 142.250.191.15
‚îÇ   ‚îî‚îÄ‚îÄ example
‚îî‚îÄ‚îÄ org
    ‚îî‚îÄ‚îÄ wikipedia
```

### 2. DNS Record Types

#### A. A Record (Address Record)

**Purpose:** Maps domain name to IPv4 address

**Example:**

```
www.example.com.  IN  A  192.0.2.1
```

**Use Cases:**

- Website hosting
- API endpoints
- Service endpoints

#### B. AAAA Record (IPv6 Address Record)

**Purpose:** Maps domain name to IPv6 address

**Example:**

```
www.example.com.  IN  AAAA  2001:0db8:85a3::8a2e:0370:7334
```

**Use Cases:**

- IPv6-enabled services
- Modern applications

#### C. CNAME Record (Canonical Name)

**Purpose:** Maps domain name to another domain name (alias)

**Example:**

```
blog.example.com.  IN  CNAME  www.example.com.
```

**Use Cases:**

- Domain aliases
- CDN integration
- Subdomain routing

**Limitations:**

- Can't use CNAME on root domain (use A/AAAA or ALIAS)
- Can't coexist with other record types (except DNSSEC)

#### D. MX Record (Mail Exchange)

**Purpose:** Specifies mail servers for domain

**Example:**

```
example.com.  IN  MX  10  mail1.example.com.
example.com.  IN  MX  20  mail2.example.com.
```

**Priority:**

- Lower number = higher priority
- Multiple MX records for redundancy

#### E. TXT Record (Text Record)

**Purpose:** Stores text data (verification, SPF, DKIM)

**Example:**

```
example.com.  IN  TXT  "v=spf1 include:_spf.google.com ~all"
example.com.  IN  TXT  "google-site-verification=abc123"
```

**Use Cases:**

- Email authentication (SPF, DKIM, DMARC)
- Domain verification
- Service configuration

#### F. SRV Record (Service Record)

**Purpose:** Specifies service location (host, port, priority)

**Example:**

```
_service._tcp.example.com.  IN  SRV  10  5  8080  server1.example.com.
```

**Format:**

```
priority weight port target
```

**Use Cases:**

- Service discovery
- Load balancing
- Microservices

#### G. NS Record (Name Server)

**Purpose:** Specifies authoritative name servers for domain

**Example:**

```
example.com.  IN  NS  ns1.example.com.
example.com.  IN  NS  ns2.example.com.
```

**Use Cases:**

- Domain delegation
- DNS management

#### H. PTR Record (Pointer Record)

**Purpose:** Reverse DNS lookup (IP to domain)

**Example:**

```
1.2.0.192.in-addr.arpa.  IN  PTR  www.example.com.
```

**Use Cases:**

- Email server verification
- Security checks
- Logging

### 3. DNS Resolution Process

#### A. Recursive Resolution

**How It Works:**

```
1. Client ‚Üí Recursive Resolver: "What is www.example.com?"
2. Recursive Resolver ‚Üí Root Server: "Where is .com?"
3. Root Server ‚Üí Recursive Resolver: "Ask .com name servers"
4. Recursive Resolver ‚Üí .com Name Server: "Where is example.com?"
5. .com Name Server ‚Üí Recursive Resolver: "Ask example.com name servers"
6. Recursive Resolver ‚Üí example.com Name Server: "What is www.example.com?"
7. example.com Name Server ‚Üí Recursive Resolver: "192.0.2.1"
8. Recursive Resolver ‚Üí Client: "192.0.2.1"
```

**Components:**

- **Recursive Resolver:** Queries on behalf of client (ISP DNS, Google 8.8.8.8, Cloudflare 1.1.1.1)
- **Root Servers:** 13 root name servers (A-M)
- **TLD Servers:** Top-level domain servers (.com, .org, etc.)
- **Authoritative Name Servers:** Domain's name servers

#### B. Iterative Resolution

**How It Works:**

```
Client queries each server directly:
1. Client ‚Üí Root Server: "Where is .com?"
2. Root Server ‚Üí Client: "Ask .com name servers"
3. Client ‚Üí .com Name Server: "Where is example.com?"
4. .com Name Server ‚Üí Client: "Ask example.com name servers"
5. Client ‚Üí example.com Name Server: "What is www.example.com?"
6. example.com Name Server ‚Üí Client: "192.0.2.1"
```

**Difference:**

- **Recursive:** Resolver does all queries
- **Iterative:** Client does all queries

### 4. DNS Caching

**TTL (Time-To-Live):**

```
TTL: 3600 seconds (1 hour)
‚Üí Record cached for 1 hour
‚Üí After 1 hour, must query again
```

**Caching Layers:**

```
1. Browser Cache: TTL from previous lookup
2. OS Cache: System-level DNS cache
3. Recursive Resolver Cache: ISP/Public DNS cache
4. Authoritative Server: Source of truth
```

**TTL Trade-offs:**

```
Low TTL (60 seconds):
  ‚úÖ Fast updates (failover, load balancing)
  ‚ùå More DNS queries (higher load, cost)

High TTL (86400 seconds = 24 hours):
  ‚úÖ Fewer queries (lower load, cost)
  ‚ùå Slow updates (longer failover time)
```

### 5. DNS Load Balancing

#### A. Round-Robin DNS

**How It Works:**

```
Multiple A records for same domain:
www.example.com.  IN  A  192.0.2.1
www.example.com.  IN  A  192.0.2.2
www.example.com.  IN  A  192.0.2.3

DNS server rotates order:
  Query 1: Returns 192.0.2.1, 192.0.2.2, 192.0.2.3
  Query 2: Returns 192.0.2.2, 192.0.2.3, 192.0.2.1
  Query 3: Returns 192.0.2.3, 192.0.2.1, 192.0.2.2
```

**Limitations:**

- No health checking (returns dead servers)
- Client caching (same IP returned)
- Uneven distribution (some clients cache longer)

#### B. Weighted Round-Robin

**How It Works:**

```
Multiple A records with different priorities:
www.example.com.  IN  A  192.0.2.1  (weight: 3)
www.example.com.  IN  A  192.0.2.2  (weight: 2)
www.example.com.  IN  A  192.0.2.3  (weight: 1)

Distribution: 50% to 192.0.2.1, 33% to 192.0.2.2, 17% to 192.0.2.3
```

### 6. Geographic DNS (GeoDNS)

**How It Works:**

```
DNS server returns different IPs based on client location:

US Client:
  www.example.com ‚Üí 192.0.2.1 (US data center)

EU Client:
  www.example.com ‚Üí 192.0.2.2 (EU data center)

APAC Client:
  www.example.com ‚Üí 192.0.2.3 (APAC data center)
```

**Implementation:**

- **Route 53 (AWS):** Latency-based routing, geolocation routing
- **Cloudflare:** Automatic geographic routing
- **Custom DNS:** EDNS Client Subnet (ECS) extension

**Benefits:**

- Lower latency (nearest data center)
- Better performance
- Compliance (data residency)

### 7. DNS Failover

**How It Works:**

```
Primary Server:
  www.example.com.  IN  A  192.0.2.1  (TTL: 60)

Health Check:
  - DNS provider monitors 192.0.2.1
  - If unhealthy ‚Üí Removes from DNS response

Failover:
  - DNS returns backup server: 192.0.2.2
  - Automatic failover (no manual intervention)
```

**Implementation:**

- **Route 53:** Health checks + failover
- **Cloudflare:** Health monitoring + automatic failover
- **Custom:** DNS-based failover scripts

### 8. DNS Security

#### A. DNSSEC (DNS Security Extensions)

**Purpose:** Prevents DNS spoofing/cache poisoning

**How It Works:**

```
1. Zone signing: Authoritative server signs records
2. Chain of trust: Root ‚Üí TLD ‚Üí Domain
3. Validation: Resolver verifies signatures
4. Protection: Prevents tampered responses
```

**Benefits:**

- Prevents man-in-the-middle attacks
- Ensures DNS response authenticity
- Protects against cache poisoning

#### B. DNS over HTTPS (DoH) / DNS over TLS (DoT)

**Purpose:** Encrypts DNS queries

**How It Works:**

```
Traditional DNS:
  Client ‚Üí DNS Server: Plain text query

DoH/DoT:
  Client ‚Üí DNS Server: Encrypted query (HTTPS/TLS)
```

**Benefits:**

- Privacy (ISPs can't see queries)
- Security (prevents interception)
- Censorship resistance

### 9. Major DNS Providers

#### A. AWS Route 53

**Features:**

- **Health Checks:** Monitor endpoint health
- **Failover:** Automatic failover routing
- **Geolocation Routing:** Route by user location
- **Latency-Based Routing:** Route to lowest latency
- **Weighted Routing:** Distribute traffic by weight
- **Private DNS:** VPC internal DNS

**Use Cases:**

- AWS-native applications
- Multi-region deployments
- Health-checked failover

#### B. Cloudflare DNS

**Features:**

- **Global Anycast Network:** Fast DNS resolution
- **DDoS Protection:** Built-in DDoS mitigation
- **DNSSEC:** Automatic DNSSEC support
- **Analytics:** DNS query analytics
- **Free Tier:** Free DNS hosting

**Use Cases:**

- Public-facing websites
- DDoS protection needed
- Cost-effective DNS

#### C. Google Cloud DNS

**Features:**

- **Integration:** Google Cloud Platform
- **Private DNS:** VPC internal DNS
- **DNSSEC:** DNSSEC support
- **Low Latency:** Google's global network

**Use Cases:**

- GCP-native applications
- Google Cloud workloads

### 10. DNS Performance Optimization

#### A. DNS Prefetching

**How It Works:**

```
Browser prefetches DNS for links on page:
  <link rel="dns-prefetch" href="//cdn.example.com">
  
Benefits:
  - Faster page loads
  - DNS resolved before user clicks
```

#### B. DNS Preconnect

**How It Works:**

```
Browser preconnects to domain:
  <link rel="preconnect" href="https://api.example.com">
  
Benefits:
  - DNS resolution + TCP handshake + TLS negotiation
  - Ready for immediate requests
```

#### C. EDNS Client Subnet (ECS)

**Purpose:** Provides client subnet to authoritative server

**Benefits:**

- Better GeoDNS (knows client location)
- More accurate routing
- Lower latency

---

## When to Use DNS

### ‚úÖ Use DNS When:

1. **Domain Resolution:** Need to translate domain names to IPs
2. **Service Discovery:** Finding services by name
3. **Load Balancing:** Simple load distribution
4. **Failover:** Automatic failover routing
5. **Geographic Routing:** Route users to nearest data center
6. **Multi-Region:** Multiple data centers, different IPs

### ‚ùå Don't Use DNS When:

1. **Real-Time Health Checks:** Need instant health status (use load balancer)
2. **Complex Routing:** Need application-level routing (use API Gateway)
3. **Session Affinity:** Need sticky sessions (use load balancer)
4. **Low Latency Required:** DNS caching adds delay (use direct IP)

---

## Real-World Examples

### Google (8.8.8.8)

**Use Case:** Public DNS resolver

**Features:**

- Fast resolution
- Global anycast network
- DoH/DoT support
- Security filtering

**Scale:**

- Billions of queries per day
- Global network
- Sub-10ms resolution

### AWS Route 53

**Use Case:** DNS for AWS services

**Features:**

- Health checks
- Failover routing
- Geolocation routing
- Private DNS

**Scale:**

- Millions of hosted zones
- Trillions of queries per month

### Cloudflare DNS

**Use Case:** Public DNS + DDoS protection

**Features:**

- Global anycast
- DDoS protection
- DNSSEC
- Analytics

**Scale:**

- Billions of queries per day
- Global network
- Fast resolution

---

## DNS vs. Other Solutions

| Solution              | Purpose                                | When to Use                             |
|-----------------------|----------------------------------------|-----------------------------------------|
| **DNS**               | Name resolution, simple load balancing | Domain resolution, basic load balancing |
| **Load Balancer**     | Traffic distribution, health checks    | Application-level load balancing        |
| **Service Discovery** | Dynamic service location               | Microservices, containerized apps       |
| **API Gateway**       | Request routing, API management        | Complex routing, API management         |

---

## Common Anti-Patterns

### ‚ùå **1. Too Low TTL**

**Problem:** Very low TTL increases DNS load

**Solution:** Balance TTL with update needs

```
‚ùå Bad:
TTL: 1 second (updates instantly, but 3600√ó more queries)

‚úÖ Good:
TTL: 60 seconds (fast updates, reasonable query load)
TTL: 300 seconds (standard, good balance)
```

### ‚ùå **2. No Health Checks**

**Problem:** DNS returns dead servers

**Solution:** Use health-checked DNS (Route 53, Cloudflare)

```
‚ùå Bad:
Round-robin DNS returns all IPs (including dead ones)

‚úÖ Good:
Health-checked DNS removes unhealthy IPs automatically
```

### ‚ùå **3. Single Name Server**

**Problem:** Single point of failure

**Solution:** Multiple name servers

```
‚ùå Bad:
example.com.  IN  NS  ns1.example.com.  (only one)

‚úÖ Good:
example.com.  IN  NS  ns1.example.com.
example.com.  IN  NS  ns2.example.com.
example.com.  IN  NS  ns3.example.com.
```

---

## Trade-offs Summary

| Aspect                 | What You Gain                     | What You Sacrifice                      |
|------------------------|-----------------------------------|-----------------------------------------|
| **Low TTL**            | Fast updates, quick failover      | Higher DNS query load                   |
| **High TTL**           | Lower query load, cost savings    | Slower updates, longer failover         |
| **DNS Load Balancing** | Simple, no infrastructure         | No health checks, client caching issues |
| **GeoDNS**             | Lower latency, better performance | Configuration complexity                |
| **DNSSEC**             | Security, authenticity            | Additional complexity, larger responses |

---

## References

- **DNS RFC 1035:** [https://tools.ietf.org/html/rfc1035](https://tools.ietf.org/html/rfc1035)
- **AWS Route 53:** [https://aws.amazon.com/route53/](https://aws.amazon.com/route53/)
- **Cloudflare DNS:** [https://www.cloudflare.com/dns/](https://www.cloudflare.com/dns/)
- **Related Chapters:**
    - [1.2.2 Networking Components](../../01-principles/1.2.2-networking-components.md) - High-level DNS overview
    - [2.0.4 Load Balancers Deep Dive](./2.0.4-load-balancers-deep-dive.md) - DNS vs Load Balancer

---

## ‚úèÔ∏è Design Challenge

### Problem

You are designing a multi-region application with 3 data centers (US, EU, APAC) that must:

1. **Route users to nearest data center** (geographic routing)
2. **Handle failover** (if one data center fails, route to backup)
3. **Load balance** within each data center (multiple servers per region)
4. **Support health checks** (remove unhealthy servers)
5. **Fast DNS resolution** (<50ms globally)
6. **Handle 1M DNS queries per minute** (high volume)

**Constraints:**

- Each region has 5 servers
- Need automatic failover (<2 minutes)
- Users should always get healthy servers
- Must support both IPv4 and IPv6

Design a DNS strategy that:

- Routes users geographically
- Handles failover automatically
- Load balances within regions
- Supports health checks
- Handles high query volume
- Ensures fast resolution

### Solution

#### üß© Scenario

- **Regions:** 3 (US, EU, APAC)
- **Servers per Region:** 5 (total: 15 servers)
- **DNS Queries:** 1M per minute = 16,667 per second
- **Failover Time:** <2 minutes
- **Resolution Time:** <50ms globally

**Calculations:**

- **Queries per Region:** ~5,556 per second (distributed)
- **TTL:** 60 seconds (balance update speed vs query load)
- **Health Check Interval:** 30 seconds (detect failures quickly)

#### ‚úÖ Step 1: DNS Provider Choice

**Choice: AWS Route 53**

**Why:**

- **Geolocation Routing:** Route by user location
- **Health Checks:** Monitor server health
- **Failover:** Automatic failover routing
- **Weighted Routing:** Load balance within region
- **High Performance:** Global anycast network (<50ms)
- **IPv6 Support:** AAAA records

#### ‚úÖ Step 2: Geographic Routing

**Geolocation Routing Configuration:**

```
Route 53 Geolocation Records:

US Region:
  www.example.com (US) ‚Üí 192.0.2.1, 192.0.2.2, 192.0.2.3, 192.0.2.4, 192.0.2.5
  Weighted: 20% each (5 servers)

EU Region:
  www.example.com (EU) ‚Üí 192.0.3.1, 192.0.3.2, 192.0.3.3, 192.0.3.4, 192.0.3.5
  Weighted: 20% each (5 servers)

APAC Region:
  www.example.com (APAC) ‚Üí 192.0.4.1, 192.0.4.2, 192.0.4.3, 192.0.4.4, 192.0.4.5
  Weighted: 20% each (5 servers)

Default (Other locations):
  www.example.com (Default) ‚Üí 192.0.2.1 (US primary)
```

**Routing Logic:**

```
User Location ‚Üí Route 53 ‚Üí Returns region-specific IPs
  - US user ‚Üí US IPs
  - EU user ‚Üí EU IPs
  - APAC user ‚Üí APAC IPs
  - Unknown ‚Üí Default (US)
```

#### ‚úÖ Step 3: Health Checks

**Health Check Configuration:**

```
Per-Server Health Checks:
  - Endpoint: HTTP GET /health
  - Interval: 30 seconds
  - Timeout: 5 seconds
  - Failure Threshold: 3 consecutive failures
  - Success Threshold: 1 success to recover

Health Check Flow:
  1. Route 53 checks /health endpoint every 30s
  2. If 3 failures ‚Üí Mark server unhealthy
  3. Remove from DNS response
  4. If 1 success ‚Üí Mark healthy, add back to DNS
```

**Health Check Results:**

```
Healthy Servers:
  - Included in DNS response
  - Traffic routed to healthy servers only

Unhealthy Servers:
  - Removed from DNS response
  - No traffic routed (automatic)
```

#### ‚úÖ Step 4: Load Balancing Within Region

**Weighted Routing:**

```
US Region (5 servers):
  www.example.com (US, weight: 20) ‚Üí 192.0.2.1
  www.example.com (US, weight: 20) ‚Üí 192.0.2.2
  www.example.com (US, weight: 20) ‚Üí 192.0.2.3
  www.example.com (US, weight: 20) ‚Üí 192.0.2.4
  www.example.com (US, weight: 20) ‚Üí 192.0.2.5

Distribution: 20% traffic to each server
```

**Dynamic Weight Adjustment:**

```
If server unhealthy:
  - Weight set to 0 (removed from DNS)
  - Remaining servers share traffic (25% each if 4 healthy)

If server recovers:
  - Weight restored to 20
  - All servers share traffic again
```

#### ‚úÖ Step 5: Failover Strategy

**Primary/Secondary Failover:**

```
US Region Failover:
  Primary: US servers (192.0.2.1-5)
  Secondary: EU servers (192.0.3.1-5)

Configuration:
  - Primary: Health checks enabled
  - Secondary: Failover routing (only if primary fails)
  - Failover Time: <2 minutes (30s check √ó 3 failures + DNS propagation)
```

**Multi-Region Failover:**

```
Failover Chain:
  1. Primary: User's region (e.g., US)
  2. Secondary: Nearest region (e.g., EU)
  3. Tertiary: Remaining region (e.g., APAC)

Example (US region fails):
  US user ‚Üí EU servers (nearest backup)
  EU user ‚Üí US servers (if EU fails, US backup)
```

#### ‚úÖ Step 6: DNS Performance

**TTL Configuration:**

```
TTL: 60 seconds

Rationale:
  - Fast updates (failover in <2 minutes)
  - Reasonable query load (not too high)
  - Good balance
```

**DNS Caching:**

```
Caching Layers:
  1. Browser Cache: 60s TTL
  2. OS Cache: 60s TTL
  3. Recursive Resolver Cache: 60s TTL
  4. Route 53: Authoritative (no cache)

Cache Invalidation:
  - Health check failure ‚Üí Remove from DNS immediately
  - DNS propagation: <60s (TTL)
```

**Query Performance:**

```
Route 53 Global Network:
  - Anycast (nearest Route 53 server)
  - Resolution: <50ms globally
  - Handles 1M queries/minute easily
```

#### ‚úÖ Step 7: IPv6 Support

**Dual-Stack Configuration:**

```
IPv4 Records (A):
  www.example.com (US) ‚Üí 192.0.2.1, 192.0.2.2, ...

IPv6 Records (AAAA):
  www.example.com (US) ‚Üí 2001:db8::1, 2001:db8::2, ...

Client Resolution:
  - IPv6-enabled client ‚Üí Gets AAAA records
  - IPv4-only client ‚Üí Gets A records
  - Dual-stack client ‚Üí Prefers IPv6, falls back to IPv4
```

#### ‚úÖ Complete Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ          Global Users (1M queries/minute)                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ   Route 53 (Geolocation)    ‚îÇ
        ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
        ‚îÇ   ‚îÇ Health Checks         ‚îÇ ‚îÇ
        ‚îÇ   ‚îÇ (30s interval)        ‚îÇ ‚îÇ
        ‚îÇ   ‚îÇ Geolocation Routing   ‚îÇ ‚îÇ
        ‚îÇ   ‚îÇ Weighted Routing      ‚îÇ ‚îÇ
        ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ                  ‚îÇ                  ‚îÇ
    ‚ñº                  ‚ñº                  ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ US      ‚îÇ      ‚îÇ EU      ‚îÇ      ‚îÇ APAC    ‚îÇ
‚îÇ Region  ‚îÇ      ‚îÇ Region  ‚îÇ      ‚îÇ Region  ‚îÇ
‚îÇ         ‚îÇ      ‚îÇ         ‚îÇ      ‚îÇ         ‚îÇ
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ      ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ      ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ ‚îÇSrv1 ‚îÇ ‚îÇ      ‚îÇ ‚îÇSrv1 ‚îÇ ‚îÇ      ‚îÇ ‚îÇSrv1 ‚îÇ ‚îÇ
‚îÇ ‚îÇSrv2 ‚îÇ ‚îÇ      ‚îÇ ‚îÇSrv2 ‚îÇ ‚îÇ      ‚îÇ ‚îÇSrv2 ‚îÇ ‚îÇ
‚îÇ ‚îÇSrv3 ‚îÇ ‚îÇ      ‚îÇ ‚îÇSrv3 ‚îÇ ‚îÇ      ‚îÇ ‚îÇSrv3 ‚îÇ ‚îÇ
‚îÇ ‚îÇSrv4 ‚îÇ ‚îÇ      ‚îÇ ‚îÇSrv4 ‚îÇ ‚îÇ      ‚îÇ ‚îÇSrv4 ‚îÇ ‚îÇ
‚îÇ ‚îÇSrv5 ‚îÇ ‚îÇ      ‚îÇ ‚îÇSrv5 ‚îÇ ‚îÇ      ‚îÇ ‚îÇSrv5 ‚îÇ ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ      ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ      ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Request Flow:**

```
1. User (US) ‚Üí Route 53: DNS query for www.example.com
2. Route 53: Determines user location (US)
3. Route 53: Checks health of US servers
4. Route 53: Returns healthy US servers (weighted)
5. Route 53 ‚Üí User: Returns 192.0.2.1, 192.0.2.2, 192.0.2.3, 192.0.2.4, 192.0.2.5
6. User ‚Üí US Server: Connects to 192.0.2.1 (first in list)
```

**Failover Flow:**

```
1. US Server 192.0.2.1 fails health check
2. Route 53: Removes 192.0.2.1 from DNS response
3. Route 53 ‚Üí User: Returns 192.0.2.2, 192.0.2.3, 192.0.2.4, 192.0.2.5
4. User ‚Üí US Server: Connects to 192.0.2.2 (next healthy server)

If all US servers fail:
1. Route 53: All US servers unhealthy
2. Route 53: Failover to EU servers (secondary)
3. Route 53 ‚Üí User: Returns EU servers
4. User ‚Üí EU Server: Connects to EU (backup region)
```

#### ‚öñÔ∏è Trade-offs Summary

| Decision                  | What We Gain                 | What We Sacrifice              |
|---------------------------|------------------------------|--------------------------------|
| **Route 53 Geolocation**  | Lower latency, better UX     | Higher cost than simple DNS    |
| **Health Checks (30s)**   | Fast failure detection       | Higher health check load       |
| **TTL (60s)**             | Fast failover, updates       | Higher DNS query load          |
| **Weighted Routing**      | Load balancing within region | Configuration complexity       |
| **Multi-Region Failover** | High availability            | Higher cost (multiple regions) |

#### ‚úÖ Final Summary

**DNS Strategy:**

- **Provider:** AWS Route 53 (geolocation, health checks, failover)
- **Routing:** Geolocation (US, EU, APAC) + Weighted (within region)
- **Health Checks:** 30s interval, 3 failure threshold
- **Failover:** Primary region ‚Üí Secondary region (automatic)
- **TTL:** 60 seconds (balance speed vs load)
- **IPv6:** Dual-stack (A + AAAA records)

**Performance:**

- **DNS Resolution:** <50ms globally (Route 53 anycast)
- **Query Volume:** 1M queries/minute (handled easily)
- **Failover Time:** <2 minutes (30s check √ó 3 + DNS propagation)
- **Health Detection:** <90 seconds (30s √ó 3 failures)

**Result:**

- ‚úÖ Routes users to nearest data center (geolocation)
- ‚úÖ Automatic failover (<2 minutes)
- ‚úÖ Load balances within region (weighted routing)
- ‚úÖ Health checks (removes unhealthy servers)
- ‚úÖ Fast DNS resolution (<50ms)
- ‚úÖ Handles 1M queries/minute
- ‚úÖ IPv6 support (dual-stack)

