# 2.0.5 API Gateway Deep Dive: The Single Entry Point for Microservices

## Intuitive Explanation

Imagine a large office building with 50 different departments. Instead of visitors wandering around trying to find the
right department, there's a **reception desk (API Gateway)** at the entrance. The receptionist:

- **Directs visitors** to the correct department ("User inquiries? Go to Department 3")
- **Checks credentials** before allowing entry (security)
- **Limits how many visitors** can enter at once (rate limiting)
- **Translates requests** ("I need help" â†’ routes to Support Department)
- **Handles common tasks** so departments don't have to (authentication, logging)

**In microservices:**

- **API Gateway:** Single entry point for all client requests
- **Goal:** Centralize cross-cutting concerns (auth, rate limiting, routing) so microservices focus on business logic
- **Benefit:** Simplifies client integration, protects backend services, enables protocol translation

---

## In-Depth Analysis

### 1. What is an API Gateway?

An **API Gateway** is a reverse proxy that sits between clients and microservices, providing a unified interface for
accessing multiple backend services.

**Key Functions:**

- **Request Routing:** Routes requests to appropriate microservices based on URL path, headers, or other criteria
- **Authentication & Authorization:** Validates tokens (JWT, OAuth) before forwarding requests
- **Rate Limiting:** Protects backend services from being overwhelmed
- **Protocol Translation:** Converts REST to gRPC, HTTP to WebSocket, etc.
- **Request/Response Transformation:** Modifies requests/responses (aggregation, filtering)
- **Monitoring & Logging:** Centralized logging and metrics collection

**Architecture:**

```
Client â†’ API Gateway â†’ Microservices
                      â”œâ”€ User Service
                      â”œâ”€ Order Service
                      â”œâ”€ Payment Service
                      â””â”€ Product Service
```

### 2. API Gateway vs. Load Balancer

| Aspect       | API Gateway                                   | Load Balancer                        |
|--------------|-----------------------------------------------|--------------------------------------|
| **Layer**    | Layer 7 (Application)                         | Layer 4 (Transport) or Layer 7       |
| **Purpose**  | API management, routing to different services | Traffic distribution to same service |
| **Routing**  | Path-based, header-based, service discovery   | Round-robin, least connections       |
| **Features** | Auth, rate limiting, protocol translation     | Health checks, SSL termination       |
| **Use Case** | Microservices (multiple services)             | Multiple instances of same service   |

**Key Difference:**

- **Load Balancer:** Routes to multiple instances of the **same service**
- **API Gateway:** Routes to **different services** based on request content

### 3. Core Features

#### A. Request Routing

**Path-Based Routing:**

```
GET /api/users/* â†’ User Service
GET /api/orders/* â†’ Order Service
GET /api/products/* â†’ Product Service
```

**Header-Based Routing:**

```
X-Service-Version: v2 â†’ Routes to v2 service
X-User-Type: premium â†’ Routes to premium service
```

**Service Discovery Integration:**

```
API Gateway â†’ Service Registry (Consul, etcd)
           â†’ Discovers available services
           â†’ Routes to healthy instances
```

#### B. Authentication & Authorization

**JWT Validation:**

```
1. Client sends request with JWT token
2. API Gateway validates token signature
3. API Gateway extracts user claims
4. API Gateway forwards request with user context
5. Backend service trusts API Gateway (no re-validation)
```

**OAuth 2.0 / OIDC:**

```
1. Client redirects to OAuth provider
2. User authenticates
3. Provider returns authorization code
4. API Gateway exchanges code for access token
5. API Gateway validates token for subsequent requests
```

**API Keys:**

```
1. Client includes API key in header
2. API Gateway validates key against database/cache
3. API Gateway checks rate limits per key
4. API Gateway routes request if valid
```

#### C. Rate Limiting

**Per-User Rate Limiting:**

```
User A: 100 requests/minute
User B: 100 requests/minute
â†’ Each user has independent limit
```

**Per-API-Key Rate Limiting:**

```
Free Tier: 1000 requests/day
Premium Tier: 100,000 requests/day
â†’ Different limits per tier
```

**Per-Service Rate Limiting:**

```
User Service: 10,000 requests/minute
Order Service: 5,000 requests/minute
â†’ Protects each service independently
```

**Algorithms:**

- **Token Bucket:** Allows bursts, smooths over time
- **Fixed Window:** Simple, but allows bursts at window boundaries
- **Sliding Window:** More accurate, prevents bursts

#### D. Protocol Translation

**REST to gRPC:**

```
Client â†’ API Gateway (REST/JSON)
      â†’ Converts to gRPC/Protobuf
      â†’ Backend Service (gRPC)
```

**HTTP to WebSocket:**

```
Client â†’ API Gateway (HTTP upgrade request)
      â†’ Establishes WebSocket connection
      â†’ Backend Service (WebSocket)
```

**GraphQL to REST:**

```
Client â†’ API Gateway (GraphQL query)
      â†’ Resolves to multiple REST calls
      â†’ Aggregates responses
      â†’ Returns GraphQL response
```

#### E. Request/Response Transformation

**Request Aggregation:**

```
Client: GET /api/user-profile
API Gateway:
  â†’ Calls User Service (GET /users/123)
  â†’ Calls Order Service (GET /orders?user_id=123)
  â†’ Aggregates responses
  â†’ Returns combined profile
```

**Response Filtering:**

```
Backend: Returns full user object (20 fields)
API Gateway: Filters to 5 fields (based on client permissions)
Client: Receives only allowed fields
```

**Request Enrichment:**

```
Client: POST /api/orders
API Gateway:
  â†’ Adds user_id (from JWT)
  â†’ Adds timestamp
  â†’ Adds request_id (for tracing)
  â†’ Forwards to Order Service
```

### 4. API Gateway Patterns

#### A. Backend for Frontend (BFF)

**Problem:** Different clients (mobile, web, admin) need different data formats

**Solution:** Separate API Gateway per client type

```
Mobile BFF:
  â†’ Optimized for mobile (small payloads, offline support)
  â†’ Returns minimal data

Web BFF:
  â†’ Optimized for web (rich data, real-time updates)
  â†’ Returns full data

Admin BFF:
  â†’ Optimized for admin (bulk operations, analytics)
  â†’ Returns aggregated data
```

#### B. API Composition

**Problem:** Client needs data from multiple services

**Solution:** API Gateway aggregates responses

```
Client: GET /api/dashboard
API Gateway:
  â†’ Calls User Service (user info)
  â†’ Calls Order Service (recent orders)
  â†’ Calls Product Service (recommendations)
  â†’ Combines responses
  â†’ Returns dashboard data
```

#### C. Circuit Breaker

**Problem:** One failing service can cascade failures

**Solution:** API Gateway implements circuit breaker

```
Service Health:
  - Healthy: Requests forwarded
  - Degraded: Some requests forwarded (sample)
  - Unhealthy: Circuit open, requests fail fast
  - Recovering: Gradually allow requests
```

### 5. Major API Gateway Solutions

#### Kong

**Architecture:**

- Built on NGINX
- Plugin-based architecture
- Supports REST, gRPC, WebSocket
- Database-backed (PostgreSQL, Cassandra)

**Features:**

- Authentication (JWT, OAuth, API keys)
- Rate limiting (Redis-based)
- Load balancing
- Request/response transformation
- Plugin ecosystem (100+ plugins)

**Use Cases:**

- On-premises deployments
- Multi-cloud environments
- High customization needs

#### AWS API Gateway

**Architecture:**

- Fully managed service
- Serverless (pay per request)
- Integrated with AWS services

**Features:**

- REST APIs
- WebSocket APIs
- HTTP APIs (lower latency, lower cost)
- Lambda integration
- Cognito authentication
- CloudWatch monitoring

**Use Cases:**

- AWS-native applications
- Serverless architectures
- Cost-effective for variable traffic

#### NGINX Plus / NGINX Gateway

**Architecture:**

- High-performance reverse proxy
- Configuration-based
- Lightweight

**Features:**

- Advanced load balancing
- Rate limiting
- JWT validation
- Request routing
- Health checks

**Use Cases:**

- High-performance requirements
- Simple routing needs
- Cost-sensitive deployments

#### Traefik

**Architecture:**

- Auto-discovery (Kubernetes, Docker, Consul)
- Dynamic configuration
- Let's Encrypt integration

**Features:**

- Automatic HTTPS
- Service discovery
- Load balancing
- Rate limiting
- Circuit breaker

**Use Cases:**

- Kubernetes deployments
- Containerized applications
- Dynamic service discovery

### 6. API Gateway Architecture Patterns

#### A. Centralized API Gateway

**Architecture:**

```
All Clients â†’ Single API Gateway â†’ All Services
```

**Pros:**

- Single point of configuration
- Consistent policies
- Centralized monitoring

**Cons:**

- Single point of failure
- Potential bottleneck
- Harder to scale

#### B. Distributed API Gateway (Per Service)

**Architecture:**

```
Client â†’ Service-Specific Gateway â†’ Service
```

**Pros:**

- No single point of failure
- Independent scaling
- Service-specific optimizations

**Cons:**

- More complex management
- Duplicate configuration
- Higher operational overhead

#### C. Hybrid Approach

**Architecture:**

```
Client â†’ Central Gateway â†’ Service Gateways â†’ Services
```

**Pros:**

- Centralized policies
- Service-specific optimizations
- Better scalability

**Cons:**

- More complex architecture
- Higher latency (two hops)

### 7. Security Features

#### A. Authentication

**JWT Validation:**

- Validates token signature
- Checks expiration
- Validates issuer/audience
- Extracts claims for authorization

**OAuth 2.0:**

- Authorization code flow
- Client credentials flow
- Token refresh
- Token introspection

**API Keys:**

- Key validation
- Key rotation
- Per-key rate limiting
- Key revocation

#### B. Authorization

**Role-Based Access Control (RBAC):**

```
User Role: admin
â†’ Can access /api/admin/*
â†’ Cannot access /api/user/* (unless also user)
```

**Attribute-Based Access Control (ABAC):**

```
User Attribute: department=engineering
â†’ Can access /api/engineering/*
â†’ Cannot access /api/sales/*
```

**Policy-Based:**

```
Policy: "Users can only access their own data"
â†’ API Gateway enforces: user_id from JWT must match resource user_id
```

#### C. Threat Protection

**DDoS Protection:**

- Rate limiting
- IP whitelisting/blacklisting
- Request size limits
- Connection limits

**SQL Injection / XSS Prevention:**

- Input validation
- Request sanitization
- Content Security Policy headers

**Bot Detection:**

- CAPTCHA integration
- Behavioral analysis
- Device fingerprinting

---

## When to Use API Gateway

### âœ… Use API Gateway When:

1. **Microservices Architecture:** Multiple services need unified entry point
2. **Multiple Clients:** Mobile, web, admin need different interfaces
3. **Cross-Cutting Concerns:** Need centralized auth, rate limiting, logging
4. **Protocol Translation:** Clients use different protocols than services
5. **Service Aggregation:** Need to combine data from multiple services
6. **Security:** Need centralized security policies

### âŒ Don't Use API Gateway When:

1. **Monolithic Application:** Single service (overhead not worth it)
2. **Simple Use Case:** Single client, single service (direct connection)
3. **Low Traffic:** Traffic doesn't justify additional infrastructure
4. **Service Mesh:** Already using service mesh for service-to-service communication (may be redundant)

---

## Real-World Examples

### Netflix (Zuul API Gateway)

**Use Case:** Routing requests to 100+ microservices

**Architecture:**

- Zuul (now Spring Cloud Gateway) as API Gateway
- Routes based on service discovery
- Handles authentication, rate limiting
- Request/response transformation

**Scale:**

- Billions of requests per day
- 100+ microservices
- Multiple client types (TV, mobile, web)

### Amazon (API Gateway)

**Use Case:** Serverless microservices

**Architecture:**

- AWS API Gateway
- Lambda functions as services
- Cognito for authentication
- CloudWatch for monitoring

**Scale:**

- Millions of API calls per day
- Pay-per-request pricing
- Auto-scaling

### Stripe (API Gateway)

**Use Case:** Payment API

**Architecture:**

- Custom API Gateway
- Rate limiting per API key
- Request logging and analytics
- Webhook management

**Features:**

- Per-key rate limits
- Request idempotency
- Webhook retries
- API versioning

---

## API Gateway vs. Other Components

| Component         | Purpose                                       | When to Use                          |
|-------------------|-----------------------------------------------|--------------------------------------|
| **API Gateway**   | API management, routing to different services | Microservices, multiple clients      |
| **Load Balancer** | Traffic distribution to same service          | Multiple instances of one service    |
| **Service Mesh**  | Service-to-service communication              | Internal microservices communication |
| **Reverse Proxy** | Simple request forwarding                     | Basic routing, no advanced features  |

---

## Common Anti-Patterns

### âŒ **1. API Gateway as Single Point of Failure**

**Problem:** Single API Gateway instance fails â†’ entire system down

**Solution:** Multiple API Gateway instances with load balancer

```
âŒ Bad:
Client â†’ Single API Gateway â†’ Services
(If gateway fails, all requests fail)

âœ… Good:
Client â†’ Load Balancer â†’ Multiple API Gateways â†’ Services
(If one gateway fails, others continue)
```

### âŒ **2. Bypassing API Gateway**

**Problem:** Services accessed directly, bypassing gateway

**Solution:** Enforce gateway usage (network policies, firewall rules)

```
âŒ Bad:
Client â†’ Service (direct access)
Client â†’ API Gateway â†’ Service
(Inconsistent access, security issues)

âœ… Good:
Client â†’ API Gateway â†’ Service (only path)
(All requests go through gateway)
```

### âŒ **3. Too Much Logic in API Gateway**

**Problem:** Business logic in gateway (should be in services)

**Solution:** Keep gateway focused on cross-cutting concerns

```
âŒ Bad:
API Gateway:
  - Validates order business rules
  - Calculates shipping costs
  - Applies discounts
(Too much business logic)

âœ… Good:
API Gateway:
  - Validates JWT token
  - Rate limiting
  - Routes to Order Service
Order Service:
  - Validates order rules
  - Calculates shipping
  - Applies discounts
```

### âŒ **4. No Caching**

**Problem:** Every request hits backend services

**Solution:** Cache responses at API Gateway

```
âŒ Bad:
Client â†’ API Gateway â†’ User Service (every request)
(High latency, high backend load)

âœ… Good:
Client â†’ API Gateway â†’ Cache (if available)
Client â†’ API Gateway â†’ User Service (if cache miss)
(Lower latency, reduced backend load)
```

---

## Trade-offs Summary

| Aspect                     | What You Gain                          | What You Sacrifice             |
|----------------------------|----------------------------------------|--------------------------------|
| **Centralized Management** | Consistent policies, easier monitoring | Single point of failure risk   |
| **Protocol Translation**   | Client flexibility                     | Additional latency, complexity |
| **Request Aggregation**    | Reduced client complexity              | Higher latency, coupling       |
| **Rate Limiting**          | Backend protection                     | Additional infrastructure cost |
| **Authentication**         | Centralized security                   | Gateway must be highly secure  |

---

## References

- **Kong Documentation:** [https://docs.konghq.com/](https://docs.konghq.com/)
- **AWS API Gateway:** [https://docs.aws.amazon.com/apigateway/](https://docs.aws.amazon.com/apigateway/)
- **NGINX Plus:** [https://www.nginx.com/products/nginx/](https://www.nginx.com/products/nginx/)
- **Related Chapters:**
    - [2.0.4 Load Balancers Deep Dive](./2.0.4-load-balancers-deep-dive.md) - Load balancing vs API Gateway
    - [1.2.3 API Gateway and Service Mesh](../../01-principles/1.2.3-api-gateway-servicemesh.md) - High-level overview

---

## âœï¸ Design Challenge

### Problem

You are designing a microservices e-commerce platform with 20 services that must handle 10 million requests per day. The
platform must:

1. **Route requests** to correct service based on URL path
2. **Authenticate users** (JWT validation, 1M active users)
3. **Rate limit** per user (100 requests/minute) and per service
4. **Aggregate data** from multiple services for dashboard
5. **Support multiple clients** (mobile app, web app, admin panel)
6. **Handle 1000 requests/second** peak traffic

**Constraints:**

- Services use gRPC internally
- Clients use REST/JSON
- Need protocol translation
- Services distributed across 3 regions
- Must handle service failures gracefully

Design an API Gateway strategy that:

- Routes requests correctly
- Handles authentication efficiently
- Implements rate limiting
- Supports protocol translation
- Aggregates data from multiple services
- Handles high traffic

### Solution

#### ğŸ§© Scenario

- **Services:** 20 microservices
- **Traffic:** 10M requests/day = 115 requests/second average, 1000/second peak
- **Users:** 1M active users
- **Protocol:** REST (client) â†’ gRPC (services)
- **Regions:** 3 regions

**Calculations:**

- **Peak QPS:** 1000 requests/second
- **API Gateway Instances:** 1000 QPS Ã· 500 QPS per instance = 2 instances minimum (use 5 for redundancy)
- **Rate Limiting Storage:** 1M users Ã— 100 req/min = 100M rate limit counters (need Redis cluster)

#### âœ… Step 1: API Gateway Architecture

**Choice: Kong API Gateway with Redis**

**Why:**

- **High Performance:** Handles 10K+ requests/second per instance
- **Plugin Ecosystem:** Rich plugins for auth, rate limiting, transformation
- **Protocol Support:** REST, gRPC, WebSocket
- **Scalable:** Horizontal scaling with load balancer
- **Redis Integration:** Built-in Redis support for rate limiting

**Architecture:**

```
Internet â†’ Load Balancer â†’ Multiple Kong Instances (5 per region)
                          â”œâ”€ Kong 1
                          â”œâ”€ Kong 2
                          â”œâ”€ Kong 3
                          â”œâ”€ Kong 4
                          â””â”€ Kong 5
```

#### âœ… Step 2: Request Routing

**Path-Based Routing Configuration:**

```
Routes:
  /api/users/* â†’ User Service (gRPC)
  /api/orders/* â†’ Order Service (gRPC)
  /api/products/* â†’ Product Service (gRPC)
  /api/payments/* â†’ Payment Service (gRPC)
  /api/dashboard â†’ Dashboard Aggregator (custom plugin)
```

**Service Discovery:**

```
Kong â†’ Consul Service Registry
    â†’ Discovers healthy service instances
    â†’ Routes to available instances
    â†’ Health checks every 30 seconds
```

**Multi-Region Routing:**

```
Route based on:
  - User location (geo-routing)
  - Service availability (health checks)
  - Latency (route to nearest region)
```

#### âœ… Step 3: Authentication

**JWT Validation Plugin:**

```
Kong JWT Plugin Configuration:
  - Validates token signature (RS256)
  - Checks expiration
  - Validates issuer/audience
  - Extracts claims (user_id, roles)
  - Adds claims to headers (X-User-ID, X-User-Roles)
```

**Flow:**

```
1. Client â†’ Kong: Request with JWT token
2. Kong: Validates JWT (signature, expiration)
3. Kong: Extracts user_id, roles from token
4. Kong: Adds headers (X-User-ID: 123, X-User-Roles: customer)
5. Kong â†’ Service: Forwards request with headers
6. Service: Trusts Kong (no re-validation needed)
```

**Token Caching:**

```
Kong â†’ Redis: Cache validated tokens (TTL: 5 minutes)
â†’ Reduces validation overhead (signature verification)
â†’ 80% cache hit rate â†’ 80% faster authentication
```

#### âœ… Step 4: Rate Limiting

**Per-User Rate Limiting:**

```
Kong Rate Limiting Plugin:
  - Algorithm: Sliding Window
  - Limit: 100 requests/minute per user
  - Storage: Redis Cluster
  - Key: user_id:endpoint
```

**Per-Service Rate Limiting:**

```
Service Limits:
  - User Service: 10,000 requests/minute
  - Order Service: 5,000 requests/minute
  - Payment Service: 2,000 requests/minute
```

**Redis Cluster Configuration:**

```
Redis Cluster: 6 nodes (3 masters, 3 replicas)
  - Handles 100M rate limit counters
  - Sharded by user_id
  - Replication for high availability
```

**Rate Limit Headers:**

```
Response Headers:
  X-RateLimit-Limit: 100
  X-RateLimit-Remaining: 95
  X-RateLimit-Reset: 1699123456
```

#### âœ… Step 5: Protocol Translation

**REST to gRPC Translation:**

```
Kong gRPC Plugin:
  - Converts REST/JSON to gRPC/Protobuf
  - Maps URL path to gRPC method
  - Transforms JSON to Protobuf message
  - Handles gRPC errors â†’ HTTP status codes
```

**Example:**

```
Client Request:
  GET /api/users/123
  Headers: Authorization: Bearer <token>

Kong Transformation:
  â†’ gRPC Call: GetUser(user_id: "123")
  â†’ gRPC Service: user-service:50051
  â†’ Protobuf Message: {user_id: "123"}

Service Response:
  â†’ Protobuf: {id: "123", name: "John", email: "john@example.com"}
  â†’ Kong: Converts to JSON
  â†’ Client: Receives JSON response
```

#### âœ… Step 6: Request Aggregation (Dashboard)

**Custom Kong Plugin:**

```
Dashboard Endpoint: GET /api/dashboard

Plugin Logic:
  1. Extract user_id from JWT
  2. Parallel calls:
     - User Service: GetUser(user_id)
     - Order Service: GetRecentOrders(user_id)
     - Product Service: GetRecommendations(user_id)
  3. Aggregate responses
  4. Return combined JSON
```

**Implementation:**

```
Kong Plugin (Lua):
  local user_service = http_client:get("/users/" .. user_id)
  local orders_service = http_client:get("/orders?user_id=" .. user_id)
  local products_service = http_client:get("/recommendations?user_id=" .. user_id)
  
  local dashboard = {
    user = user_service.body,
    orders = orders_service.body,
    recommendations = products_service.body
  }
  
  return kong.response.exit(200, dashboard)
```

**Caching:**

```
Dashboard Response:
  - Cache key: dashboard:user_id
  - TTL: 60 seconds
  - Redis storage
  â†’ Reduces service load (80% cache hit rate)
```

#### âœ… Step 7: Multi-Client Support (BFF Pattern)

**Backend for Frontend (BFF) Routes:**

```
Mobile BFF:
  /mobile/api/* â†’ Mobile-optimized responses (minimal data)
  
Web BFF:
  /web/api/* â†’ Web-optimized responses (rich data)
  
Admin BFF:
  /admin/api/* â†’ Admin-optimized responses (bulk data, analytics)
```

**Response Transformation:**

```
Mobile Request: GET /mobile/api/users/123
  â†’ Kong: Calls User Service
  â†’ Kong: Filters response (only: id, name, avatar)
  â†’ Client: Receives minimal payload (50% smaller)

Web Request: GET /web/api/users/123
  â†’ Kong: Calls User Service
  â†’ Kong: Returns full response (all fields)
  â†’ Client: Receives complete data
```

#### âœ… Step 8: Circuit Breaker

**Kong Circuit Breaker Plugin:**

```
Configuration:
  - Failure Threshold: 5 failures in 10 seconds
  - Success Threshold: 2 successes to recover
  - Timeout: 5 seconds
  - Half-Open State: Allow 1 request to test
```

**Behavior:**

```
Service Health:
  - Healthy: All requests forwarded
  - Degraded: 50% requests forwarded (sample)
  - Unhealthy: Circuit open, fail fast (503 Service Unavailable)
  - Recovering: Gradually allow requests (1 â†’ 10% â†’ 50% â†’ 100%)
```

#### âœ… Step 9: Monitoring & Observability

**Metrics Collection:**

```
Kong â†’ Prometheus:
  - Request rate (QPS)
  - Latency (p50, p95, p99)
  - Error rate (4xx, 5xx)
  - Rate limit hits
  - Circuit breaker state
```

**Distributed Tracing:**

```
Kong â†’ Jaeger:
  - Generates trace ID
  - Adds trace headers (X-Trace-ID)
  - Forwards to services
  - Collects spans from all services
```

**Logging:**

```
Kong â†’ ELK Stack:
  - Request logs (method, path, status, latency)
  - Error logs (stack traces, context)
  - Access logs (IP, user_id, timestamp)
```

#### âœ… Complete Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Clients (Mobile, Web, Admin)                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   Load Balancer (ALB)       â”‚
        â”‚   (3 regions, active-active)â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   Kong API Gateway Cluster  â”‚
        â”‚   (5 instances per region)  â”‚
        â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
        â”‚   â”‚ Plugins:              â”‚ â”‚
        â”‚   â”‚ - JWT Validation      â”‚ â”‚
        â”‚   â”‚ - Rate Limiting       â”‚ â”‚
        â”‚   â”‚ - gRPC Translation    â”‚ â”‚
        â”‚   â”‚ - Request Aggregation â”‚ â”‚
        â”‚   â”‚ - Circuit Breaker     â”‚ â”‚
        â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   Redis Cluster             â”‚
        â”‚   - Rate limit counters     â”‚
        â”‚   - Token cache             â”‚
        â”‚   - Dashboard cache         â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   Service Registry (Consul) â”‚
        â”‚   - Service discovery       â”‚
        â”‚   - Health checks           â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                  â”‚                  â”‚
    â–¼                  â–¼                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ User    â”‚      â”‚ Order   â”‚      â”‚ Product â”‚
â”‚ Service â”‚      â”‚ Service â”‚      â”‚ Service â”‚
â”‚ (gRPC)  â”‚      â”‚ (gRPC)  â”‚      â”‚ (gRPC)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Request Flow:**

```
1. Client â†’ Load Balancer: GET /api/users/123 (JWT token)
2. Load Balancer â†’ Kong: Routes to available instance
3. Kong: Validates JWT (checks Redis cache first)
4. Kong: Checks rate limit (Redis: user_id:endpoint)
5. Kong: Routes to User Service (Consul service discovery)
6. Kong: Translates REST â†’ gRPC
7. User Service â†’ Kong: gRPC response
8. Kong: Translates gRPC â†’ REST/JSON
9. Kong â†’ Client: JSON response
```

#### âš–ï¸ Trade-offs Summary

| Decision                | What We Gain                    | What We Sacrifice                     |
|-------------------------|---------------------------------|---------------------------------------|
| **Kong API Gateway**    | Rich features, plugin ecosystem | Higher complexity than simple proxy   |
| **JWT Caching**         | 80% faster auth                 | Slight staleness risk (5 min TTL)     |
| **Request Aggregation** | Reduced client complexity       | Higher latency, coupling              |
| **Multi-Region**        | Low latency, high availability  | Configuration complexity              |
| **Circuit Breaker**     | Failure isolation               | Some requests fail fast (intentional) |

#### âœ… Final Summary

**API Gateway Strategy:**

- **Gateway:** Kong API Gateway (5 instances per region)
- **Routing:** Path-based with service discovery (Consul)
- **Authentication:** JWT validation with Redis caching
- **Rate Limiting:** Per-user (100/min) and per-service (Redis cluster)
- **Protocol Translation:** REST â†’ gRPC (Kong gRPC plugin)
- **Aggregation:** Custom plugin for dashboard
- **Multi-Client:** BFF pattern (mobile, web, admin)

**Performance:**

- **Throughput:** 1000 requests/second (5 instances Ã— 200 QPS each)
- **Latency:** <50ms added by gateway (JWT validation, routing)
- **Availability:** 99.99% (multi-region, circuit breakers, health checks)

**Result:**

- âœ… Routes requests correctly (path-based, service discovery)
- âœ… Handles authentication efficiently (JWT + caching)
- âœ… Implements rate limiting (per-user, per-service)
- âœ… Supports protocol translation (REST â†’ gRPC)
- âœ… Aggregates data (dashboard plugin)
- âœ… Handles high traffic (1000 QPS, horizontal scaling)

