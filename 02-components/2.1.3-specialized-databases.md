# 2.1.3 Specialized Databases: Time-Series, Graph, and Geospatial

## Intuitive Explanation

While $\text{RDBMS}$ and standard $\text{NoSQL}$ databases cover most applications, certain types of data and queries
are fundamentally inefficient in general-purpose databases. Specialized $\text{DBs}$ are designed with a specific access
pattern in mind, leading to massive performance gains for those tasks.

- **Time-Series DB (The Logging Specialist):** Optimized for recording and querying sequences of data points over time (
  e.g., server metrics, stock prices).
- **Graph DB (The Relationship Mapper):** Optimized for storing relationships between entities (e.g., social
  connections, recommendation networks).
- **Geospatial DB (The Map Tracker):** Optimized for queries involving location, distance, and proximity (e.g., "Find
  all restaurants within 5 km").

---

## In-Depth Analysis

### 1. Time-Series Databases (TSDB)

$\text{TSDBs}$ are highly optimized for high-volume writes and range queries (i.e., "Give me the average CPU usage
between 2 PM and 4 PM yesterday").

- **Internal Design:** Data is typically compressed and stored sequentially on disk by time, often using an $\text{LSM}$
  -Tree structure (see 2.1.5) and indexing on both time and the metric key. This structure makes time-range queries
  extremely fast compared to general-purpose databases.
- **Write-Heavy Focus:** Designed to ingest millions of data points per second. Writes are appended, rarely updated.
- **Use Cases:** $\text{IoT}$ sensor data, infrastructure monitoring (Prometheus, Grafana data), stock market data
  analysis.
- **Examples:** InfluxDB, TimescaleDB, Prometheus.

### 2. Graph Databases

Graph databases use nodes, edges, and properties to represent and store data. They excel at traversing relationships,
where a traditional $\text{RDBMS}$ would require complex, slow multi-table joins.

- **Components:**
    - **Node:** An entity (e.g., a User, a Product).
    - **Edge (Relationship):** A connection between two nodes (e.g., "FOLLOWS," "BUYS"). Edges can have properties (
      e.g., the date a user started following another).
- **Use Cases:** Social networks ($\text{Friend}$ $\text{of}$ $\text{a}$ $\text{Friend}$ queries), recommendation
  engines, fraud detection (tracing complex transaction links).
- **Examples:** Neo4j, AWS Neptune.

### 3. Geospatial Databases

These systems, often implemented as extensions to $\text{PostgreSQL}$ ($\text{PostGIS}$) or $\text{MongoDB}$, use
specialized indexing structures to perform spatial queries efficiently.

- **Indexing:** Uses structures like **Geohash** or **Quadtrees** to translate $2\text{D}$ coordinates into a single,
  ordered string or tree structure, allowing proximity queries to be resolved quickly.
- **Query Types:** Point-in-Polygon, distance calculations (e.g., finding all drivers within a radius of a customer).
- **Use Cases:** Ride-sharing (Uber, Lyft), location-based services (Yelp, Foursquare).

### Key Concepts / Tradeoffs

| DB Type     | Rationale (Why Specialized?)                                                                                                 | Trade-off / Limitation                                                                                                                  |
|-------------|------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------|
| Time-Series | Querying across a time range is $\text{O}(1)$ or $\text{O}(\log N)$, compared to $\text{O}(N)$ in a standard $\text{RDBMS}$. | Extremely poor performance for non-time-based queries (e.g., finding the latest record based on a non-indexed attribute).               |
| Graph       | The performance of traversing relationships is constant, regardless of the size of the total dataset.                        | Poor performance for non-relational, bulk data storage and retrieval. Requires a complex schema design focused purely on relationships. |
| Geospatial  | Enables complex mathematical calculations (spherical geometry) at scale.                                                     | $\text{Geohash}$ indexing introduces complexities and potential inaccuracies near region boundaries (the "bounding box" problem).       |

---

## ‚úèÔ∏è Design Challenge

### Problem

You are building a social feed for a hyper-local app (like Nextdoor) that must prioritize showing users events and posts
from their exact neighborhood. How would you model the boundaries of neighborhoods and efficiently query for "all posts
within a $1 \text{km}$ radius" using a Geospatial approach? What index type would you use?

### Solution

#### üß© Scenario Summary

- **App:** Hyper-local social platform (like Nextdoor)
- **Goal:** Show posts/events near a user‚Äôs location (e.g., within 1 km radius)
- **Challenge:** Efficiently query millions of posts filtered by proximity

#### ‚úÖ Step 1: Model Neighborhood Boundaries

Neighborhoods can be represented in one of two ways depending on your precision needs:

##### Option A ‚Äî Polygon Boundaries

- Store each neighborhood as a polygon (GeoJSON Polygon) defining its real geographic area.
- Each post has a latitude and longitude.
- To find which neighborhood a post belongs to:
  ````sql 
  SELECT neighborhood_id
  FROM neighborhoods
  WHERE ST_Contains(geometry, ST_Point(:lat, :lon));
  ````
- This uses geometric containment ‚Äî useful if neighborhoods are irregularly shaped.

##### Option B ‚Äî Radius Approximation (for simplicity)

- Represent each neighborhood by its center point and a radius (e.g., 1 km).
- Then use proximity queries (distance-based) rather than polygon containment.

#### ‚úÖ Step 2: Store Posts with Geo Coordinates

Each post should have:

```json
{
  "post_id": "123",
  "user_id": "u456",
  "text": "Community cleanup event",
  "location": {
    "type": "Point",
    "coordinates": [
      "longitude",
      "latitude"
    ]
  },
  "timestamp": "2025-10-12T10:00:00Z"
}
```

This format follows **GeoJSON**, supported by most document stores and spatial databases.

#### ‚úÖ Step 3: Query ‚Äî ‚ÄúAll posts within 1 km radius‚Äù

Use a **geospatial** ‚Äú`near`‚Äù query, for example:

In PostGIS (PostgreSQL extension)

```sql
SELECT *
FROM posts
WHERE ST_DWithin(
  location::geography,
  ST_MakePoint(:lon, :lat)::geography,
  1000
);
```

Both return all posts within a 1 km radius of the given coordinate efficiently.

#### ‚úÖ Step 4: Index Type ‚Äî Use a Geospatial Index

##### Choice: üó∫Ô∏è Geohash / R-Tree / 2dsphere index

- MongoDB ‚Üí `2dsphere` index (supports spherical coordinates & distance queries)
- PostgreSQL (PostGIS) ‚Üí `GiST` index (R-Tree‚Äìbased for geometry)
- Elasticsearch / DynamoDB ‚Üí Geohash‚Äìbased index for geo-queries

| Database      | Index Type                   | Use Case                             |
|---------------|------------------------------|--------------------------------------|
| MongoDB       | **2dsphere index**           | Queries by radius or polygon         |
| PostGIS       | **GiST (R-Tree)**            | Precise geospatial joins and filters |
| Elasticsearch | **Geohash / GeoPoint index** | Text + location search combined      |

These indexes enable logarithmic lookup for spatial regions instead of full scans.

#### ‚úÖ Step 5: Why This Works

- **Spatial locality:** Points close together are grouped in index cells (geohash buckets or R-tree nodes).
- **Efficient radius queries:** The engine filters by nearby bounding boxes first, then refines by exact distance.
- **Scalable:** Works across millions of posts with real-time query speed.

#### ‚ö†Ô∏è Trade-offs / Gotchas

- **Boundary precision:** Geohash bucketing can cause edge cases near borders (posts slightly outside might be
  included/excluded).
- **Updates:** Re-indexing is needed when post location changes (rare).
- **Storage overhead:** Spatial indexes are larger than normal B-trees.

#### ‚úÖ Final Summary

| Aspect                     | Design Decision                                                        | Reason                             |
|----------------------------|------------------------------------------------------------------------|------------------------------------|
| **Neighborhood model**     | Polygon or center + radius                                             | Represents local boundaries        |
| **Post location storage**  | GeoJSON `{ type: Point, coordinates: [lon, lat] }`                     | Standard geospatial format         |
| **Query for posts nearby** | `ST_DWithin` / `$nearSphere` within 1 km                               | Fast proximity filter              |
| **Index type**             | **2dsphere / R-Tree (GiST)**                                           | Enables efficient spatial lookup   |
| **Trade-off**              | Minor precision loss at boundaries (eventual consistency with geohash) | Acceptable for social feed latency |
