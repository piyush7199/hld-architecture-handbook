# 2.1.1 RDBMS Deep Dive: SQL and the ACID Guarantees

## Intuitive Explanation

Relational Database Management Systems (RDBMS) like PostgreSQL and MySQL are like a highly organized, trustworthy
accountant's ledger. They use tables (like spreadsheets) linked by relationships. Their core promise is trust and
consistency, enforced by the ACID properties.

- SQL (Structured Query Language): The universal language for talking to these databases.
- ACID: The absolute guarantee that your data is always valid, even if the power goes out mid-transaction. This makes
  them ideal for financial systems and inventory management.

---

## In-Depth Analysis

### 1. Relational Model and Joins

RDBMS stores data in normalized tables, meaning data is split into multiple tables to eliminate redundancy (e.g.,
separating user details from order details).

- **Normalization:** Reduces data duplication, saving space and ensuring that updates only need to happen in one place.
- **Joins:** Used to reconstruct the complete data (User + Order + Item) by linking tables using Foreign Keys. Joins are
  powerful but can become very slow at scale.

### 2. The ACID Properties (The Trust Contract)

ACID is an acronym defining the properties of database transactions, ensuring data remains valid despite errors,
failures, or concurrent access.

| Property    | Definition                                                                                                                              | Intuition                                                                                                                  |
|-------------|-----------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------|
| Atomicity   | A transaction is treated as a single, indivisible unit. Either all of the changes succeed, or none of them do.                          | If you transfer money, the deduction and the credit must both succeed; otherwise, the whole transfer is cancelled.         |
| Consistency | The database must move from one valid state to another valid state. Transactions that violate database rules (constraints) are aborted. | You cannot write a negative number into an inventory column that is defined as unsigned.                                   |
| Isolation   | Concurrent transactions must appear to execute sequentially. One transaction's intermediate state is hidden from others.                | Two users trying to buy the last iPhone see the stock count of 1 sequentially, not simultaneously, preventing overselling. |
| Durability  | Once a transaction is committed, it remains permanently recorded, even if the system crashes or loses power immediately after.          | The confirmation receipt you get for your order means the change is written to persistent storage (usually the disk).      |

### 3. Transactions and Isolation Levels

A Transaction is a sequence of database operations grouped together as a single logical unit of work. Isolation is
enforced through Isolation Levels:

- **Read Uncommitted**:
    - **Definition**: Transactions can read uncommitted changes from other transactions.
    - **How It Works**: Allows "`dirty reads`", where a transaction sees uncommitted data that may be rolled back.
    - **Examples**: Rarely used; supported in MySQL, SQL Server.
    - **Use Cases**: Non-critical reporting where speed is prioritized.
    - **Issues**: High risk of inconsistent data.
    - **Trade-offs**:
        - **Pros**: Minimal locking, high concurrency.
        - **Cons**: Risk of reading incorrect data.

- **Read Committed**:
    - **Definition**: Transactions only read committed data, but non-repeatable reads and phantom reads are possible.
    - **How It Works**: Ensures no dirty reads, but data may change between reads within a transaction.
    - **Examples**: Default in PostgreSQL, SQL Server, Oracle.
    - **Use Cases**: General-purpose applications (e.g., user profile updates).
    - **Issues**:
        - **Non-repeatable reads**: Data read twice in a transaction may differ.
        - **Phantom reads**: New rows may appear during a transaction.
    - **Trade-offs**:
        - **Pros**: Balances consistency and performance.
        - **Cons**: Inconsistent reads within a transaction.

- **Repeatable Read**:
    - **Definition**: Ensures consistent reads within a transaction, but phantom reads are possible.
    - **How It Works**: Locks read data to prevent updates by other transactions.
    - **Examples**: Default in MySQL (InnoDB); supported in PostgreSQL.
    - **Use Cases**: Applications needing stable reads (e.g., financial reports).
    - **Issues**: Phantom reads (new rows inserted by other transactions).
    - **Trade-offs**:
        - **Pros**: Stronger consistency than Read Committed.
        - **Cons**: Increased locking, potential deadlocks.

- **Serializable**:
    - **Definition**: Transactions execute as if run sequentially, preventing all anomalies.
    - **How It Works**: Uses strict locking or multiversion concurrency control (MVCC) to ensure complete isolation.
    - **Examples**: Supported in PostgreSQL, MySQL, Oracle.
    - **Use Cases**: Critical systems (e.g., banking, inventory control).
    - **Issues**: Lowest concurrency due to heavy locking.
    - **Trade-offs**:
        - **Pros**: Maximum consistency, no anomalies.
        - **Cons**: High latency, risk of deadlocks, reduced throughput.

### 4. Common Anomalies

- **Dirty Reads**: Reading uncommitted data that may be rolled back.
- **Non-repeatable Reads**: Data changes between reads within a transaction.
- **Phantom Reads**: New rows appear during a transaction due to inserts by other transactions.
- **Lost Updates**: Concurrent transactions overwrite each other‚Äôs changes.

### 5. Implementation Techniques

- **Locking**: Uses shared (read) or exclusive (write) locks to enforce isolation.
    - Example: MySQL‚Äôs Repeatable Read uses row-level locks.
- **Multiversion Concurrency Control (MVCC)**:
    - Creates data snapshots for transactions to read consistent versions.
    - Example: PostgreSQL uses MVCC for Read Committed and Repeatable Read.
- **Trade-offs**:
    - Locking: Simple but risks deadlocks and contention.
    - MVCC: Improves concurrency but increases storage for versioned data.

---

## üí° Use Cases and Scaling Trade-offs

| Use Case                    | Rationale                                                               | Scaling Challenge                                                                                                                               |
|-----------------------------|-------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------|
| Financial/Banking Ledgers   | Requires absolute ACID compliance (especially Atomicity and Isolation). | **High Write Contention:** Concurrent updates to bank balances or inventory require heavy locking, severely limiting write throughput.          |
| User Authentication/Profile | Strong consistency is required for password and core profile data.      | **Vertical Scaling:** Traditional RDBMS scales primarily by getting a bigger server (vertical scaling), which has physical and cost limits.**** |

---

## ‚úèÔ∏è Design Challenge

### Problem

You are designing the back-end for an auction site where millions of users might bid on a single item. Every bid is a
database write. If you use a traditional RDBMS for the bidding ledger, which Isolation Level would you choose to prevent
bids from disappearing or conflicting, and what is the direct performance cost of this choice?

### Solution

#### üß© Scenario

- System: Auction site
- Action: Millions of concurrent bids on a single item
- Requirement:
    - Every bid must be recorded (no lost updates or conflicts)
    - Prevent inconsistent or missing data in the bidding ledger

#### ‚úÖ Goal

Prevent:

- Lost updates (two concurrent bids overwriting each other)
- Phantom reads / write conflicts
- Duplicate or missing bids

So we need strong consistency in the write path.

#### ‚öôÔ∏è Isolation Level Choice: SERIALIZABLE

Why SERIALIZABLE

- It‚Äôs the strongest isolation level ‚Äî transactions behave as if executed one at a time (serially), even though they
  actually run concurrently.
  This ensures:
- Every bid is fully isolated.
- No two concurrent bids will see or overwrite each other‚Äôs intermediate state.
- The bidding ledger remains consistent and linearizable ‚Äî no disappearing bids or race conditions.

#### ‚ö†Ô∏è Performance Cost: Concurrency & Throughput Drop

| Impact                     | Description                                                                                           |
|----------------------------|-------------------------------------------------------------------------------------------------------|
| **Lock contention**        | SERIALIZABLE isolation requires strict read/write locks or validation, blocking concurrent bidders.   |
| **Transaction retries**    | Many transactions will abort and retry due to serialization conflicts.                                |
| **Reduced throughput**     | Heavy contention (millions of bids) ‚Üí major latency increase and lower QPS.                           |
| **Scalability bottleneck** | Traditional RDBMS might not horizontally scale under this isolation level for such high write volume. |

#### üß† Practical Real-World Approach

In real systems (like eBay or Amazon Auctions), they often:

- Use Optimistic Concurrency Control (OCC) or
- A **message queue + event** sourcing architecture,

so that bids are serialized by design without blocking all transactions.

#### ‚úÖ Final Answer

| Aspect               | Decision                                                                                                        |
|----------------------|-----------------------------------------------------------------------------------------------------------------|
| **Isolation Level**  | **SERIALIZABLE**                                                                                                |
| **Why**              | Ensures no lost or conflicting bids ‚Äî provides full transaction correctness.                                    |
| **Performance Cost** | Severe ‚Äî high lock contention, frequent rollbacks, and reduced throughput due to serialization of transactions. |
