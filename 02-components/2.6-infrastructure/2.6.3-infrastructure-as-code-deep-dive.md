# 2.6.3 Infrastructure as Code Deep Dive: Terraform, CloudFormation, and Pulumi

## Intuitive Explanation

Imagine building a house. Instead of manually hiring contractors, buying materials, and coordinating everything yourself, you write a **blueprint (Infrastructure as Code)** that describes exactly what you want. A system reads the blueprint and automatically builds the house exactly as specified.

**In cloud infrastructure:**
- **Infrastructure as Code (IaC):** Write code to define infrastructure (servers, databases, networks)
- **Goal:** Automate infrastructure provisioning, ensure consistency, enable version control
- **Benefit:** Reproducible infrastructure, faster deployments, reduced human error

**Key Tools:**
- **Terraform:** Multi-cloud infrastructure provisioning
- **CloudFormation:** AWS-native infrastructure as code
- **Pulumi:** Infrastructure as code using general-purpose languages

---

## In-Depth Analysis

### 1. What is Infrastructure as Code?

**Infrastructure as Code (IaC)** is the practice of managing and provisioning infrastructure through machine-readable definition files, rather than through manual processes.

**Key Principles:**
- **Declarative:** Describe desired state, not steps to achieve it
- **Idempotent:** Running same code multiple times produces same result
- **Version Controlled:** Infrastructure code in Git (track changes, rollback)
- **Automated:** No manual steps (fully automated provisioning)

**Benefits:**
- **Consistency:** Same infrastructure every time
- **Speed:** Deploy infrastructure in minutes (vs hours/days manually)
- **Documentation:** Code serves as documentation
- **Collaboration:** Team can review and approve changes
- **Disaster Recovery:** Recreate infrastructure from code

### 2. Infrastructure as Code vs. Manual Provisioning

| Aspect | Manual Provisioning | Infrastructure as Code |
|--------|-------------------|----------------------|
| **Speed** | Hours/Days | Minutes |
| **Consistency** | Human error prone | Consistent every time |
| **Version Control** | No tracking | Git version control |
| **Reproducibility** | Difficult | Easy (same code = same result) |
| **Scalability** | Doesn't scale | Scales automatically |
| **Documentation** | Outdated docs | Code is documentation |

### 3. Major IaC Tools

#### Terraform

**Architecture:**
- **Declarative Language:** HCL (HashiCorp Configuration Language)
- **Multi-Cloud:** Supports AWS, GCP, Azure, and 100+ providers
- **State Management:** Tracks infrastructure state
- **Plan/Apply:** Preview changes before applying

**Key Features:**
- **Providers:** 100+ cloud providers and services
- **Modules:** Reusable infrastructure components
- **State File:** Tracks current infrastructure state
- **Plan:** Preview changes before applying
- **Workspaces:** Multiple environments (dev, staging, prod)

**Example:**
```hcl
resource "aws_instance" "web" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t2.micro"
  
  tags = {
    Name = "WebServer"
  }
}
```

#### AWS CloudFormation

**Architecture:**
- **AWS-Native:** Built by AWS, only works with AWS
- **JSON/YAML:** Template format
- **Stack Management:** Manages related resources as a stack
- **Rollback:** Automatic rollback on failure

**Key Features:**
- **Templates:** JSON or YAML format
- **Stacks:** Group related resources
- **Change Sets:** Preview changes before applying
- **Drift Detection:** Detect manual changes
- **Nested Stacks:** Reusable stack components

**Example:**
```yaml
Resources:
  WebServer:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: ami-0c55b159cbfafe1f0
      InstanceType: t2.micro
      Tags:
        - Key: Name
          Value: WebServer
```

#### Pulumi

**Architecture:**
- **General-Purpose Languages:** Python, TypeScript, Go, C#
- **Multi-Cloud:** Supports AWS, GCP, Azure, Kubernetes
- **State Management:** Cloud or local state
- **Type Safety:** Compile-time type checking

**Key Features:**
- **Languages:** Use familiar programming languages
- **Type Safety:** Catch errors at compile time
- **Testing:** Write unit tests for infrastructure
- **Components:** Reusable infrastructure components
- **State Backend:** Cloud or local state storage

**Example (TypeScript):**
```typescript
import * as aws from "@pulumi/aws";

const webServer = new aws.ec2.Instance("web", {
    ami: "ami-0c55b159cbfafe1f0",
    instanceType: "t2.micro",
    tags: {
        Name: "WebServer",
    },
});
```

### 4. Terraform Deep Dive

#### A. Core Concepts

**Resources:**
```
Resource: Represents infrastructure component
  - Example: AWS EC2 instance, S3 bucket, RDS database
  - Defined in .tf files
```

**Providers:**
```
Provider: Plugin that interacts with cloud/service
  - Example: aws, google, azurerm
  - Handles API calls to create/update/delete resources
```

**State:**
```
State: Tracks current infrastructure
  - Stored in state file (terraform.tfstate)
  - Maps resources to real infrastructure
  - Used to determine what to create/update/delete
```

**Modules:**
```
Module: Reusable infrastructure component
  - Example: VPC module, database module
  - Promotes code reuse
  - Encapsulates complexity
```

#### B. Terraform Workflow

**1. Initialize:**
```
terraform init
‚Üí Downloads providers
‚Üí Initializes backend
```

**2. Plan:**
```
terraform plan
‚Üí Compares desired state (code) with current state
‚Üí Shows what will be created/updated/deleted
‚Üí No changes made (dry run)
```

**3. Apply:**
```
terraform apply
‚Üí Creates/updates/deletes resources
‚Üí Updates state file
‚Üí Infrastructure matches code
```

**4. Destroy:**
```
terraform destroy
‚Üí Destroys all resources
‚Üí Useful for cleanup
```

#### C. State Management

**Local State:**
```
State stored in local file (terraform.tfstate)
‚Üí Simple for single developer
‚Üí Problem: Doesn't work for teams
```

**Remote State:**
```
State stored in remote backend (S3, Consul, etcd)
‚Üí Shared state for teams
‚Üí State locking (prevent concurrent modifications)
‚Üí Versioning (track state history)
```

**State Backend (S3):**
```
Backend Configuration:
  backend "s3" {
    bucket = "terraform-state"
    key    = "prod/terraform.tfstate"
    region = "us-east-1"
    dynamodb_table = "terraform-locks"  # State locking
  }
```

#### D. Modules

**Module Structure:**
```
modules/vpc/
  ‚îú‚îÄ‚îÄ main.tf        # Resources
  ‚îú‚îÄ‚îÄ variables.tf   # Input variables
  ‚îú‚îÄ‚îÄ outputs.tf     # Output values
  ‚îî‚îÄ‚îÄ README.md      # Documentation
```

**Using Modules:**
```hcl
module "vpc" {
  source = "./modules/vpc"
  
  vpc_cidr = "10.0.0.0/16"
  environment = "production"
}

output "vpc_id" {
  value = module.vpc.vpc_id
}
```

### 5. Infrastructure Patterns

#### A. Environment Separation

**Pattern:** Separate infrastructure for dev, staging, prod

```
terraform/
  ‚îú‚îÄ‚îÄ environments/
  ‚îÇ   ‚îú‚îÄ‚îÄ dev/
  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ terraform.tfvars
  ‚îÇ   ‚îú‚îÄ‚îÄ staging/
  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ terraform.tfvars
  ‚îÇ   ‚îî‚îÄ‚îÄ prod/
  ‚îÇ       ‚îî‚îÄ‚îÄ terraform.tfvars
  ‚îî‚îÄ‚îÄ modules/
      ‚îî‚îÄ‚îÄ app/
          ‚îî‚îÄ‚îÄ main.tf
```

**Terraform Workspaces:**
```
terraform workspace new dev
terraform workspace new staging
terraform workspace new prod

terraform workspace select dev
terraform apply
```

#### B. Multi-Region Deployment

**Pattern:** Deploy same infrastructure to multiple regions

```
module "us_east" {
  source = "./modules/app"
  region = "us-east-1"
}

module "us_west" {
  source = "./modules/app"
  region = "us-west-2"
}
```

#### C. Infrastructure Layering

**Pattern:** Separate infrastructure into layers

```
Layer 1: Network (VPC, subnets, routing)
Layer 2: Security (Security groups, IAM)
Layer 3: Compute (EC2, ECS, Lambda)
Layer 4: Data (RDS, ElastiCache, S3)
```

### 6. Best Practices

#### A. Version Control

**Git Workflow:**
```
1. Infrastructure code in Git
2. Feature branches for changes
3. Code review before merge
4. Automated testing (terraform validate, plan)
5. Merge to main ‚Üí Deploy to production
```

#### B. State Management

**Remote State:**
```
‚úÖ Good:
  - Remote state (S3, Consul)
  - State locking (DynamoDB)
  - State versioning
  - Encrypted state

‚ùå Bad:
  - Local state file
  - State in Git (contains secrets)
  - No state locking
```

#### C. Secrets Management

**Secrets:**
```
‚úÖ Good:
  - Use secrets manager (Vault, AWS Secrets Manager)
  - Reference secrets in Terraform (don't hardcode)
  - Rotate secrets regularly

‚ùå Bad:
  - Hardcode secrets in code
  - Commit secrets to Git
  - Store secrets in state file
```

#### D. Resource Tagging

**Tagging Strategy:**
```
Tags:
  - Environment: dev/staging/prod
  - Project: project-name
  - ManagedBy: Terraform
  - CostCenter: department
```

### 7. Terraform vs. CloudFormation vs. Pulumi

| Aspect | Terraform | CloudFormation | Pulumi |
|--------|----------|----------------|--------|
| **Language** | HCL | JSON/YAML | Python/TypeScript/Go |
| **Cloud Support** | Multi-cloud | AWS only | Multi-cloud |
| **State Management** | Explicit state file | AWS-managed | Cloud or local |
| **Learning Curve** | Medium | Easy (AWS) | Medium (if know language) |
| **Type Safety** | Runtime | Runtime | Compile-time |
| **Testing** | Limited | Limited | Full (unit tests) |
| **Community** | Large | Large (AWS) | Growing |

---

## When to Use Infrastructure as Code

### ‚úÖ Use Infrastructure as Code When:

1. **Reproducible Infrastructure:** Need consistent environments
2. **Multiple Environments:** Dev, staging, prod (avoid manual setup)
3. **Team Collaboration:** Multiple people managing infrastructure
4. **Disaster Recovery:** Need to recreate infrastructure quickly
5. **Compliance:** Need audit trail of infrastructure changes
6. **Scalability:** Need to provision infrastructure at scale

### ‚ùå Don't Use Infrastructure as Code When:

1. **One-Time Setup:** Infrastructure set up once and never changes
2. **Very Simple:** Single server, no complexity
3. **Learning/Experimentation:** Exploring cloud services (manual is faster)
4. **Legacy Systems:** Existing manual infrastructure (migration cost)

---

## Real-World Examples

### HashiCorp (Terraform)

**Use Case:** Managing infrastructure for HashiCorp Cloud

**Architecture:**
- Terraform for all infrastructure
- Multi-cloud (AWS, GCP)
- Automated deployments
- Infrastructure version controlled

**Scale:**
- Thousands of resources
- Multiple regions
- Automated scaling

### Netflix (Spinnaker + Terraform)

**Use Case:** Infrastructure and application deployment

**Architecture:**
- Terraform for infrastructure
- Spinnaker for application deployment
- Infrastructure as code for all environments

**Scale:**
- Millions of customers
- Global infrastructure
- High availability

### GitHub (Terraform)

**Use Case:** Managing GitHub infrastructure

**Architecture:**
- Terraform for all infrastructure
- Multi-region deployment
- Automated provisioning
- Infrastructure version controlled

---

## Common Anti-Patterns

### ‚ùå **1. Storing Secrets in Code**

**Problem:** Hardcoding passwords, API keys in Terraform

**Solution:** Use secrets manager

```
‚ùå Bad:
variable "db_password" {
  default = "secret123"  # Hardcoded in code
}

‚úÖ Good:
data "aws_secretsmanager_secret_version" "db" {
  secret_id = "database-password"
}

resource "aws_db_instance" "db" {
  password = data.aws_secretsmanager_secret_version.db.secret_string
}
```

### ‚ùå **2. No State Management**

**Problem:** Local state file, no remote state

**Solution:** Use remote state with locking

```
‚ùå Bad:
terraform.tfstate (local file)
‚Üí Doesn't work for teams
‚Üí No state locking
‚Üí Risk of state corruption

‚úÖ Good:
Backend: S3 + DynamoDB (locking)
‚Üí Shared state
‚Üí State locking
‚Üí Versioning
```

### ‚ùå **3. No Code Review**

**Problem:** Direct changes to production infrastructure

**Solution:** Use Git workflow with code review

```
‚ùå Bad:
Developer ‚Üí Direct terraform apply to production
‚Üí No review
‚Üí Risk of breaking production

‚úÖ Good:
Developer ‚Üí Git branch ‚Üí Pull request ‚Üí Review ‚Üí Merge ‚Üí Deploy
‚Üí Code review
‚Üí Automated testing
‚Üí Safe deployment
```

---

## Trade-offs Summary

| Aspect | What You Gain | What You Sacrifice |
|--------|---------------|-------------------|
| **Infrastructure as Code** | Consistency, speed, version control | Learning curve, initial setup time |
| **Terraform** | Multi-cloud, large community | HCL learning curve |
| **CloudFormation** | AWS-native, integrated | AWS-only, JSON/YAML verbose |
| **Pulumi** | Type safety, testing, familiar languages | Smaller community, newer tool |

---

## References

- **Terraform Documentation:** [https://www.terraform.io/docs](https://www.terraform.io/docs)
- **AWS CloudFormation:** [https://docs.aws.amazon.com/cloudformation/](https://docs.aws.amazon.com/cloudformation/)
- **Pulumi Documentation:** [https://www.pulumi.com/docs/](https://www.pulumi.com/docs/)
- **Related Chapters:**
  - [2.6.1 Kubernetes and Docker Deep Dive](./2.6.1-kubernetes-docker-deep-dive.md) - Infrastructure orchestration
  - [2.6.2 Configuration Management Deep Dive](./2.6.2-configuration-management-deep-dive.md) - Configuration vs infrastructure

---

## ‚úèÔ∏è Design Challenge

### Problem

You are designing infrastructure for a microservices platform that must:

1. **Deploy to 3 environments** (dev, staging, prod)
2. **Support 50 microservices** (each needs: ECS service, ALB, RDS database)
3. **Multi-region deployment** (us-east-1, us-west-2, eu-west-1)
4. **Automated provisioning** (CI/CD pipeline)
5. **Version controlled** (Git workflow with code review)
6. **Disaster recovery** (recreate infrastructure from code)

**Constraints:**
- Infrastructure changes 50 times per week
- Need to provision new environments quickly (<30 minutes)
- Multiple teams managing infrastructure
- Must prevent manual changes (enforce IaC)

Design an Infrastructure as Code strategy that:
- Supports multiple environments
- Handles 50 microservices
- Supports multi-region
- Enables automated provisioning
- Ensures version control
- Prevents manual changes

### Solution

#### üß© Scenario

- **Environments:** 3 (dev, staging, prod)
- **Services:** 50 microservices
- **Regions:** 3 (us-east-1, us-west-2, eu-west-1)
- **Infrastructure Changes:** 50 per week
- **Provisioning Time:** <30 minutes

**Calculations:**
- **Total Resources:** 50 services √ó 3 envs √ó 3 regions = 450 service deployments
- **Infrastructure Components:** 450 √ó 3 (ECS, ALB, RDS) = 1,350 resources
- **State Management:** Need remote state with locking

#### ‚úÖ Step 1: IaC Tool Choice

**Choice: Terraform**

**Why:**
- **Multi-Cloud:** Supports AWS (current) + future GCP/Azure
- **Large Community:** Extensive modules, documentation
- **State Management:** Robust state management (S3 + DynamoDB)
- **Modules:** Reusable modules for microservices
- **CI/CD Integration:** Works well with CI/CD pipelines

#### ‚úÖ Step 2: Project Structure

**Directory Structure:**
```
terraform/
  ‚îú‚îÄ‚îÄ environments/
  ‚îÇ   ‚îú‚îÄ‚îÄ dev/
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.tf
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ variables.tf
  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ terraform.tfvars
  ‚îÇ   ‚îú‚îÄ‚îÄ staging/
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.tf
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ variables.tf
  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ terraform.tfvars
  ‚îÇ   ‚îî‚îÄ‚îÄ prod/
  ‚îÇ       ‚îú‚îÄ‚îÄ main.tf
  ‚îÇ       ‚îú‚îÄ‚îÄ variables.tf
  ‚îÇ       ‚îî‚îÄ‚îÄ terraform.tfvars
  ‚îú‚îÄ‚îÄ modules/
  ‚îÇ   ‚îú‚îÄ‚îÄ vpc/
  ‚îÇ   ‚îú‚îÄ‚îÄ ecs-service/
  ‚îÇ   ‚îú‚îÄ‚îÄ alb/
  ‚îÇ   ‚îî‚îÄ‚îÄ rds/
  ‚îî‚îÄ‚îÄ shared/
      ‚îî‚îÄ‚îÄ backend.tf
```

#### ‚úÖ Step 3: Module Design

**ECS Service Module:**
```
modules/ecs-service/
  ‚îú‚îÄ‚îÄ main.tf          # ECS service, task definition
  ‚îú‚îÄ‚îÄ variables.tf     # Input variables
  ‚îú‚îÄ‚îÄ outputs.tf       # Output values
  ‚îî‚îÄ‚îÄ README.md        # Documentation
```

**Module Usage:**
```hcl
module "user_service" {
  source = "../../modules/ecs-service"
  
  service_name = "user-service"
  image = "user-service:latest"
  cpu = 256
  memory = 512
  desired_count = 3
  
  environment = var.environment
  region = var.region
}
```

**Reusability:**
```
50 services √ó same module = Consistent infrastructure
‚Üí Change module once ‚Üí All services updated
‚Üí Reduces code duplication
```

#### ‚úÖ Step 4: Multi-Environment Strategy

**Environment-Specific Configuration:**
```
environments/dev/terraform.tfvars:
  environment = "dev"
  instance_type = "t2.small"
  desired_count = 1
  multi_az = false

environments/prod/terraform.tfvars:
  environment = "prod"
  instance_type = "t3.large"
  desired_count = 5
  multi_az = true
```

**Workspace Strategy:**
```
terraform workspace new dev
terraform workspace new staging
terraform workspace new prod

terraform workspace select dev
terraform apply -var-file="environments/dev/terraform.tfvars"
```

#### ‚úÖ Step 5: Multi-Region Deployment

**Region Modules:**
```
module "us_east" {
  source = "./modules/region"
  region = "us-east-1"
  environment = var.environment
  services = var.services
}

module "us_west" {
  source = "./modules/region"
  region = "us-west-2"
  environment = var.environment
  services = var.services
}

module "eu_west" {
  source = "./modules/region"
  region = "eu-west-1"
  environment = var.environment
  services = var.services
}
```

**State Management (Per Region):**
```
Backend Configuration:
  backend "s3" {
    bucket = "terraform-state-${var.environment}"
    key    = "${var.region}/terraform.tfstate"
    region = var.region
    dynamodb_table = "terraform-locks-${var.region}"
  }
```

#### ‚úÖ Step 6: State Management

**Remote State (S3 + DynamoDB):**
```
S3 Buckets (per environment):
  - terraform-state-dev
  - terraform-state-staging
  - terraform-state-prod

DynamoDB Tables (per region):
  - terraform-locks-us-east-1
  - terraform-locks-us-west-2
  - terraform-locks-eu-west-1

State Locking:
  - Prevents concurrent modifications
  - DynamoDB table stores lock
  - Lock released after apply completes
```

**State Versioning:**
```
S3 Versioning:
  - Enable versioning on state buckets
  - Track state history
  - Rollback to previous state if needed
```

#### ‚úÖ Step 7: CI/CD Integration

**GitHub Actions Workflow:**
```
Workflow:
  1. Developer pushes code to Git
  2. GitHub Actions triggers
  3. terraform fmt (format code)
  4. terraform validate (validate syntax)
  5. terraform plan (preview changes)
  6. Code review (pull request)
  7. Merge to main
  8. terraform apply (deploy to environment)
```

**Pipeline Stages:**
```
Stage 1: Development
  - Developer ‚Üí Feature branch ‚Üí Pull request
  - Automated: terraform validate, plan
  - Manual: Code review

Stage 2: Staging
  - Merge to main ‚Üí Auto-deploy to staging
  - terraform apply (staging environment)
  - Automated testing

Stage 3: Production
  - Manual approval ‚Üí Deploy to production
  - terraform apply (prod environment)
  - Monitoring and rollback if needed
```

#### ‚úÖ Step 8: Preventing Manual Changes

**AWS Config Rules:**
```
Config Rule: "prevent-manual-changes"
  - Monitors infrastructure changes
  - Detects changes not from Terraform
  - Alerts on manual changes
  - Optionally: Auto-revert manual changes
```

**Resource Tagging:**
```
Tags:
  - ManagedBy: Terraform
  - Environment: dev/staging/prod
  - Region: us-east-1/us-west-2/eu-west-1

Filter Resources:
  - Only manage resources with ManagedBy=Terraform tag
  - Ignore manually created resources
```

**IAM Policies:**
```
IAM Policy: "terraform-only"
  - Allow: terraform service role
  - Deny: All other users (prevent manual changes)
  - Exception: Read-only access for monitoring
```

#### ‚úÖ Step 9: Disaster Recovery

**Infrastructure Recreation:**
```
Disaster Recovery Plan:
  1. Infrastructure destroyed (disaster)
  2. Git repository intact (code preserved)
  3. State file in S3 (may be lost, but code has desired state)
  4. Run: terraform init (download providers)
  5. Run: terraform apply (recreate infrastructure)
  6. Result: Infrastructure restored in <30 minutes
```

**State Backup:**
```
State Backup Strategy:
  - S3 versioning (automatic backups)
  - Cross-region replication (backup state to another region)
  - Daily state exports (backup to separate bucket)
```

#### ‚úÖ Complete Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              Git Repository (GitHub)                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ terraform/                                       ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ   ‚îú‚îÄ‚îÄ environments/ (dev, staging, prod)        ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ   ‚îî‚îÄ‚îÄ modules/ (vpc, ecs-service, alb, rds)     ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ   CI/CD Pipeline            ‚îÇ
        ‚îÇ   (GitHub Actions)           ‚îÇ
        ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
        ‚îÇ   ‚îÇ 1. terraform validate ‚îÇ  ‚îÇ
        ‚îÇ   ‚îÇ 2. terraform plan     ‚îÇ  ‚îÇ
        ‚îÇ   ‚îÇ 3. Code review        ‚îÇ  ‚îÇ
        ‚îÇ   ‚îÇ 4. terraform apply    ‚îÇ  ‚îÇ
        ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ   Terraform State            ‚îÇ
        ‚îÇ   (S3 + DynamoDB)            ‚îÇ
        ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
        ‚îÇ   ‚îÇ - State files        ‚îÇ  ‚îÇ
        ‚îÇ   ‚îÇ - State locking      ‚îÇ  ‚îÇ
        ‚îÇ   ‚îÇ - State versioning   ‚îÇ  ‚îÇ
        ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ   AWS Infrastructure         ‚îÇ
        ‚îÇ   (3 Regions, 3 Environments)‚îÇ
        ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
        ‚îÇ   ‚îÇ - 50 ECS Services     ‚îÇ  ‚îÇ
        ‚îÇ   ‚îÇ - 50 ALBs            ‚îÇ  ‚îÇ
        ‚îÇ   ‚îÇ - 50 RDS Databases   ‚îÇ  ‚îÇ
        ‚îÇ   ‚îÇ - VPCs, Subnets, etc.‚îÇ  ‚îÇ
        ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Deployment Flow:**
```
1. Developer ‚Üí Git: Push infrastructure changes
2. GitHub Actions ‚Üí Trigger: terraform validate, plan
3. Pull Request ‚Üí Code review
4. Merge to main ‚Üí Trigger: terraform apply (staging)
5. Manual approval ‚Üí terraform apply (production)
6. Infrastructure ‚Üí Updated in <30 minutes
```

#### ‚öñÔ∏è Trade-offs Summary

| Decision | What We Gain | What We Sacrifice |
|----------|--------------|-------------------|
| **Terraform** | Multi-cloud, large community | HCL learning curve |
| **Modules** | Code reuse, consistency | Initial module development time |
| **Remote State** | Team collaboration, locking | S3/DynamoDB costs |
| **Multi-Region** | High availability | State management complexity |
| **CI/CD Integration** | Automated deployments | Pipeline setup complexity |

#### ‚úÖ Final Summary

**Infrastructure as Code Strategy:**
- **Tool:** Terraform (multi-cloud, large community)
- **Structure:** Environments (dev/staging/prod) + Modules (reusable)
- **State:** S3 + DynamoDB (remote state with locking)
- **Regions:** 3 regions (us-east-1, us-west-2, eu-west-1)
- **CI/CD:** GitHub Actions (automated validation, plan, apply)
- **Governance:** IAM policies, AWS Config (prevent manual changes)

**Performance:**
- **Provisioning Time:** <30 minutes (meets requirement)
- **Infrastructure Changes:** 50 per week (handled by CI/CD)
- **Disaster Recovery:** <30 minutes (recreate from code)
- **Consistency:** Same infrastructure every time (modules)

**Result:**
- ‚úÖ Supports 3 environments (dev, staging, prod)
- ‚úÖ Handles 50 microservices (reusable modules)
- ‚úÖ Multi-region deployment (3 regions)
- ‚úÖ Automated provisioning (CI/CD pipeline)
- ‚úÖ Version controlled (Git workflow)
- ‚úÖ Prevents manual changes (IAM, AWS Config)
- ‚úÖ Disaster recovery (<30 minutes)

