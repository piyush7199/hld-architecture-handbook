# 3.5.1 Design a Payment Gateway (Stripe / PayPal)

> üìö **Note on Implementation Details:**
> This document focuses on high-level design concepts and architectural decisions.
> For detailed algorithm implementations, see **[pseudocode.md](./pseudocode.md)**.

## üìä Visual Diagrams & Resources

- **[High-Level Design Diagrams](./hld-diagram.md)** - System architecture, component design, data flow
- **[Sequence Diagrams](./sequence-diagrams.md)** - Detailed interaction flows and failure scenarios
- **[Design Decisions (This Over That)](./this-over-that.md)** - In-depth analysis of architectural choices
- **[Pseudocode Implementations](./pseudocode.md)** - Detailed algorithm implementations

---

## 1. Problem Statement

Design a **payment gateway** like Stripe or PayPal that securely processes credit card transactions for e-commerce
platforms. The system must handle authorization, capture, refunds, and chargebacks while maintaining **ACID guarantees
**, **PCI-DSS compliance**, and **idempotency** to prevent duplicate charges.

**Key Challenges:**

- **Financial Integrity**: Guarantee exactly-once payment processing (no double charges)
- **Security**: Protect sensitive card data, comply with PCI-DSS Level 1
- **Latency**: Process payments in under 500ms
- **Availability**: 99.99% uptime (critical path for all transactions)
- **Fraud Prevention**: Detect and block fraudulent transactions in real-time
- **Auditability**: Maintain immutable ledger for reconciliation

---

## 2. Requirements and Scale Estimation

### Functional Requirements (FRs)

1. **Transaction Processing**: Accept, authorize, and capture credit card payments
2. **Idempotency**: Guarantee exactly-once processing using idempotency keys
3. **Refunds/Chargebacks**: Support reversing or disputing transactions
4. **Multi-Currency**: Handle payments in 150+ currencies
5. **Webhooks**: Notify merchants of payment events asynchronously
6. **Compliance**: Adhere to PCI-DSS, GDPR, SOC 2 regulations

### Non-Functional Requirements (NFRs)

1. **Strong Consistency**: Financial ledgers must be ACID compliant
2. **High Availability**: 99.99% uptime (4 nines = 52 minutes downtime/year)
3. **Low Latency**: < 500ms for authorization, < 200ms for token generation
4. **Security**: End-to-end encryption, tokenization, zero-trust architecture
5. **Auditability**: Immutable transaction logs, full audit trails

### Scale Estimation

| Metric                    | Assumption               | Calculation                           | Result                                           |
|---------------------------|--------------------------|---------------------------------------|--------------------------------------------------|
| **Peak Throughput**       | Black Friday traffic     | 20,000 QPS                            | $20 \text{k}$ $\text{API}$ $\text{requests/sec}$ |
| **Daily Transactions**    | Average processing       | $20 \text{k} \times 86400 \times 0.1$ | ~170M transactions/day                           |
| **Transaction Storage**   | 10 years retention       | $170 \text{M} \times 365 \times 10$   | 620 billion transactions                         |
| **Data Volume**           | 1 KB per transaction     | $620 \text{B} \times 1 \text{KB}$     | 620 TB storage                                   |
| **Authorization Latency** | To bank and back         | Network + processing                  | < 500ms target                                   |
| **Database Write Load**   | Every transaction logged | $20 \text{k}$ writes/sec peak         | Requires sharded RDBMS                           |

**Cost of Downtime**: For a gateway processing $10M transactions/day at 2.9% fee:

- Revenue: $290k/day √ó 2.9% = ~$8.4k/day
- Downtime cost: **$350/minute** ($5.8/second)

---

## 3. High-Level Architecture

The architecture centers around a **dual-phase commit** (authorization ‚Üí capture), **idempotency layer**, and *
*immutable ledger** for financial integrity.

### Core Components

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                         Merchant Website                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ
                       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                       API Gateway (TLS)                           ‚îÇ
‚îÇ         Rate Limiting ‚Ä¢ Authentication ‚Ä¢ Load Balancing           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ              ‚îÇ              ‚îÇ
        ‚ñº              ‚ñº              ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Tokenization ‚îÇ ‚îÇ  Payment   ‚îÇ ‚îÇ Fraud Detection‚îÇ
‚îÇ   Service    ‚îÇ ‚îÇ  Service   ‚îÇ ‚îÇ    Service     ‚îÇ
‚îÇ (PCI Scope)  ‚îÇ ‚îÇ            ‚îÇ ‚îÇ   (ML-based)   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ               ‚îÇ                  ‚îÇ
       ‚îÇ               ‚ñº                  ‚îÇ
       ‚îÇ        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
       ‚îÇ        ‚îÇ Idempotency  ‚îÇ          ‚îÇ
       ‚îÇ        ‚îÇ Store (Redis)‚îÇ          ‚îÇ
       ‚îÇ        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
       ‚îÇ               ‚îÇ                  ‚îÇ
       ‚îÇ               ‚ñº                  ‚ñº
       ‚îÇ        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚îÇ        ‚îÇ   Ledger Service (Postgres)  ‚îÇ
       ‚îÇ        ‚îÇ   Sharded by Merchant ID     ‚îÇ
       ‚îÇ        ‚îÇ   ACID Transactions          ‚îÇ
       ‚îÇ        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ               ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ
                       ‚ñº
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
            ‚îÇ  Bank Processor API  ‚îÇ
            ‚îÇ  (Visa, Mastercard)  ‚îÇ
            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## 4. Detailed Component Design

### 4.1 Payment Flow: Authorization vs Capture

**Why Two Steps?**

Modern payment systems use a **two-phase commit**:

1. **Authorization**: Reserve funds ($\text{soft}$ $\text{hold}$), verify card validity
2. **Capture**: Actually transfer money (usually after shipment)

**Benefits:**

- Merchant can cancel orders before capture (no refund needed)
- Reduces risk of chargebacks (customer changed mind)
- Handles inventory checks (authorize first, capture only if in stock)

**Flow:**

```
Authorization:
  Client ‚Üí API: POST /payments {amount, card_token, idempotency_key}
  API ‚Üí Bank: "Can this card pay $100?"
  Bank ‚Üí API: "Yes, authorized (auth_code: ABC123)"
  API ‚Üí Ledger: Write AUTHORIZED status
  API ‚Üí Client: {payment_id, status: authorized}

Capture (hours/days later):
  Client ‚Üí API: POST /payments/{id}/capture
  API ‚Üí Bank: "Transfer the $100 (auth_code: ABC123)"
  Bank ‚Üí API: "Done (settlement_id: XYZ789)"
  API ‚Üí Ledger: Write CAPTURED status
  API ‚Üí Client: {status: captured}
```

*See pseudocode.md::authorize_payment() and pseudocode.md::capture_payment() for implementation*

### 4.2 Idempotency System

**The Problem**: Network failures cause retries. Without idempotency, a retry charges the customer twice.

**Solution**: Client provides `idempotency_key` (UUID). Server caches results.

**Implementation:**

```
1. Client generates UUID: "idem_abc123"
2. Server checks Redis: GET idempotency:idem_abc123
3. If exists ‚Üí return cached result (HTTP 200, same response)
4. If not exists:
   a. Process payment
   b. Store result in Redis: SET idempotency:idem_abc123 {response} EX 86400
   c. Return response
```

**Key Properties:**

- **TTL**: 24 hours (balances memory vs safety)
- **Scope**: Per merchant (merchant_A and merchant_B can use same key)
- **Storage**: Redis for speed (1ms lookup)
- **Durability**: Replicated Redis cluster (async replication OK, stale read acceptable)

*See pseudocode.md::check_idempotency() for implementation*

### 4.3 Tokenization (PCI-DSS Compliance)

**The Problem**: Storing credit card numbers is expensive (PCI-DSS Level 1 certification costs millions).

**Solution**: **Tokenization** - Replace card with non-sensitive token.

**Flow:**

```
1. Client: POST /tokens {card_number: "4111111111111111"}
2. Tokenization Service (PCI scope):
   a. Validate card (Luhn algorithm)
   b. Generate token: "tok_abc123"
   c. Encrypt card: AES-256(card_number)
   d. Store: tokens_db[tok_abc123] = encrypted_card
   e. Return token to client
3. Client: POST /payments {amount, token: "tok_abc123"}
4. Payment Service: Fetch card from tokens_db, send to bank
```

**Security:**

- **Encryption at Rest**: AES-256 with key rotation
- **Encryption in Transit**: TLS 1.3 only
- **Key Management**: AWS KMS / HashiCorp Vault (HSM-backed)
- **PCI Scope Reduction**: Only Tokenization Service handles raw cards

**Database Schema:**

```sql
CREATE TABLE tokens (
    token_id VARCHAR(32) PRIMARY KEY,  -- tok_abc123
    card_fingerprint CHAR(64),  -- SHA-256 hash for deduplication
    encrypted_card BYTEA,  -- AES-256 encrypted
    card_brand VARCHAR(20),  -- Visa, Mastercard
    last4 CHAR(4),  -- 1111 (for display)
    exp_month INT,
    exp_year INT,
    merchant_id VARCHAR(32),
    created_at TIMESTAMP DEFAULT NOW(),
    INDEX (merchant_id, created_at)
);
```

*See pseudocode.md::tokenize_card() for implementation*

### 4.4 Ledger Database Design

**Requirements:**

- **ACID Transactions**: Atomicity (all-or-nothing), Isolation (no dirty reads)
- **Immutable**: Once written, never updated (append-only)
- **Auditable**: Every state change logged
- **Reconcilable**: Match exactly with bank statements

**Choice: Sharded PostgreSQL**

**Why PostgreSQL over NoSQL?**

| Feature          | PostgreSQL                   | Cassandra                   | DynamoDB                    |
|------------------|------------------------------|-----------------------------|-----------------------------|
| **ACID**         | ‚úÖ Full ACID                  | ‚ùå Eventual consistency      | ‚ùå Eventual consistency      |
| **Transactions** | ‚úÖ Multi-row transactions     | ‚ùå Single-row only           | ‚ùå Limited transactions      |
| **Auditability** | ‚úÖ Write-ahead log (WAL)      | ‚ö†Ô∏è Harder to audit          | ‚ö†Ô∏è Harder to audit          |
| **Compliance**   | ‚úÖ Financial systems standard | ‚ùå Not recommended for money | ‚ùå Not recommended for money |

**Schema Design:**

```sql
CREATE TABLE payments (
    payment_id VARCHAR(32) PRIMARY KEY,
    merchant_id VARCHAR(32) NOT NULL,
    idempotency_key VARCHAR(64) UNIQUE,
    amount_cents BIGINT NOT NULL,  -- Store as cents (avoid floats)
    currency CHAR(3),  -- USD, EUR
    status VARCHAR(20),  -- authorized, captured, refunded, failed
    card_token VARCHAR(32),
    customer_id VARCHAR(32),
    authorization_code VARCHAR(64),  -- From bank
    captured_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    INDEX (merchant_id, created_at),
    INDEX (idempotency_key)
);

CREATE TABLE payment_events (
    event_id BIGSERIAL PRIMARY KEY,
    payment_id VARCHAR(32) NOT NULL,
    event_type VARCHAR(32),  -- authorized, captured, refunded
    previous_status VARCHAR(20),
    new_status VARCHAR(20),
    metadata JSONB,  -- Flexible for audit data
    created_at TIMESTAMP DEFAULT NOW(),
    INDEX (payment_id, created_at)
);
```

**Sharding Strategy:**

- **Shard Key**: `merchant_id` (all payments for one merchant on same shard)
- **Why Merchant ID?** Queries are always scoped to merchant (for analytics, reports)
- **Shard Count**: 64 shards (handle 20k writes/sec √∑ 64 = ~300 writes/sec per shard)
- **Replication**: 3 replicas per shard (primary + 2 read replicas)

*See pseudocode.md::write_to_ledger() for implementation*

---

## 5. Security and Compliance

### 5.1 PCI-DSS Compliance

**PCI-DSS Level 1** (6M+ transactions/year) requirements:

1. **Build and Maintain Secure Network**
    - Firewalls between public/private networks
    - Change default passwords

2. **Protect Cardholder Data**
    - Encrypt card data at rest (AES-256)
    - Encrypt card data in transit (TLS 1.3)
    - Tokenization (reduce scope)

3. **Vulnerability Management**
    - Use anti-virus software
    - Regularly update systems

4. **Access Control**
    - Restrict access to cardholder data (need-to-know basis)
    - Unique IDs for each person with access
    - Physical access controls

5. **Monitor and Test Networks**
    - Track all access to cardholder data
    - Regular security testing

6. **Information Security Policy**
    - Maintain policy for all personnel

**Implementation:**

- **Tokenization Service**: Only component in PCI scope
- **Encryption**: All card data encrypted with AES-256
- **Key Rotation**: Monthly key rotation via AWS KMS
- **Access Logs**: Every card access logged to immutable audit log
- **Network Segmentation**: Tokenization service in isolated VPC

### 5.2 Fraud Detection

**Challenge**: Detect fraudulent transactions in < 50ms (part of authorization flow).

**Solution**: Real-time ML-based risk scoring.

**Features for ML Model:**

1. **Transaction Features**:
    - Amount, currency
    - Merchant category
    - Time of day, day of week

2. **Card Features**:
    - Card brand, issuing bank
    - Previous transaction history
    - Decline rate

3. **Customer Features**:
    - Email domain, IP address
    - Billing vs shipping address mismatch
    - Velocity (transactions per hour)

4. **Behavioral Features**:
    - Deviation from normal spending pattern
    - First-time customer flag
    - VPN/proxy usage

**Model Pipeline:**

```
1. Real-Time Scoring (Synchronous):
   - Load features from cache (Redis)
   - Score with lightweight model (decision tree)
   - If risk > 0.8 ‚Üí BLOCK
   - If 0.5 < risk < 0.8 ‚Üí FLAG (manual review)
   - If risk < 0.5 ‚Üí ALLOW

2. Offline Training (Daily):
   - Kafka ‚Üí Spark ‚Üí Feature engineering
   - Train XGBoost model on labeled data
   - Deploy new model to Redis (A/B test)
```

**Risk Actions:**

- **Low Risk** (< 0.5): Auto-approve
- **Medium Risk** (0.5-0.8): 3D Secure challenge (customer verifies)
- **High Risk** (> 0.8): Block transaction

*See pseudocode.md::calculate_fraud_score() for implementation*

---

## 6. Refunds and Chargebacks

### 6.1 Refunds

**Types:**

1. **Full Refund**: Return entire amount
2. **Partial Refund**: Return portion (e.g., returned item)

**Flow:**

```
1. Merchant: POST /payments/{id}/refunds {amount}
2. Payment Service:
   a. Verify payment exists and is captured
   b. Check refund amount <= captured amount
   c. Create refund record in ledger
   d. Send refund request to bank
   e. Bank returns refund_id
   f. Update ledger with refund status
3. Response: {refund_id, status: processing}
4. Webhook: payment.refunded event sent to merchant
```

**Idempotency**: Refunds also use idempotency keys (prevent double refunds).

**Database Schema:**

```sql
CREATE TABLE refunds (
    refund_id VARCHAR(32) PRIMARY KEY,
    payment_id VARCHAR(32) NOT NULL,
    amount_cents BIGINT NOT NULL,
    reason VARCHAR(255),
    status VARCHAR(20),  -- pending, completed, failed
    created_at TIMESTAMP DEFAULT NOW(),
    completed_at TIMESTAMP,
    FOREIGN KEY (payment_id) REFERENCES payments(payment_id),
    INDEX (payment_id)
);
```

### 6.2 Chargebacks

**Definition**: Customer disputes charge with bank (not merchant).

**Chargeback Reasons:**

- Fraudulent transaction
- Product not received
- Product not as described
- Duplicate charge

**Flow:**

```
1. Bank notifies payment gateway of chargeback
2. Gateway creates chargeback record
3. Gateway sends webhook to merchant: payment.dispute.created
4. Merchant has 7-21 days to provide evidence
5. If merchant wins ‚Üí funds returned
6. If merchant loses ‚Üí funds deducted, chargeback fee applied ($15-$25)
```

**Impact:**

- **High chargeback rate** (> 1%) ‚Üí Gateway may terminate merchant
- **Chargeback fees**: $15-$25 per chargeback
- **Reserve funds**: Gateway may hold 10% of revenue as reserve

*See pseudocode.md::process_chargeback() for implementation*

---

## 7. Multi-Currency Support

**Challenge**: Support 150+ currencies with accurate conversion rates.

**Components:**

1. **Exchange Rate Service**:
    - Fetch rates from providers (e.g., Open Exchange Rates API)
    - Cache rates in Redis (TTL: 1 hour)
    - Update rates every 30 minutes

2. **Presentment Currency vs Settlement Currency**:
    - **Presentment**: Currency shown to customer (EUR)
    - **Settlement**: Currency paid to merchant (USD)
    - Gateway handles conversion

**Example:**

```
Customer in Europe:
- Sees: ‚Ç¨100.00
- Exchange rate: 1 EUR = 1.10 USD
- Merchant receives: $110.00
- Fee (2.9% + $0.30): $3.49
- Net to merchant: $106.51
```

**Database Schema:**

```sql
CREATE TABLE exchange_rates (
    rate_id BIGSERIAL PRIMARY KEY,
    base_currency CHAR(3),  -- USD
    quote_currency CHAR(3),  -- EUR
    rate DECIMAL(18, 8),  -- 0.90909091
    valid_from TIMESTAMP,
    valid_until TIMESTAMP,
    INDEX (base_currency, quote_currency, valid_from)
);
```

*See pseudocode.md::convert_currency() for implementation*

---

## 8. Webhook System

**Purpose**: Notify merchants of async events (payment captured, refund completed).

**Events:**

- `payment.authorized`
- `payment.captured`
- `payment.failed`
- `payment.refunded`
- `payment.dispute.created`

**Delivery Guarantees:**

- **At-least-once delivery**: Retry up to 10 times with exponential backoff
- **Signature verification**: HMAC-SHA256 signature in header
- **Idempotency**: Merchant should handle duplicate events

**Flow:**

```
1. Event occurs (payment captured)
2. Create webhook job in queue (Kafka)
3. Webhook Worker picks up job
4. Send POST request to merchant endpoint
5. If success (HTTP 200) ‚Üí Mark as delivered
6. If failure (HTTP 5xx, timeout) ‚Üí Retry with backoff
7. After 10 retries ‚Üí Mark as failed, alert merchant
```

**Retry Schedule:**

- Attempt 1: Immediate
- Attempt 2: 1 minute later
- Attempt 3: 5 minutes later
- Attempt 4: 30 minutes later
- Attempt 5-10: 1 hour, 6 hours, 12 hours, 24 hours

*See pseudocode.md::deliver_webhook() for implementation*

---

## 9. Availability and Fault Tolerance

### 9.1 Database Failover

**Setup**: Multi-master PostgreSQL cluster (3 nodes per shard).

**Failure Scenario:**

```
Normal:
  Primary (writes + reads) ‚Üí Replica 1 (reads) ‚Üí Replica 2 (reads)

Primary Fails:
  1. Health check detects failure (< 10 seconds)
  2. Replica 1 promoted to primary (automatic)
  3. Traffic routed to new primary
  4. Failed node replaced

RTO: < 30 seconds
RPO: 0 (synchronous replication to at least 1 replica)
```

### 9.2 Circuit Breaker for Bank API

**Problem**: Bank API slow/unavailable ‚Üí our system backs up.

**Solution**: Circuit breaker pattern.

**States:**

1. **Closed** (normal): All requests go through
2. **Open** (bank down): Fail fast, don't call bank
3. **Half-Open** (testing): Send test request after cooldown

**Configuration:**

- **Failure threshold**: 50% error rate over 10 seconds
- **Cooldown**: 60 seconds
- **Success threshold**: 5 consecutive successes to close circuit

*See pseudocode.md::circuit_breaker() for implementation*

---

## 10. Bottlenecks and Optimizations

### 10.1 Database Write Contention

**Problem**: 20k writes/sec to single database ‚Üí bottleneck.

**Solution**: Aggressive sharding by `merchant_id`.

**Sharding Strategy:**

```
Shard = hash(merchant_id) % 64

Each shard:
- Primary: 300 writes/sec
- Replica 1: Read queries
- Replica 2: Read queries

Total capacity: 64 shards √ó 300 writes/sec = 19,200 writes/sec
```

**Shard Rebalancing**: When adding shards, use consistent hashing to minimize data movement.

### 10.2 Hot Merchant Problem

**Problem**: Large merchant (Amazon) generates 50% of traffic ‚Üí single shard overloaded.

**Solution**: Sub-sharding for hot merchants.

```
Normal merchant: hash(merchant_id) % 64
Hot merchant: hash(merchant_id + transaction_id) % 256

Result: Hot merchant split across 4 shards (256/64)
```

### 10.3 Latency to Bank Processors

**Problem**: Bank API latency varies (100ms to 2 seconds).

**Solution**: Smart routing + multiple processors.

**Implementation:**

```
1. Track latency per processor:
   - Visa: p95 = 200ms
   - Mastercard: p95 = 300ms
   - Amex: p95 = 500ms

2. Route based on card brand and latency:
   - Visa card ‚Üí Route to fastest Visa processor
   - Mastercard ‚Üí Route to fastest Mastercard processor

3. Failover:
   - If primary processor down ‚Üí route to backup
   - If all processors down ‚Üí return error (don't retry indefinitely)
```

*See pseudocode.md::route_to_processor() for implementation*

---

## 11. Common Anti-Patterns

### ‚ùå **1. Using Floats for Money**

**Problem**: Floating-point arithmetic is imprecise.

```
0.1 + 0.2 = 0.30000000000000004  // JavaScript, Python, etc.
```

**Impact**: Rounding errors accumulate over millions of transactions.

**Solution**: Store amounts as **cents** (integers).

```
‚úÖ CORRECT:
amount_cents = 10050  // $100.50
amount_cents = 99  // $0.99

‚ùå WRONG:
amount_dollars = 100.50  // Precision loss
```

### ‚ùå **2. Skipping Idempotency**

**Problem**: Network failures cause retries ‚Üí double charges.

**Impact**: Customer charged twice, chargebacks, reputation damage.

**Solution**: Always require `idempotency_key` for mutation operations.

```
‚úÖ CORRECT:
POST /payments
{
  "amount": 10000,
  "currency": "usd",
  "idempotency_key": "idem_abc123"  // Required
}

‚ùå WRONG:
POST /payments
{
  "amount": 10000,
  "currency": "usd"
  // No idempotency key ‚Üí retry doubles charge
}
```

### ‚ùå **3. Storing Raw Credit Cards**

**Problem**: PCI-DSS Level 1 certification costs millions, increases liability.

**Solution**: Tokenize immediately, never store raw cards.

```
‚úÖ CORRECT:
tokens_db[tok_abc123] = AES-256("4111111111111111")

‚ùå WRONG:
payments_db[payment_id] = {
  card_number: "4111111111111111"  // Massive PCI scope
}
```

### ‚ùå **4. Missing Audit Trail**

**Problem**: Can't reconcile with bank statements, fails audits.

**Solution**: Append-only event log for every state change.

```
‚úÖ CORRECT:
payment_events:
- event_id=1: status=pending ‚Üí authorized
- event_id=2: status=authorized ‚Üí captured
- event_id=3: status=captured ‚Üí refunded

‚ùå WRONG:
UPDATE payments SET status='refunded'  // Lost history
```

### ‚ùå **5. Synchronous Webhook Delivery**

**Problem**: Merchant webhook endpoint down ‚Üí block payment flow.

**Solution**: Async webhook delivery with retries.

```
‚úÖ CORRECT:
1. Capture payment
2. Publish webhook event to Kafka
3. Return success to customer
4. Worker delivers webhook async

‚ùå WRONG:
1. Capture payment
2. Call merchant webhook (blocking)
3. If webhook fails ‚Üí fail entire payment
```

---

## 12. Alternative Approaches

### Alternative 1: Event Sourcing for Ledger

**Approach**: Store every state change as event, derive current state by replaying events.

**Pros:**

- Perfect audit trail
- Can replay history
- Time-travel queries

**Cons:**

- Complex to implement
- Read queries slower (need to replay)
- Harder to debug

**When to Use**: If audit trail is critical (regulatory requirements).

### Alternative 2: Blockchain for Transparency

**Approach**: Use blockchain for immutable transaction ledger.

**Pros:**

- Cryptographically immutable
- Distributed trust

**Cons:**

- Slow (Bitcoin: 7 TPS, Ethereum: 15 TPS)
- Expensive (gas fees)
- Overkill for centralized system

**When to Use**: Multi-party settlement (inter-bank transfers).

### Alternative 3: Outsource to Processor

**Approach**: Use existing processor (Adyen, Stripe) instead of building.

**Pros:**

- Fast time-to-market
- PCI compliance handled
- Existing integrations

**Cons:**

- Higher fees (2.9% + $0.30 vs 0.5% internal)
- Less control
- Vendor lock-in

**When to Use**: Small businesses, rapid prototyping.

---

## 13. Monitoring and Observability

### Key Metrics

**Business Metrics:**

| Metric                         | Target       | Alert Threshold |
|--------------------------------|--------------|-----------------|
| **Authorization Success Rate** | > 98%        | < 95%           |
| **Capture Success Rate**       | > 99.5%      | < 99%           |
| **Fraud Detection Rate**       | 0.1% blocked | > 1% blocked    |
| **Chargeback Rate**            | < 0.5%       | > 1%            |
| **Average Transaction Value**  | $50          | -20% change     |

**System Metrics:**

| Metric                         | Target  | Alert Threshold |
|--------------------------------|---------|-----------------|
| **API Latency (p95)**          | < 500ms | > 1000ms        |
| **Database Query Time (p95)**  | < 50ms  | > 200ms         |
| **Idempotency Cache Hit Rate** | > 80%   | < 50%           |
| **Webhook Delivery Rate**      | > 99%   | < 95%           |

**Dashboards:**

1. **Transaction Health**:
    - Authorization rate (by card brand)
    - Latency breakdown (API ‚Üí Bank ‚Üí DB)
    - Error rate by error type

2. **Financial Health**:
    - Revenue per hour
    - Refund rate
    - Chargeback rate

3. **Infrastructure**:
    - Database CPU/memory
    - Redis cache hit rate
    - Kafka lag

**Alerting:**

- **Critical**: Authorization rate < 95% ‚Üí Page on-call
- **High**: Latency > 1s ‚Üí Slack alert
- **Medium**: Fraud rate spike ‚Üí Email security team

---

## 14. Trade-offs Summary

| Decision                    | What We Gain                                   | What We Sacrifice                     |
|-----------------------------|------------------------------------------------|---------------------------------------|
| **Authorization + Capture** | ‚úÖ Merchant flexibility (cancel before capture) | ‚ùå Two API calls, more complexity      |
| **Tokenization**            | ‚úÖ PCI scope reduction (cheaper compliance)     | ‚ùå Additional service to maintain      |
| **PostgreSQL Ledger**       | ‚úÖ ACID guarantees, audit trail                 | ‚ùå Harder to scale (need sharding)     |
| **Idempotency Keys**        | ‚úÖ Exactly-once processing                      | ‚ùå Client must generate UUIDs          |
| **Async Webhooks**          | ‚úÖ Non-blocking payment flow                    | ‚ùå Merchant must handle async events   |
| **Sharded Database**        | ‚úÖ Horizontal scaling                           | ‚ùå Cross-shard queries difficult       |
| **Multi-Region**            | ‚úÖ Low latency globally                         | ‚ùå Complex replication, data residency |
| **Real-Time Fraud**         | ‚úÖ Block fraud before capture                   | ‚ùå Adds 50ms latency                   |

---

## 15. Real-World Examples

### Stripe

**Architecture:**

- Ruby on Rails monolith (initially), now microservices
- PostgreSQL for ledger (sharded by merchant)
- Redis for idempotency
- Real-time fraud detection (Radar)
- 99.99% uptime SLA

**Scale:**

- $640B payment volume (2021)
- 100+ countries
- Millions of merchants

**Key Innovation**: Developer-first API (simple integration).

### PayPal

**Architecture:**

- Java microservices
- Oracle database (historically), now moving to distributed systems
- Multi-region active-active
- Fraud detection with ML (PayPal Risk Models)

**Scale:**

- $1.36T payment volume (2021)
- 400M active accounts
- 30M merchants

**Key Innovation**: Buyer/seller protection, dispute resolution.

### Square

**Architecture:**

- Microservices (Go, Ruby)
- MySQL for transactions
- Point-of-sale hardware integration
- Real-time analytics

**Scale:**

- $112B payment volume (2020)
- 2M active merchants
- Focus on small businesses

**Key Innovation**: Unified commerce (online + offline).

---

## 16. References

**Related Chapters:**

- [2.1.1 PostgreSQL Deep Dive](../../02-components/2.1-databases/2.1.1-postgresql-deep-dive.md) - ACID transactions
- [2.1.7 Redis Deep Dive](../../02-components/2.2-caching/2.2.1-redis-deep-dive.md) - Idempotency cache
- [2.3.2 Kafka Deep Dive](../../02-components/2.3-messaging-streaming/2.3.2-kafka-deep-dive.md) - Event streaming
- [1.1.4 Consistency Models](../../01-principles/1.1.4-consistency-models.md) - ACID vs BASE
- [1.2.3 Security Patterns](../../01-principles/1.2.3-security-patterns.md) - Encryption, tokenization

**External Resources:**

- **Stripe API Documentation**: https://stripe.com/docs/api
- **PCI-DSS Standards**: https://www.pcisecuritystandards.org/
- **Payment Card Industry**: https://en.wikipedia.org/wiki/Payment_card_industry
- **Idempotency in APIs**: https://stripe.com/blog/idempotency

**Books:**

- *Designing Data-Intensive Applications* by Martin Kleppmann (Chapter 7: Transactions)
- *Site Reliability Engineering* by Google (Chapter 21: Handling Overload)

**Papers:**

- *TAO: Facebook's Distributed Data Store for the Social Graph* (cache invalidation)
- *Spanner: Google's Globally-Distributed Database* (distributed transactions)

---

## 17. Deployment and Infrastructure

### 18.1 Multi-Region Deployment Strategy

**Region Selection:**

- **US-East-1** (Virginia): Primary region, largest capacity
- **US-West-2** (Oregon): Secondary US region for failover
- **EU-West-1** (Ireland): European users, GDPR compliance
- **AP-Southeast-1** (Singapore): Asian users

**Active-Active Configuration:**

```
Each Region:
‚îú‚îÄ‚îÄ API Gateway (10 instances per AZ √ó 3 AZs = 30 instances)
‚îú‚îÄ‚îÄ Payment Service (20 instances per AZ √ó 3 AZs = 60 instances)
‚îú‚îÄ‚îÄ Tokenization Service (5 instances per AZ √ó 3 AZs = 15 instances)
‚îú‚îÄ‚îÄ Fraud Detection (3 instances per AZ √ó 3 AZs = 9 instances)
‚îú‚îÄ‚îÄ PostgreSQL Shards (16 shards √ó 3 replicas = 48 nodes)
‚îú‚îÄ‚îÄ Redis Cluster (3 masters + 3 replicas = 6 nodes)
‚îî‚îÄ‚îÄ Kafka Cluster (5 brokers √ó 3 AZs = 15 brokers)
```

**Cross-Region Replication:**

1. **Database Replication**: Async replication with 1-2 second lag
2. **Cache Invalidation**: Pub/sub pattern via Kafka
3. **S3 Cross-Region Replication**: For logs and audit trails
4. **Route53 Latency-Based Routing**: Route users to nearest region

**Disaster Recovery:**

- **RTO** (Recovery Time Objective): 5 minutes
- **RPO** (Recovery Point Objective): 0 (synchronous within region, async cross-region)
- **Backup Strategy**: Continuous backups to S3, daily snapshots
- **Runbook**: Automated failover scripts tested quarterly

### 18.2 Database Sharding Implementation

**Shard Mapping Table:**

```sql
CREATE TABLE shard_map (
    merchant_id VARCHAR(32) PRIMARY KEY,
    shard_id INT NOT NULL,
    shard_host VARCHAR(255),
    shard_port INT,
    created_at TIMESTAMP DEFAULT NOW(),
    INDEX (shard_id)
);
```

**Shard Router Service:**

```
Request Flow:
1. Client: POST /payments {merchant_id, amount, ...}
2. API Gateway ‚Üí Shard Router
3. Shard Router:
   - Compute: shard_id = hash(merchant_id) % 64
   - Lookup: shard_host = shard_map[shard_id]
   - Route request to correct shard
4. PostgreSQL Shard: Process payment
5. Response back through router
```

**Consistent Hashing for Shard Rebalancing:**

When adding new shards (e.g., 64 ‚Üí 128):

```
Old: shard = hash(merchant_id) % 64
New: shard = hash(merchant_id) % 128

Only ~50% of merchants move (not 100%)
- Merchants 0-63 stay in same shards
- Merchants 64-127 move to new shards

Migration strategy:
1. Deploy new shards (64-127)
2. Stream replication from old shards
3. Switch reads to new shards (dual-write period)
4. Switch writes to new shards
5. Remove old shard mappings
```

---

## 18. Advanced Features

### 19.1 3D Secure (3DS) Authentication

**Purpose**: Additional authentication layer for high-risk transactions.

**Flow:**

```
1. Risk score indicates medium risk (0.5-0.8)
2. Payment Service redirects to 3DS challenge
3. Customer enters OTP sent to phone
4. Bank verifies OTP
5. If success ‚Üí liability shifts to bank (no chargeback risk)
6. If failure ‚Üí transaction declined

Benefits:
- Reduces fraud
- Shifts chargeback liability to issuing bank
- Required for SCA (Strong Customer Authentication) in EU
```

**Implementation:**

```
Authorization with 3DS:
1. POST /payments {amount, card_token, ...}
2. Fraud score: 0.65 (medium risk)
3. Response: {status: requires_action, next_action: {type: "3ds", url: "..."}}
4. Client redirects to 3DS URL
5. Customer completes challenge
6. Callback: POST /payments/{id}/confirm
7. Complete authorization
8. Response: {status: authorized}
```

*See pseudocode.md::handle_3ds_challenge() for implementation*

### 19.2 Recurring Payments / Subscriptions

**Use Case**: Netflix, Spotify subscriptions.

**Components:**

1. **Subscription Service**: Manages billing cycles
2. **Scheduler**: Cron job to charge subscriptions
3. **Retry Logic**: Retry failed charges with exponential backoff

**Subscription Lifecycle:**

```
1. Create Subscription:
   POST /subscriptions {
     customer_id,
     plan_id,  // monthly, annual
     payment_method: tok_abc123
   }

2. Store Subscription:
   subscriptions_db[sub_123] = {
     customer: customer_456,
     plan: plan_monthly_$9.99,
     payment_method: tok_abc123,
     current_period_start: 2024-01-01,
     current_period_end: 2024-02-01,
     status: active
   }

3. Billing Cycle (Daily Cron at 00:00 UTC):
   - Query: SELECT * FROM subscriptions WHERE current_period_end = TODAY()
   - For each subscription:
     a. Charge payment method
     b. If success ‚Üí Extend period (current_period_end + 1 month)
     c. If failure ‚Üí Retry with backoff (3 attempts over 7 days)
     d. If all fail ‚Üí Mark subscription as past_due
     e. Send webhook: invoice.payment_failed
     f. After 30 days past_due ‚Üí Cancel subscription

4. Customer Update:
   - Update payment method: PUT /subscriptions/{id}
   - Cancel subscription: DELETE /subscriptions/{id}
   - Resume subscription: POST /subscriptions/{id}/resume
```

**Retry Strategy:**

```
Attempt 1: Day 0 (billing date)
Attempt 2: Day 3
Attempt 3: Day 7
If all fail: Mark past_due, email customer
After 30 days: Cancel subscription
```

**Schema:**

```sql
CREATE TABLE subscriptions (
    subscription_id VARCHAR(32) PRIMARY KEY,
    customer_id VARCHAR(32) NOT NULL,
    plan_id VARCHAR(32),
    payment_method_token VARCHAR(32),
    status VARCHAR(20),  -- active, past_due, canceled
    current_period_start DATE,
    current_period_end DATE,
    cancel_at_period_end BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP,
    canceled_at TIMESTAMP,
    INDEX (customer_id),
    INDEX (current_period_end, status)
);
```

*See pseudocode.md::process_subscription_billing() for implementation*

### 19.3 Payment Links

**Use Case**: Send payment link via email/SMS (no website needed).

**Flow:**

```
1. Merchant: POST /payment_links {
     amount: 5000,  // $50.00
     description: "Consultation fee",
     success_url: "https://merchant.com/success"
   }

2. Response: {
     link_id: "plink_abc123",
     url: "https://pay.gateway.com/plink_abc123",
     expires_at: "2024-01-08"  // 7 days
   }

3. Merchant sends link to customer via email

4. Customer clicks link ‚Üí Hosted payment page
   - Enter card details
   - Submit payment
   - Gateway processes payment
   - Redirect to success_url

5. Merchant receives webhook: payment.succeeded
```

**Hosted Payment Page:**

- **PCI Scope**: Gateway-hosted (merchant doesn't handle cards)
- **Customization**: Merchant logo, colors, terms
- **Security**: TLS 1.3, CSP headers, rate limiting
- **Mobile-Optimized**: Responsive design

**Schema:**

```sql
CREATE TABLE payment_links (
    link_id VARCHAR(32) PRIMARY KEY,
    merchant_id VARCHAR(32) NOT NULL,
    amount_cents BIGINT,
    currency CHAR(3),
    description TEXT,
    success_url TEXT,
    status VARCHAR(20),  -- active, paid, expired
    expires_at TIMESTAMP,
    payment_id VARCHAR(32),  -- Populated after payment
    created_at TIMESTAMP,
    INDEX (merchant_id, status),
    INDEX (expires_at, status)
);
```

*See pseudocode.md::create_payment_link() for implementation*

### 19.4 Split Payments (Marketplace Model)

**Use Case**: Uber, Airbnb, Stripe Connect.

**Scenario**:

- Customer pays $100 to platform (Uber)
- Platform takes $20 commission
- Driver receives $80

**Flow:**

```
1. Create Connected Account (Driver):
   POST /accounts {
     type: "express",
     country: "US",
     email: "driver@example.com"
   }
   Response: {account_id: "acct_123"}

2. Onboard Driver:
   - Collect tax information (W-9, SSN)
   - Bank account details for payouts
   - Identity verification (KYC)

3. Customer Payment:
   POST /payments {
     amount: 10000,  // $100
     application_fee_amount: 2000,  // $20 platform fee
     on_behalf_of: "acct_123",  // Driver account
     transfer_data: {
       destination: "acct_123"
     }
   }

4. Money Flow:
   - Customer charged: $100
   - Platform receives: $20 (application fee)
   - Driver receives: $80 (transferred automatically)

5. Payout to Driver:
   - Automatic daily payout to driver's bank account
   - Or on-demand payout: POST /payouts {amount: 8000, destination: bank_account}
```

**Revenue Split Models:**

1. **Direct Charge + Transfer**:
    - Platform charges customer
    - Platform transfers to merchant
    - Pro: Platform controls funds
    - Con: Platform liable for chargebacks

2. **Destination Charge**:
    - Merchant charges customer
    - Platform takes application fee
    - Pro: Merchant liable for chargebacks
    - Con: Merchant needs full account

**Schema:**

```sql
CREATE TABLE connected_accounts (
    account_id VARCHAR(32) PRIMARY KEY,
    type VARCHAR(20),  -- express, standard, custom
    country CHAR(2),
    email VARCHAR(255),
    verification_status VARCHAR(20),  -- pending, verified
    payout_schedule VARCHAR(20),  -- daily, weekly, monthly
    default_currency CHAR(3),
    created_at TIMESTAMP
);

CREATE TABLE transfers (
    transfer_id VARCHAR(32) PRIMARY KEY,
    payment_id VARCHAR(32),
    source_account_id VARCHAR(32),  -- Platform
    destination_account_id VARCHAR(32),  -- Merchant
    amount_cents BIGINT,
    currency CHAR(3),
    status VARCHAR(20),  -- pending, paid, failed
    created_at TIMESTAMP,
    FOREIGN KEY (payment_id) REFERENCES payments(payment_id)
);
```

*See pseudocode.md::create_transfer() for implementation*

---

## 19. Performance Optimization

### 20.1 Database Connection Pooling

**Problem**: Opening new DB connection per request is slow (100ms handshake).

**Solution**: Connection pool (reuse connections).

**Configuration:**

```
Connection Pool Settings:
- Min connections: 50 per instance
- Max connections: 200 per instance
- Connection timeout: 30 seconds
- Idle timeout: 10 minutes
- Max lifetime: 30 minutes

With 60 Payment Service instances:
- Total connections: 60 √ó 200 = 12,000
- Per shard (64 shards): 12,000 / 64 = 187 connections per shard
- PostgreSQL max_connections: 500 (safe margin)
```

### 20.2 Read Replicas for Analytics

**Problem**: Merchant dashboard queries slow down payment processing.

**Solution**: Route analytics queries to read replicas.

**Architecture:**

```
Payment Flow (Write Path):
  API ‚Üí Primary DB (writes)

Analytics Flow (Read Path):
  Dashboard ‚Üí Read Replica (reads)

Replication:
  Primary ‚Üí Replica 1 (async, lag < 1s)
  Primary ‚Üí Replica 2 (async, lag < 1s)
```

### 20.3 Caching Strategy

**Multi-Level Cache:**

```
Level 1: Application Cache (in-memory, per instance)
  - Exchange rates (TTL: 1 hour)
  - Merchant configs (TTL: 10 minutes)
  - Size: 100 MB per instance

Level 2: Redis Cache (distributed)
  - Idempotency keys (TTL: 24 hours)
  - Token metadata (TTL: 1 hour)
  - Fraud features (TTL: 5 minutes)
  - Size: 50 GB cluster

Level 3: Database
  - Source of truth
```

### 20.4 API Rate Limiting

**Strategy**: Token bucket algorithm per merchant.

**Limits:**

```
Tier 1 (Small Merchants):
- 100 requests/second
- 10,000 requests/hour

Tier 2 (Medium Merchants):
- 1,000 requests/second
- 100,000 requests/hour

Tier 3 (Enterprise):
- 10,000 requests/second
- 1,000,000 requests/hour
```

**Implementation:**

```
Redis-based token bucket:

1. Request arrives for merchant_123
2. Check: INCR rate_limit:merchant_123:second
3. If count > limit ‚Üí HTTP 429 (Too Many Requests)
4. Else ‚Üí Process request
5. Set TTL: EXPIRE rate_limit:merchant_123:second 1

Response Headers:
  X-RateLimit-Limit: 100
  X-RateLimit-Remaining: 87
  X-RateLimit-Reset: 1609459200
```

*See pseudocode.md::check_rate_limit() for implementation*

---

## 20. Interview Discussion Points

### Question 1: How do you prevent double charging?

**Answer**: Idempotency keys.

**Deep Dive:**

1. Client generates UUID for each request
2. Server checks Redis cache for key
3. If exists ‚Üí return cached result
4. If not ‚Üí process payment, cache result with 24h TTL
5. Scope: per merchant (merchant_A and merchant_B can use same key)

**Follow-up**: What if Redis fails?

- Graceful degradation: Query database for duplicate payment_id
- Slower but still correct
- Alert ops team to restore Redis

### Question 2: Why PostgreSQL instead of NoSQL?

**Answer**: ACID guarantees required for financial transactions.

**Deep Dive:**

- **Atomicity**: All-or-nothing (can't partially charge)
- **Consistency**: Referential integrity (payments reference valid tokens)
- **Isolation**: Concurrent transactions don't interfere
- **Durability**: Committed transactions survive crashes

**NoSQL Trade-offs:**

- Cassandra: Eventual consistency (unacceptable for money)
- DynamoDB: Limited transactions (max 25 items)
- MongoDB: Recently added transactions, but less mature

**Scaling PostgreSQL:**

- Horizontal sharding by merchant_id (64 shards)
- Each shard: 300 writes/sec (total 19,200 writes/sec)
- Read replicas for analytics queries

### Question 3: How do you handle bank API failures?

**Answer**: Circuit breaker pattern + multiple processors.

**Deep Dive:**

**Circuit Breaker States:**

1. **Closed** (normal): All requests go through
2. **Open** (bank down): Fail fast, return error immediately
3. **Half-Open** (testing): Send test request after cooldown

**Configuration:**

- Failure threshold: 50% error rate over 10 seconds
- Cooldown: 60 seconds
- Success threshold: 5 consecutive successes to close

**Multiple Processors:**

- Visa processor A (primary)
- Visa processor B (backup)
- If both fail ‚Üí return error (don't retry indefinitely)

### Question 4: How do you scale to 20k QPS?

**Answer**: Multi-level approach.

**Horizontal Scaling:**

1. **API Gateway**: 100 instances behind load balancer
2. **Payment Service**: 200 instances (stateless)
3. **Database**: 64 shards (300 writes/sec each)
4. **Redis**: 10-node cluster (200k ops/sec)

**Vertical Optimizations:**

1. **Connection Pooling**: Reuse DB connections (avoid 100ms handshake)
2. **Caching**: Redis for idempotency (1ms vs 10ms DB query)
3. **Async Webhooks**: Don't block payment flow on merchant endpoint
4. **Read Replicas**: Route analytics to replicas (offload primary)

**Bottleneck Identification:**

- Monitor: Latency, error rate, resource utilization
- Profiling: Flame graphs to find slow code paths
- Load testing: Identify breaking points before production

### Question 5: How do you ensure PCI-DSS compliance?

**Answer**: Tokenization + network segmentation.

**Strategy:**

1. **Minimize Scope**:
    - Only Tokenization Service stores cards
    - Payment Service never sees raw cards (only tokens)
    - Smaller scope = cheaper compliance

2. **Secure Tokenization Service**:
    - Isolated VPC (no internet access)
    - Hardware Security Module (HSM) for keys
    - Encrypted at rest (AES-256) and in transit (TLS 1.3)
    - Access logged to immutable audit log

3. **Regular Audits**:
    - Annual PCI-DSS assessment by QSA (Qualified Security Assessor)
    - Quarterly vulnerability scans by ASV (Approved Scanning Vendor)
    - Penetration testing annually

4. **Employee Training**:
    - Security awareness training for all employees
    - PCI-specific training for engineers with card access
    - Background checks for personnel with access