# 3.1.3 Design a Distributed ID Generator (Snowflake)

## Problem Statement

Design a highly available, distributed ID generation service similar to Twitter's Snowflake that can generate globally
unique,
time-sortable, 64-bit integer IDs at scale. The system must generate millions of IDs per second across multiple data
centers while maintaining uniqueness guarantees without requiring coordination between nodes during ID generation.

---

## 1. Requirements and Scale Estimation

### Functional Requirements (FRs)

| Requirement           | Description                                                          | Priority    |
|-----------------------|----------------------------------------------------------------------|-------------|
| **Global Uniqueness** | Every generated ID must be globally unique across all data centers   | Must Have   |
| **Numerical**         | IDs must be 64-bit integers (BIGINT) for efficient database indexing | Must Have   |
| **Time-Sortable**     | Newer IDs should be numerically greater than older IDs (roughly)     | Must Have   |
| **No Coordination**   | ID generation should not require inter-node communication            | Must Have   |
| **High Availability** | Service must remain available even if some nodes fail                | Must Have   |
| **K-Sortable**        | IDs generated within same time window should be roughly sortable     | Should Have |

### Non-Functional Requirements (NFRs)

| Requirement           | Target                | Rationale                                 |
|-----------------------|-----------------------|-------------------------------------------|
| **Low Latency**       | < 1 ms per ID         | Should not slow down application          |
| **High Throughput**   | 100K IDs/sec per node | Support high-traffic applications         |
| **High Availability** | 99.999% uptime        | ID generation failure stops entire system |
| **Scalability**       | Linear horizontal     | Add nodes without coordination overhead   |
| **Clock Tolerance**   | Handle clock drift    | Real-world clocks are never perfect       |

---

### Scale Estimation

#### Scenario: Large Social Media Platform

| Metric                  | Assumption               | Calculation                | Result                   |
|-------------------------|--------------------------|----------------------------|--------------------------|
| **Average QPS**         | 10K writes/sec baseline  | 10,000 QPS                 | **10K IDs/sec**          |
| **Peak QPS**            | 10x burst during events  | 10,000 × 10                | **100K IDs/sec peak**    |
| **Daily IDs**           | 10K QPS sustained        | 10,000 × 86,400 sec/day    | **~864 million IDs/day** |
| **IDs per Node**        | 10 nodes sharing load    | 100K / 10                  | **10K IDs/sec per node** |
| **IDs per Millisecond** | Per node capacity        | 10,000 / 1,000 ms          | **10 IDs/ms per node**   |
| **Sequence Bits**       | Support 4096 IDs/ms      | 2^12 = 4096                | **12 bits sufficient**   |
| **Timestamp Lifespan**  | 41 bits at 1ms precision | 2^41 / (1000×60×60×24×365) | **~69 years**            |
| **Total Nodes**         | 10 bits for node ID      | 2^10                       | **Up to 1024 nodes**     |

#### Back-of-the-Envelope Calculations

```
64-bit ID Structure:
├─ 1 bit (sign): Always 0 (positive number)
├─ 41 bits (timestamp): Milliseconds since epoch = 2^41 ms = 69 years
├─ 10 bits (worker ID): Up to 2^10 = 1024 worker nodes
└─ 12 bits (sequence): Up to 2^12 = 4,096 IDs per millisecond per node

Max IDs per second per node = 4,096 × 1,000 = 4,096,000 IDs/sec
Max IDs per second cluster (1024 nodes) = 4.2 billion IDs/sec

Our need: 100K IDs/sec (well within capacity)
```

---

## 2. High-Level Architecture

### System Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                      Application Layer                           │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐        │
│  │  Service │  │  Service │  │  Service │  │  Service │        │
│  │    A     │  │    B     │  │    C     │  │    D     │        │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────┘        │
└───────┼─────────────┼─────────────┼─────────────┼──────────────┘
        │             │             │             │
        └─────────────┴──────┬──────┴─────────────┘
                             │
                    ┌────────▼────────┐
                    │  Load Balancer  │
                    │   (Round Robin) │
                    └────────┬────────┘
                             │
        ┌────────────────────┼────────────────────┐
        │                    │                    │
        ▼                    ▼                    ▼
┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│ ID Generator │     │ ID Generator │     │ ID Generator │
│   Node 1     │     │   Node 2     │     │   Node N     │
│ Worker ID: 1 │     │ Worker ID: 2 │     │ Worker ID: N │
│              │     │              │     │              │
│ ┌──────────┐ │     │ ┌──────────┐ │     │ ┌──────────┐ │
│ │Snowflake │ │     │ │Snowflake │ │     │ │Snowflake │ │
│ │Algorithm │ │     │ │Algorithm │ │     │ │Algorithm │ │
│ └──────────┘ │     │ └──────────┘ │     │ └──────────┘ │
│              │     │              │     │              │
│ Sequence: 0  │     │ Sequence: 0  │     │ Sequence: 0  │
│ Last TS: ... │     │ Last TS: ... │     │ Last TS: ... │
└──────────────┘     └──────────────┘     └──────────────┘
        │                    │                    │
        └────────────────────┼────────────────────┘
                             │
                    ┌────────▼────────┐
                    │  Coordination   │
                    │    Service      │
                    │ (ZooKeeper/etcd)│
                    │                 │
                    │ - Assigns Worker│
                    │   IDs on startup│
                    │ - Health checks │
                    └─────────────────┘
```

### Key Components

| Component                | Responsibility                                    | Technology Options           |
|--------------------------|---------------------------------------------------|------------------------------|
| **ID Generator Node**    | Generate unique IDs using Snowflake algorithm     | Go, Java, Rust (stateless)   |
| **Load Balancer**        | Distribute requests across nodes                  | NGINX, HAProxy, AWS ALB      |
| **Coordination Service** | Assign unique worker IDs, service discovery       | ZooKeeper, etcd, Consul      |
| **Monitoring**           | Track ID generation rate, clock drift, duplicates | Prometheus, Grafana, DataDog |

---

## 3. Detailed Component Design

### 3.1 Snowflake ID Structure

#### 64-bit Layout

```
┌────────────────────────────────────────────────────────────────┐
│ 0 │          41 bits          │  10 bits  │     12 bits       │
│───│───────────────────────────│───────────│───────────────────│
│ S │       Timestamp           │ Worker ID │    Sequence       │
│───│───────────────────────────│───────────│───────────────────│
│ 0 │ Milliseconds since epoch  │  Node ID  │ Counter (0-4095)  │
└────────────────────────────────────────────────────────────────┘

S: Sign bit (always 0 for positive)
```

| Component     | Bits | Range                  | Purpose                                     |
|---------------|------|------------------------|---------------------------------------------|
| **Sign**      | 1    | 0                      | Keep ID positive for Java compatibility     |
| **Timestamp** | 41   | 0 to 2,199,023,255,551 | Milliseconds since custom epoch (~69 years) |
| **Worker ID** | 10   | 0 to 1,023             | Unique node identifier (1024 nodes max)     |
| **Sequence**  | 12   | 0 to 4,095             | Counter within same millisecond per node    |

#### Why This Structure?

**Time-Sortable:**

- Timestamp is the most significant bits
- Newer IDs are naturally greater than older IDs
- Database indexes can efficiently range-scan by ID (which correlates with time)

**Globally Unique:**

- Worker ID ensures different nodes never generate same ID
- Sequence ensures same node can't generate duplicates within millisecond

**Compact:**

- 64-bit fits in BIGINT (standard database type)
- Smaller than UUID (128 bits)
- Efficient for indexing and storage

---

### 3.2 Snowflake Algorithm Implementation

#### Core Algorithm

```
SnowflakeIDGenerator:
  // Constants
  EPOCH = 1577836800000  // January 1, 2020 00:00:00 UTC (milliseconds)
  
  // Bit allocation
  WORKER_ID_BITS = 10
  SEQUENCE_BITS = 12
  
  // Max values
  MAX_WORKER_ID = (2^WORKER_ID_BITS) - 1  // 1023
  MAX_SEQUENCE = (2^SEQUENCE_BITS) - 1    // 4095
  
  // Bit shifts
  TIMESTAMP_SHIFT = WORKER_ID_BITS + SEQUENCE_BITS  // 22
  WORKER_ID_SHIFT = SEQUENCE_BITS                    // 12
  
  // State variables
  worker_id: integer
  sequence: integer = 0
  last_timestamp: integer = -1
  lock: Mutex  // Thread-safe access
  
  
  function initialize(worker_id):
    if worker_id < 0 or worker_id > MAX_WORKER_ID:
      raise error("Worker ID must be between 0 and " + MAX_WORKER_ID)
    
    this.worker_id = worker_id
  
  
  function generate_id():
    acquire_lock(lock):
      timestamp = current_millis()
      
      // Clock moved backwards! Handle clock drift
      if timestamp < last_timestamp:
        offset = last_timestamp - timestamp
        if offset > 5:  // More than 5ms backwards
          raise error("Clock moved backwards by " + offset + "ms. Refusing to generate ID.")
        
        // Wait for clock to catch up
        sleep(offset milliseconds)
        timestamp = current_millis()
      
      // Same millisecond - increment sequence
      if timestamp == last_timestamp:
        sequence = (sequence + 1) AND MAX_SEQUENCE  // Bitmask for wraparound
        
        // Sequence overflow - wait for next millisecond
        if sequence == 0:
          timestamp = wait_next_millis(last_timestamp)
      else:
        // New millisecond - reset sequence
        sequence = 0
      
      last_timestamp = timestamp
      
      // Construct ID using bit operations
      id = ((timestamp - EPOCH) << TIMESTAMP_SHIFT) OR
           (worker_id << WORKER_ID_SHIFT) OR
           sequence
      
      return id
  
  
  function current_millis():
    return current_system_time_in_milliseconds()
  
  
  function wait_next_millis(last_timestamp):
    timestamp = current_millis()
    while timestamp <= last_timestamp:
      timestamp = current_millis()
    return timestamp
  
  
  function parse_id(id):
    // Extract components from ID
    timestamp = ((id >> TIMESTAMP_SHIFT) + EPOCH)
    worker_id = (id >> WORKER_ID_SHIFT) AND MAX_WORKER_ID
    sequence = id AND MAX_SEQUENCE
    
    return {
      timestamp: timestamp,
      timestamp_human: format_timestamp(timestamp),
      worker_id: worker_id,
      sequence: sequence
    }
```

**Example Usage:**
```
generator = SnowflakeIDGenerator(worker_id=1)
id1 = generator.generate_id()

// Output: 123456789012345678

parsed = generator.parse_id(id1)
// Output: {
//   timestamp: 1730000000000,
//   timestamp_human: '2024-10-27 00:00:00',
//   worker_id: 1,
//   sequence: 0
// }
```

---

### 3.3 Worker ID Assignment

#### Challenge

Each generator node needs a unique worker ID (0-1023). How do we assign these without conflicts?

#### Solution 1: Coordination Service (Recommended)

```
WorkerIDManager:
  etcd_client: EtcdClient
  prefix: string = "/snowflake/workers/"
  
  function initialize(etcd_host, etcd_port):
    etcd_client = connect_to_etcd(etcd_host, etcd_port)
  
  function acquire_worker_id(node_hostname):
    // Try to find existing assignment
    existing = etcd_client.get(prefix + node_hostname)
    if existing is not null:
      return parse_int(existing)
    
    // Find available worker ID
    for worker_id from 0 to 1023:
      key = prefix + "id_" + worker_id
      
      // Try to create with lease (TTL for automatic cleanup)
      lease = etcd_client.create_lease(ttl=30_seconds)
      success = etcd_client.put_if_not_exists(key, node_hostname, lease)
      
      if success:
        // Start heartbeat thread to keep lease alive
        start_background_thread(heartbeat(lease))
        
        // Store hostname → worker_id mapping
        etcd_client.put(prefix + node_hostname, worker_id)
        return worker_id
    
    raise error("No available worker IDs")
  
  function heartbeat(lease):
    // Keep lease alive with periodic heartbeat
    while true:
      lease.refresh()
      sleep(10_seconds)  // Refresh every 10 seconds

// Usage
manager = WorkerIDManager(etcd_host="localhost", etcd_port=2379)
worker_id = manager.acquire_worker_id("node-1.example.com")
generator = SnowflakeIDGenerator(worker_id)
```

#### Solution 2: Static Configuration

```yaml
# config.yaml
workers:
  - hostname: node-1.example.com
    worker_id: 1
  - hostname: node-2.example.com
    worker_id: 2
  - hostname: node-3.example.com
    worker_id: 3
```

**Trade-offs:**

| Method                   | Pros                        | Cons                                  |
|--------------------------|-----------------------------|---------------------------------------|
| **Coordination Service** | Dynamic, automatic failover | Dependency on external service        |
| **Static Config**        | Simple, no dependencies     | Manual management, no auto-failover   |
| **MAC Address Hash**     | Automatic, no coordination  | Risk of collisions (birthday paradox) |
| **Database Assignment**  | Centralized, auditable      | Single point of failure, slower       |

---

### 3.4 Clock Synchronization & Drift Handling

#### Problem: Clock Drift

Real-world server clocks drift over time. NTP corrections can cause:

1. **Clock jumps forward**: Minor issue, just larger gap in IDs
2. **Clock jumps backward**: CATASTROPHIC - can cause duplicate IDs!

#### Solution Strategies

**Strategy 1: Refuse to Generate IDs (Conservative)**

```
function generate_id():
  timestamp = current_millis()
  
  if timestamp < last_timestamp:
    offset = last_timestamp - timestamp
    raise error("Clock moved backwards by " + offset + "ms. " +
                "Refusing to generate ID to prevent duplicates.")
  
  // ... rest of algorithm
```

**Strategy 2: Wait for Clock to Catch Up (Tolerant)**

```
MAX_BACKWARD_TOLERANCE_MS = 5

function generate_id():
  timestamp = current_millis()
  
  if timestamp < last_timestamp:
    offset = last_timestamp - timestamp
    
    if offset > MAX_BACKWARD_TOLERANCE_MS:
      raise error("Clock moved backwards by " + offset + "ms")
    
    // Small drift - wait for it
    sleep(offset milliseconds)
    timestamp = current_millis()
  
  // ... rest of algorithm
```

**Strategy 3: Use Last Known Good Timestamp (Aggressive)**

```
function generate_id():
  timestamp = current_millis()
  
  if timestamp < last_timestamp:
    // Continue from last known good timestamp
    timestamp = last_timestamp
    // WARNING: This might exhaust sequence bits faster
  
  // ... rest of algorithm
```

#### Clock Synchronization Best Practices

| Practice                  | Description                    | Benefit              |
|---------------------------|--------------------------------|----------------------|
| **NTP Sync**              | Sync clocks every 1-5 minutes  | Keep drift < 1ms     |
| **Monotonic Clocks**      | Use system monotonic clock API | Never goes backwards |
| **Clock Skew Monitoring** | Alert if drift > 10ms          | Early detection      |
| **Graceful Degradation**  | Handle small backwards jumps   | Better availability  |

---

## 4. Alternative ID Generation Strategies

### Comparison Matrix

| Strategy              | Size    | Sortable          | Performance | Coordination   | Best For             |
|-----------------------|---------|-------------------|-------------|----------------|----------------------|
| **Snowflake**         | 64-bit  | ✅ Time-sorted     | ⭐⭐⭐⭐⭐       | Worker ID only | **Recommended**      |
| **UUID v4**           | 128-bit | ❌ Random          | ⭐⭐⭐⭐        | None           | Simplicity           |
| **UUID v7**           | 128-bit | ✅ Time-sorted     | ⭐⭐⭐⭐        | None           | Sortable UUID needed |
| **ULID**              | 128-bit | ✅ Time-sorted     | ⭐⭐⭐⭐        | None           | UUID alternative     |
| **DB Auto-increment** | 64-bit  | ✅ Strictly sorted | ⭐⭐          | Every insert   | Small scale          |
| **MongoDB ObjectID**  | 96-bit  | ✅ Time-sorted     | ⭐⭐⭐⭐        | None           | MongoDB              |

### Detailed Comparison

#### UUID v4 (Random)

```
// Generate random UUID v4
id = generate_uuid_v4()

// Example: 'f47ac10b-58cc-4372-a567-0e02b2c3d479'
```

**Pros:**

- ✅ Globally unique (virtually impossible to collide)
- ✅ No coordination needed
- ✅ Built into all languages

**Cons:**

- ❌ 128 bits (2x storage of Snowflake)
- ❌ Not sortable (bad for database indexes)
- ❌ Random insertion pattern (poor B-tree performance)

---

#### UUID v7 (Time-ordered)

```
// Generate time-ordered UUID v7
id = generate_uuid_v7()

// Example: '018c4c3c-8f1f-7000-8000-0242ac120002'
//          └───timestamp───┘└────random────┘
```

**Pros:**

- ✅ Time-sortable
- ✅ No coordination needed
- ✅ Better index performance than UUID v4

**Cons:**

- ❌ Still 128 bits
- ❌ Less human-readable

---

#### ULID (Universally Unique Lexicographically Sortable Identifier)

```
// Generate ULID
id = generate_ulid()

// Example: '01ARZ3NDEKTSV4RRFFQ69G5FAV'
```

**Structure:**

```
 01ARZ3NDEKTSV4RRFFQ69G5FAV
 ├─────────┬────────────────┘
 Timestamp   Random (80 bits)
 (48 bits)
```

**Pros:**

- ✅ Time-sortable
- ✅ Lexicographically sortable (as strings)
- ✅ No coordination

**Cons:**

- ❌ 128 bits
- ❌ Less adoption than UUID

---

#### Database Auto-Increment

```sql
CREATE TABLE users (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255)
);

INSERT INTO users (name) VALUES ('Alice');
-- Returns id = 1
```

**Pros:**

- ✅ Simple
- ✅ Strictly monotonic
- ✅ 64-bit

**Cons:**

- ❌ **Single point of failure**
- ❌ **Write bottleneck** (all inserts contend for same sequence)
- ❌ **Doesn't scale horizontally**
- ❌ Requires database round-trip for every ID

---

### When to Use Each

| Scenario                                 | Recommended Strategy | Why                                |
|------------------------------------------|----------------------|------------------------------------|
| **High-scale distributed system**        | Snowflake            | Best performance, sortable, 64-bit |
| **Need strict ordering**                 | DB Auto-increment    | Only option for strict sequence    |
| **Global uniqueness, no coordination**   | UUID v7              | Standard, widely supported         |
| **Small-scale application**              | UUID v4              | Simplest, no infrastructure        |
| **Multi-region, no central coordinator** | ULID or UUID v7      | Sortable without coordination      |
| **MongoDB**                              | ObjectID             | Native support                     |

---

## 5. Handling Edge Cases & Failures

### 5.1 Sequence Exhaustion

**Problem:** Node needs to generate > 4,096 IDs in 1 millisecond

**Solutions:**

**Option 1: Wait for Next Millisecond**

```python
if self.sequence == 0:  # Overflowed
    timestamp = self._wait_next_millis(self.last_timestamp)
```

**Option 2: Increase Sequence Bits (Custom Implementation)**

```
┌─────────────────────────────────────────────┐
│ 1 │  41 bits  │  8 bits   │   14 bits      │
│───│───────────│───────────│────────────────│
│ 0 │ Timestamp │ Worker ID │   Sequence     │
└─────────────────────────────────────────────┘
       69 years     256 nodes    16,384 IDs/ms
```

**Option 3: Add More Worker Nodes**

- 1024 nodes × 4,096 IDs/ms = 4.2 million IDs/ms cluster-wide

---

### 5.2 Worker ID Conflicts

**Problem:** Two nodes accidentally get same worker ID

**Prevention:**

1. **Coordination Service with Leases**
    - etcd/ZooKeeper assigns IDs atomically
    - TTL + heartbeat ensures stale assignments expire

2. **Duplicate Detection**

```python
class IDGeneratorWithDuplicateDetection:
    def __init__(self, worker_id, redis_client):
        self.worker_id = worker_id
        self.redis = redis_client
    
    def generate_id(self) -> int:
        id = self._generate_snowflake_id()
        
        # Check for duplicate (should never happen)
        key = f"id:{id}"
        if not self.redis.setnx(key, self.worker_id):
            # CRITICAL: Duplicate detected!
            self._alert_duplicate(id)
            raise DuplicateIDException(f"Duplicate ID generated: {id}")
        
        # Set expiry (cleanup old IDs)
        self.redis.expire(key, 86400)  # 24 hours
        
        return id
```

---

### 5.3 Clock Drift Monitoring

```python
from prometheus_client import Gauge, Counter

clock_drift_gauge = Gauge('snowflake_clock_drift_ms', 'Clock drift in milliseconds')
clock_backwards_counter = Counter('snowflake_clock_backwards_total', 'Clock moved backwards')

def monitor_clock_drift(self):
    """Run in background thread"""
    while True:
        system_time = self._current_millis()
        ntp_time = self._get_ntp_time()
        
        drift = abs(system_time - ntp_time)
        clock_drift_gauge.set(drift)
        
        if drift > 10:  # >10ms drift
            logger.warning(f"Clock drift detected: {drift}ms")
        
        if drift > 100:  # >100ms drift
            logger.critical(f"CRITICAL clock drift: {drift}ms")
            alert_team("Clock drift critical", drift)
        
        time.sleep(60)  # Check every minute
```

---

## 6. High Availability Architecture

### Multi-Region Deployment

```
Region US-East:
┌────────────────────────────────┐
│  ID Generators (Worker ID 0-99)│
│  ┌──────┐  ┌──────┐  ┌──────┐ │
│  │Node 1│  │Node 2│  │Node N│ │
│  └──────┘  └──────┘  └──────┘ │
└────────────────────────────────┘

Region EU-West:
┌────────────────────────────────┐
│ID Generators (Worker ID 100-199)│
│  ┌──────┐  ┌──────┐  ┌──────┐ │
│  │Node 1│  │Node 2│  │Node N│ │
│  └──────┘  └──────┘  └──────┘ │
└────────────────────────────────┘

Region AP-South:
┌────────────────────────────────┐
│ID Generators (Worker ID 200-299)│
│  ┌──────┐  ┌──────┐  ┌──────┐ │
│  │Node 1│  │Node 2│  │Node N│ │
│  └──────┘  └──────┘  └──────┘ │
└────────────────────────────────┘
```

**Benefits:**

- ✅ Each region operates independently
- ✅ Low latency for local applications
- ✅ No cross-region coordination needed

**Worker ID Allocation by Region:**

- Region 1: Worker IDs 0-339
- Region 2: Worker IDs 340-679
- Region 3: Worker IDs 680-1023

---

## 7. Monitoring & Observability

### Key Metrics

| Metric                  | Target        | Alert Threshold | Why Important          |
|-------------------------|---------------|-----------------|------------------------|
| **Generation Rate**     | Baseline ±20% | > 2x baseline   | Detect unusual traffic |
| **Latency (p99)**       | < 1ms         | > 10ms          | User experience        |
| **Clock Drift**         | < 10ms        | > 50ms          | Duplicate ID risk      |
| **Sequence Resets**     | Per new ms    | > 100/sec       | Sequence exhaustion    |
| **Clock Backwards**     | 0             | > 0             | Critical issue         |
| **Worker ID Conflicts** | 0             | > 0             | Critical issue         |
| **Error Rate**          | < 0.01%       | > 0.1%          | Service health         |

### Monitoring Dashboard

```python
from prometheus_client import Counter, Histogram, Gauge

# Metrics
ids_generated = Counter('snowflake_ids_generated_total', 'Total IDs generated')
generation_latency = Histogram('snowflake_generation_seconds', 'ID generation latency')
sequence_resets = Counter('snowflake_sequence_resets_total', 'Sequence number resets')
clock_drift = Gauge('snowflake_clock_drift_milliseconds', 'Clock drift')

class MonitoredSnowflakeGenerator(SnowflakeIDGenerator):
    def generate_id(self) -> int:
        with generation_latency.time():
            id = super().generate_id()
            ids_generated.inc()
            
            if self.sequence == 0:
                sequence_resets.inc()
            
            return id
```

---

## 8. Common Anti-Patterns

### Anti-Pattern 1: Not Handling Clock Backwards

**Problem:**

```python
# ❌ No clock backwards handling
def generate_id(self):
    timestamp = current_millis()
    # What if timestamp < last_timestamp? DUPLICATES!
    self.last_timestamp = timestamp
    return construct_id(timestamp, worker_id, sequence)
```

**Better:**

```python
# ✅ Handle clock backwards
def generate_id(self):
    timestamp = current_millis()
    
    if timestamp < self.last_timestamp:
        raise ClockBackwardsException()
    
    # ... rest of algorithm
```

---

### Anti-Pattern 2: Using System Time Directly

**Problem:**

```python
# ❌ System time can jump
timestamp = int(time.time() * 1000)
```

**Better:**

```python
# ✅ Use monotonic clock (never goes backwards)
import time

def current_millis() -> int:
    # Python 3.7+: monotonic_ns() never goes backwards
    return time.monotonic_ns() // 1_000_000

# Or track last timestamp and max()
def current_millis_safe(self) -> int:
    ts = int(time.time() * 1000)
    return max(ts, self.last_timestamp)
```

---

### Anti-Pattern 3: No Worker ID Coordination

**Problem:**

```python
# ❌ Random worker ID (collision risk!)
worker_id = random.randint(0, 1023)
```

**Better:**

```python
# ✅ Coordinated assignment
worker_id = acquire_worker_id_from_etcd()
```

---

### Anti-Pattern 4: Blocking on ID Generation

**Problem:**

```python
# ❌ Synchronous, blocks application
id = requests.get('http://id-service/generate').json()['id']
```

**Better:**

```python
# ✅ Embed generator in application (no network call)
generator = SnowflakeIDGenerator(worker_id=1)
id = generator.generate_id()  # < 1ms, no network
```

---

## 9. Performance Optimizations

### Batch Generation

```python
def generate_batch(self, count: int) -> List[int]:
    """Generate multiple IDs efficiently"""
    ids = []
    with self.lock:
        for _ in range(count):
            ids.append(self._generate_id_unlocked())
    return ids

# Usage: Generate 1000 IDs at once
ids = generator.generate_batch(1000)
# Much faster than 1000 individual calls
```

### Lock-Free Implementation (Advanced)

```python
import threading

class LockFreeSnowflake:
    def __init__(self, worker_id):
        self.worker_id = worker_id
        # Use atomic operations
        self._counter = threading.local()
    
    def generate_id(self) -> int:
        # Each thread has its own counter (lock-free)
        if not hasattr(self._counter, 'sequence'):
            self._counter.sequence = 0
            self._counter.last_ts = -1
        
        timestamp = current_millis()
        
        if timestamp == self._counter.last_ts:
            self._counter.sequence = (self._counter.sequence + 1) & 4095
        else:
            self._counter.sequence = 0
        
        self._counter.last_ts = timestamp
        
        return construct_id(timestamp, self.worker_id, self._counter.sequence)
```

---

## 10. Implementation in Different Languages

### Java (Spring Boot Service)

```java

@Service
public class SnowflakeService {
    private final long EPOCH = 1577836800000L;
    private final long WORKER_ID_BITS = 10L;
    private final long SEQUENCE_BITS = 12L;
    private final long MAX_WORKER_ID = ~(-1L << WORKER_ID_BITS);
    private final long MAX_SEQUENCE = ~(-1L << SEQUENCE_BITS);

    private final long workerId;
    private long sequence = 0L;
    private long lastTimestamp = -1L;

    public SnowflakeService(long workerId) {
        if (workerId > MAX_WORKER_ID || workerId < 0) {
            throw new IllegalArgumentException("Worker ID out of range");
        }
        this.workerId = workerId;
    }

    public synchronized long generateId() {
        long timestamp = System.currentTimeMillis();

        if (timestamp < lastTimestamp) {
            throw new RuntimeException("Clock moved backwards");
        }

        if (timestamp == lastTimestamp) {
            sequence = (sequence + 1) & MAX_SEQUENCE;
            if (sequence == 0) {
                timestamp = waitNextMillis(lastTimestamp);
            }
        } else {
            sequence = 0;
        }

        lastTimestamp = timestamp;

        return ((timestamp - EPOCH) << 22)
                | (workerId << 12)
                | sequence;
    }

    private long waitNextMillis(long lastTimestamp) {
        long timestamp = System.currentTimeMillis();
        while (timestamp <= lastTimestamp) {
            timestamp = System.currentTimeMillis();
        }
        return timestamp;
    }
}
```

---

## 11. Capacity Planning

### Scaling Guidelines

| Load                   | Worker Nodes | Rationale         |
|------------------------|--------------|-------------------|
| **< 10K IDs/sec**      | 2-3 nodes    | Redundancy for HA |
| **10K - 100K IDs/sec** | 10-20 nodes  | Distribute load   |
| **100K - 1M IDs/sec**  | 50-100 nodes | High throughput   |
| **> 1M IDs/sec**       | 100+ nodes   | Maximum scale     |

### Cost Estimation (AWS)

```
Instance Type: t3.medium (2 vCPU, 4 GB RAM)
Cost: $0.0416/hour

10 nodes × $0.0416/hour × 730 hours/month = $304/month

Load Balancer (ALB): ~$20/month
etcd cluster (3 nodes, t3.micro): ~$20/month

Total: ~$350/month for 100K IDs/sec capacity
```

---

## 12. Trade-offs Summary

| Decision         | Choice         | Alternative    | Why Chosen               | Trade-off                    |
|------------------|----------------|----------------|--------------------------|------------------------------|
| **ID Size**      | 64-bit         | 128-bit UUID   | Smaller, standard BIGINT | Can't store 128-bit metadata |
| **Coordination** | Worker ID only | None           | Prevents collisions      | Needs etcd/ZooKeeper         |
| **Sortability**  | Time-sorted    | Random         | Better DB performance    | Slight predictability        |
| **Generation**   | Local          | Remote service | No network latency       | Need to embed in apps        |
| **Clock Drift**  | Refuse or wait | Continue       | Prevent duplicates       | Temporary unavailability     |

---

## Summary

A distributed ID generator using Snowflake algorithm provides:

**Key Advantages:**

1. ✅ **Globally unique** without coordination during generation
2. ✅ **Time-sortable** for efficient database indexing
3. ✅ **High performance** (< 1ms, millions of IDs/sec)
4. ✅ **64-bit** standard integer (efficient storage)
5. ✅ **Horizontally scalable** (up to 1024 nodes)

**Key Challenges:**

1. ⚠️ Clock synchronization (NTP required)
2. ⚠️ Worker ID management (needs coordination service)
3. ⚠️ Clock backwards handling (graceful degradation)
4. ⚠️ Sequence exhaustion at extreme load per node

**Recommended Stack:**

- **Language:** Go (performance) or Java (enterprise)
- **Coordination:** etcd (lightweight) or ZooKeeper (battle-tested)
- **Clock Sync:** chrony or ntpd
- **Monitoring:** Prometheus + Grafana
- **Deployment:** Embedded in application services (no separate service)

The Snowflake algorithm is the **gold standard** for distributed ID generation in high-scale systems.

